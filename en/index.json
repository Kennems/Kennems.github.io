[{"content":"Java20天速成——进阶课程(3) 文件操作 File对象 常用方法 public static void main(String[] args) { // 创建File对象，表示文件test.txt的绝对路径 File f1 = new File(\u0026#34;D:/JAVA/JavaSeProMax/file-io-app/src/com/showguan/FileDemo/test.txt\u0026#34;); // 创建File对象，表示文件夹JavaSeProMax的绝对路径 File f2 = new File(\u0026#34;D:/JAVA\u0026#34;); // 创建File对象，表示不存在的文件路径t.txt File f3 = new File(\u0026#34;D:/JAVA/t.txt\u0026#34;); // 输出文件f1的长度（字节数） System.out.println(f1.length()); // 输出文件夹f2的长度，由于f2表示文件夹，而不是文件，因此返回值没有意义 System.out.println(f2.length()); // 输出文件f3的长度，由于文件路径不存在，因此返回0 System.out.println(f3.length()); // 检查文件f3是否存在，返回false，因为文件路径不存在 System.out.println(f3.exists()); // 创建File对象，表示相对路径下的文件test.txt // 相对路径默认从当前工程的根目录开始寻找，因此文件路径不存在 File f4 = new File(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\FileDemo\\\\test.txt\u0026#34;); // 检查文件f4是否存在，返回false，因为文件路径不存在 System.out.println(f4.exists()); // 输出文件f4的长度，由于文件路径不存在，因此返回0 System.out.println(f4.length()); } public static void main(String[] args) { // 创建File对象，表示相对路径下的文件test.txt File f1 = new File(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\FileDemo\\\\test.txt\u0026#34;); // 创建File对象，表示文件夹file-io-app的路径 File f2 = new File(\u0026#34;file-io-app\u0026#34;); // 检查文件f1是否存在，返回true，因为文件路径存在 System.out.println(f1.exists()); // 检查f1是否表示一个文件，返回true System.out.println(f1.isFile()); // 检查f1是否表示一个文件夹，返回false System.out.println(f1.isDirectory()); // 检查f2是否表示一个文件夹，返回true System.out.println(f2.isDirectory()); // 获取文件f1的名称，输出test.txt System.out.println(f1.getName()); // 获取文件f1的长度（字节数） System.out.println(f1.length()); // 获取文件f1最后修改时间 long time = f1.lastModified(); // 格式化最后修改时间并输出 SimpleDateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy/MM/dd HH:mm:ss\u0026#34;); System.out.println(sdf.format(time)); // 获取文件f1的路径（创建时使用的路径），输出相对路径file-io-app\\src\\com\\showguan\\FileDemo\\test.txt System.out.println(f1.getPath()); // 获取文件f1的绝对路径，输出完整的绝对路径 System.out.println(f1.getAbsolutePath()); } 创建文件、目录 import java.io.File; import java.io.IOException; public static void main(String[] args) throws IOException { // 创建File对象，表示新文件test2.txt的路径 File f1 = new File(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\FileDemo\\\\test2.txt\u0026#34;); // 创建新文件test2.txt，如果文件不存在则创建并返回true，否则返回false System.out.println(f1.createNewFile()); // 创建File对象，表示新文件夹aaa的路径 File f2 = new File(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\FileDemo\\\\aaa\u0026#34;); // 创建新文件夹aaa，如果文件夹不存在则创建并返回true，否则返回false System.out.println(f2.mkdir()); // 创建File对象，表示新文件夹路径a\\b\\c File f3 = new File(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\FileDemo\\\\a\\\\b\\\\c\u0026#34;); // 创建新文件夹路径a\\b\\c，如果路径中的文件夹不存在则递归创建，创建成功返回true，否则返回false System.out.println(f3.mkdirs()); // 删除文件test2.txt，删除成功返回true，否则返回false System.out.println(f1.delete()); // 删除文件夹a，由于文件夹非空，因此删除失败返回false File f4 = new File(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\FileDemo\\\\a\u0026#34;); System.out.println(f4.delete()); } public static void main(String[] args) { // 遍历方法，只能遍历一级文件 File f1 = new File(\u0026#34;D:\\\\JAVA\u0026#34;); // 获取D:\\JAVA目录下的所有一级文件名 String[] names = f1.list(); // 遍历打印所有一级文件名 for (String name : names) { System.out.println(name); } // 获取D:\\JAVA目录下的所有一级文件对象 File f2 = new File(\u0026#34;D:\\\\JAVA\u0026#34;); // 获取D:\\JAVA目录下的所有一级文件对象 File[] files = f2.listFiles(); // 遍历打印所有一级文件对象的绝对路径 for (File file : files) { System.out.println(file.getAbsoluteFile()); } // 尝试获取不存在的目录的一级文件对象，返回null File f3 = new File(\u0026#34;D:\\\\JAVA1\u0026#34;); System.out.println(f3.listFiles()); // null // 尝试获取非文件夹的一级文件对象，返回null File f4 = new File(\u0026#34;D:\\\\JAVA\\\\test1\u0026#34;); // 因为f4代表的路径不是文件夹，因此listFiles()返回null File[] files4 = f4.listFiles(); System.out.println(Arrays.toString(files4)); // null } 递归查找 public static void main(String[] args) throws IOException { searchFile(new File(\u0026#34;D:\\\\文档\u0026#34;), \u0026#34;23暑期青训营笔记\u0026#34;); // 调用搜索文件的方法 } /** * 递归搜索指定目录下的文件，并打印找到的文件的绝对路径，并使用系统默认程序打开该文件。 * @param dir 要搜索的目录 * @param fileName 要搜索的文件名 * @throws IOException 如果发生I/O错误 */ public static void searchFile(File dir, String fileName) throws IOException { // 如果目录为空、不存在或者是文件，则直接返回 if(dir==null || !dir.exists() || dir.isFile()){ return ; } // 获取目录下的所有文件和子目录 File[] files = dir.listFiles(); // 如果目录下存在文件 if(files!=null \u0026amp;\u0026amp; files.length\u0026gt;0){ // 遍历目录下的所有文件和子目录 for (File file : files) { // 如果是文件 if(file.isFile()){ // 判断文件名是否包含指定的文件名 if(file.getName().contains(fileName)){ System.out.println(\u0026#34;找到了！\u0026#34; + file.getAbsoluteFile()); // 打印找到的文件的绝对路径 Runtime runtime = Runtime.getRuntime(); runtime.exec(file.getAbsolutePath()); // 使用系统默认程序打开该文件 return; // 找到文件后直接返回 } }else{ // 如果是目录，则递归调用搜索文件的方法 searchFile(file, fileName); } } } } 递归删除 public static void main(String[] args) throws IOException { File file = new File(\u0026#34;D:\\\\JAVA\\\\test1\\\\test\u0026#34;); // 要删除的目录的路径 deleteDir(file); // 调用删除目录的方法 } /** * 递归删除目录及其所有子目录和文件。 * @param dir 要删除的目录 */ public static void deleteDir(File dir){ // 如果目录为空或者不存在，则直接返回 if(dir==null || !dir.exists()){ return ; } // 如果是文件，则直接删除并返回 if(dir.isFile()){ dir.delete(); return; } // 获取目录下的所有文件和子目录 File[] files = dir.listFiles(); // 如果目录为空，则直接返回 if(files==null){ return; } // 遍历目录下的所有文件和子目录 for (File file : files) { if(file.isFile()){ // 如果是文件，则直接删除 file.delete(); } deleteDir(file); // 递归删除子目录 } dir.delete(); // 删除当前目录 } 字符集 UTF-32\n每个字符占4个字节，存储空间太大，没有普及 UTF-8\n是Unicode字符集的一种编码方案，采取可变长编码方案，共分为四个长度区：一个字节，两个字节，三个字节，四个字节 英文字符，数字等只占一个字节（兼容标准ASCII编码），汉字字符占用3个字节。 ASCII字符集：只有英文、数字、符号等，占1个字节 GBK字符集：汉字占2两个字节，英文，数字占1个字节 UTF-8字符集：汉字占3个字节，英文，数字占1个字节 import java.io.UnsupportedEncodingException; import java.util.Arrays; public static void main(String[] args) throws UnsupportedEncodingException { String data = \u0026#34;a啊a\u0026#34;; // 使用默认字符集（通常是UTF-8）将字符串转换为字节数组 byte[] bytes = data.getBytes(); System.out.println(Arrays.toString(bytes)); // 使用指定字符集（例如GBK）将字符串转换为字节数组 byte[] bytes1 = data.getBytes(\u0026#34;GBK\u0026#34;); System.out.println(Arrays.toString(bytes1)); // 将字节数组转换为字符串，使用默认字符集进行解码 String s = new String(bytes); System.out.println(s); // 将字节数组转换为字符串，使用指定字符集进行解码 String s1 = new String(bytes1, \u0026#34;GBK\u0026#34;); System.out.println(s1); } IO流 按流的方向分为\n输入流 输出流 按流中数据的最小单位，分为：\n字节流 适合操作所有类型的文件 比如：音频，视频，图片，文本文件的复制，转移等 字符流 知识和操作纯文本文件 比如：读写txt, java文件等 FileInputStream(文件字节输入流) 作用：以内存为基准，可以把磁盘文件中的数据以字节的形式读入到内存中去 public static void main(String[] args) throws IOException { // 用多态的形式创建文件输入流 InputStream is = new FileInputStream(\u0026#34;D:\\\\JAVA\\\\JavaSeProMax\\\\file-io-app\\\\src\\\\com\\\\showguan\\\\ByteStreamDemo\\\\test.txt\u0026#34;); int b; // 读取文件内容，直到遇到文件末尾(-1) while((b = is.read()) != -1){ System.out.print((char) b); // 将读取到的字节转换为字符并打印到控制台 } is.close(); // 关闭文件输入流 } public static void main(String[] args) throws IOException { InputStream is = new FileInputStream(\u0026#34;D:\\\\JAVA\\\\JavaSeProMax\\\\file-io-app\\\\src\\\\com\\\\showguan\\\\ByteStreamDemo\\\\test.txt\u0026#34;); // 创建文件输入流 byte[] buffer = new byte[3]; // 创建缓冲区 int len1 = is.read(buffer); // 从文件中读取字节到缓冲区中 System.out.println(\u0026#34;当前读取的长度:\u0026#34; + len1); // 打印当前读取的长度 String s = new String(buffer); // 将缓冲区中的字节转换为字符串 System.out.println(s); // 打印字符串 } 文件字节输入流：一次读完全部字节\n方式一：定义一个字节数组与被读取的文件大小一样大，然后使用该字节数组，一次读完文件的全部字节。\n方法二：Java官方为InputStream提供了readAllBytes()方法， 可以直接把文件的全部字节读取到一个字节数组中返回。\nFileOutputStream(文件字节输出流) 作用：以内存为基准，把内存中的数据以字节的形式写出到文件中去 public static void main(String[] args) throws IOException { // 创建文件输出流，指定文件路径，并设置为追加模式（true） FileOutputStream os = new FileOutputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ByteStreamDemo\\\\test2.txt\u0026#34;, true); os.write(97); // 向文件中写入一个字节 os.write(\u0026#39;a\u0026#39;); // 向文件中写入一个字符 byte[] bytes = \u0026#34;今天是20240419\u0026#34;.getBytes(); // 将字符串转换为字节数组 // 向文件中写入字节数组的一部分内容 os.write(bytes, 0, 15); // 从字节数组的索引0开始，写入长度为15的字节数据 os.write(\u0026#34;\\r\\n\u0026#34;.getBytes()); // 向文件中写入换行符 os.close(); // 关闭文件输出流 } 文件复制 public class FileCopyDemo { /** * 程序入口点，复制一个文件的内容到另一个文件。 * @param args 命令行参数 * @throws IOException 如果发生I/O错误 */ public static void main(String[] args) throws IOException { InputStream is = new FileInputStream(\u0026#34;D:\\\\JAVA\\\\JavaSeProMax\\\\file-io-app\\\\src\\\\com\\\\showguan\\\\ByteStreamDemo\\\\test.jpg\u0026#34;); // 创建文件输入流，读取源文件 OutputStream os = new FileOutputStream(\u0026#34;D:\\\\JAVA\\\\test1\\\\img2.jpg\u0026#34;); // 创建文件输出流，写入目标文件 byte[] buffer = new byte[1024]; // 创建缓冲区 int len; // 定义变量用于保存读取的字节数 // 循环读取源文件内容，并写入目标文件 while((len = is.read(buffer)) != -1){ os.write(buffer, 0, len); // 将缓冲区中的字节写入目标文件 } os.close(); // 关闭文件输出流 is.close(); // 关闭文件输入流 System.out.println(\u0026#34;复制完成！\u0026#34;); // 打印复制完成的消息 } } 释放资源的方式 try-catch-finally finally代码区的特点：无论try中的程序是否正常执行了， 还是出现了异常，最后都一定会执行finally区， 除非JVM终止 作用：一般用于在程序执行完成后进行资源的释放操作(专业级做法) public static void main(String[] args) { // 声明输入和输出流对象为null，以确保在try块中可以访问这些对象 InputStream is = null; OutputStream os = null; try{ // 故意产生的异常，用于演示异常捕捉 System.out.println(10/0); // 创建一个FileInputStream来读取文件 is = new FileInputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ResourceDemo\\\\test.txt\u0026#34;); // 创建一个FileOutputStream来写入文件 os = new FileOutputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ResourceDemo\\\\test1.txt\u0026#34;); System.out.println(10/0); // 创建一个字节数组用于暂存从文件读取的数据 byte[] buffer = new byte[1024]; int len; // 循环读取并写入文件，直到文件结束 while((len=is.read(buffer))!=-1){ os.write(buffer, 0, len); } System.out.println(\u0026#34;复制完成！\u0026#34;); }catch (IOException e){ // 捕捉并处理IO异常 e.printStackTrace(); }finally { // 在finally块中释放资源，确保无论是否有异常发生，资源都被释放 try { // 关闭输出流资源 if(os!=null) os.close(); } catch (IOException e) { throw new RuntimeException(e); } try { // 关闭输入流资源 if(is!=null) is.close(); } catch (IOException e) { throw new RuntimeException(e); } } } try-with-resource public static void main(String[] args) { // 使用try-with-resources语法，自动关闭输入流和输出流 try ( InputStream is = new FileInputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ResourceDemo\\\\test.txt\u0026#34;); // 创建文件输入流，读取源文件 OutputStream os = new FileOutputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ResourceDemo\\\\test1.txt\u0026#34;); // 创建文件输出流，写入目标文件 ) { byte[] buffer = new byte[1024]; // 创建缓冲区 int len; // 定义变量用于保存读取的字节数 // 循环读取源文件内容，并写入目标文件 while ((len = is.read(buffer)) != -1) { os.write(buffer, 0, len); // 将缓冲区中的字节写入目标文件 } System.out.println(\u0026#34;复制完成！\u0026#34;); // 打印复制完成的消息 } catch (Exception e) { // 捕获可能发生的异常 e.printStackTrace(); // 打印异常信息 } } 注意：()里面只能放置资源对象，资源都会实现AutoCloseable接口\n资源用完之后，会自动调用close方法。\nIO字符流 FileReader public static void main(String[] args) throws FileNotFoundException { // 使用try-with-resources语法，自动关闭字符流 try ( Reader fr = new FileReader(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ResourceDemo\\\\test.txt\u0026#34;); // 创建字符输入流，读取文件 ) { // int c; // while((c=fr.read())!=-1){ // System.out.println((char) c); // } char[] buffer = new char[3]; // 创建缓冲区 int len; // 定义变量用于保存读取的字符数 // 循环读取文件内容，并打印到控制台 while((len=fr.read(buffer))!=-1){ System.out.print(new String(buffer, 0, len)); // 将缓冲区中的字符转换为字符串并打印 } } catch (Exception e) { // 捕获可能发生的异常 e.printStackTrace(); // 打印异常信息 } } FileWriter public static void main(String[] args) { // 使用try-with-resources语法，自动关闭字符流 try ( FileWriter fw = new FileWriter(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\CharStreamDemo\\\\test.txt\u0026#34;, true); // 创建字符输出流，写入文件 ){ fw.write(\u0026#34;\\r\\n\u0026#34;); // 向文件中写入换行符 fw.write(\u0026#39;a\u0026#39;); // 向文件中写入字符 fw.write(\u0026#34;\\r\\n\u0026#34;); // 向文件中写入换行符 fw.write(98); // 向文件中写入字符对应的ASCII码 fw.write(\u0026#39;英\u0026#39;); // 向文件中写入字符 fw.write(\u0026#34;\\r\\n\u0026#34;); // 向文件中写入换行符 fw.write(\u0026#34;\\r\\n\u0026#34;); // 向文件中写入换行符 fw.write(\u0026#34;我是的话\u0026#34;); // 向文件中写入字符串 fw.write(\u0026#34;\\r\\n\u0026#34;); // 向文件中写入换行符 fw.write(\u0026#34;fw.write\u0026#34;); // 向文件中写入字符串 char[] buffer = {\u0026#39;黑\u0026#39;, \u0026#39;马\u0026#39;, \u0026#39;a\u0026#39;}; // 创建字符数组 fw.write(buffer); // 向文件中写入字符数组的内容 fw.write(buffer, 0, 2); // 向文件中写入字符数组的一部分内容 } catch (Exception e) { // 捕获可能发生的异常 e.printStackTrace(); // 打印异常信息 } } flush() public static void main(String[] args) throws IOException { Writer fw = new FileWriter(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\CharStreamDemo\\\\test1.txt\u0026#34;); // 创建字符输出流，写入文件 fw.write(\u0026#39;a\u0026#39;); // 向文件中写入字符 \u0026#39;a\u0026#39; fw.write(\u0026#39;b\u0026#39;); // 向文件中写入字符 \u0026#39;b\u0026#39; fw.write(\u0026#39;c\u0026#39;); // 向文件中写入字符 \u0026#39;c\u0026#39; fw.flush(); // 手动刷新缓冲区，将缓冲区中的数据写入文件 fw.write(\u0026#39;a\u0026#39;); // 向文件中写入字符 \u0026#39;a\u0026#39; fw.close(); // 关闭字符输出流，会自动刷新 } ","permalink":"https://showguan.github.io/en/posts/tech/java20%E5%A4%A9%E9%80%9F%E6%88%90%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B3/","summary":"Java20天速成——进阶课程(3) 文件操作 File对象 常用方法 public static void main(String[] args) { // 创建File对象，表示文件test.txt的绝对路径 File f1 = new File(\u0026#34;D:/JAVA/JavaSeProMax/file-io-app/src/com/showguan/FileDemo/test.txt\u0026#34;);","title":"Java20天速成——进阶课程(3)"},{"content":"LeetCode笔记 目标：2500分\n剑指Offer + 数据流中的中位数 用两个堆模拟， 左边大顶堆，右边小顶堆，则两个堆顶是最中间的数字。\n添加数字时：\n如果输入的是第奇数个（比如第一个，则N初始化为0，插入后N为1，代表一共有一个数字），则先插入大顶堆，然后把堆顶插入小顶堆。保证小顶堆的任意一个值都比大顶堆大。 同样，如果输入的是第偶数个（第二个），则先插入小顶堆，然后将小顶堆最小值插入大顶堆。同样是保证小顶堆的任意一个值都比大顶堆大。 至于先插入哪一个堆是没有关系的，只要保证交替插入不同的堆即可，并且要确保边界问题（比如在奇数个元素的的中位数， 只有一个数据时应返回先插入的堆顶值， 否则堆为空会报错）。\nimport heapq as hp class Solution: heapl = [] # 大根堆 heapr = [] # 小根堆 N = 0 def insert(self, num): \u0026#34;\u0026#34;\u0026#34; :type num: int :rtype: void \u0026#34;\u0026#34;\u0026#34; if self.N % 2 ==0: hp.heappush(self.heapl, -num) hp.heappush(self.heapr, -hp.heappop(self.heapl)) else: hp.heappush(self.heapr, num) hp.heappush(self.heapl, -hp.heappop(self.heapr)) self.N += 1 def getMedian(self): \u0026#34;\u0026#34;\u0026#34; :rtype: float \u0026#34;\u0026#34;\u0026#34; if self.N %2==0: return (-self.heapl[0]+self.heapr[0])/2.0 else: return self.heapr[0]*1.0 字符流中第一个只出现一次的字符 import collections class Solution: d = collections.defaultdict(int) q = collections.deque() def firstAppearingOnce(self): \u0026#34;\u0026#34;\u0026#34; :rtype: str \u0026#34;\u0026#34;\u0026#34; return \u0026#39;#\u0026#39; if not self.q else self.q[0] def insert(self, char): \u0026#34;\u0026#34;\u0026#34; :type char: str :rtype: void \u0026#34;\u0026#34;\u0026#34; self.d[char]+=1 self.q.append(char) while self.q and self.d[self.q[0]]\u0026gt;1: self.q.popleft() 最长不含重复字符的子字符串 class Solution: def longestSubstringWithoutDuplication(self, s): \u0026#34;\u0026#34;\u0026#34; :type s: str :rtype: int \u0026#34;\u0026#34;\u0026#34; char_index = {} # 存储字符的最近出现位置 ans = 0 start = 0 for i, char in enumerate(s): if char in char_index and char_index[char] \u0026gt;= start: start = char_index[char] + 1 char_index[char] = i ans = max(ans, i - start + 1) return ans 骰子的点数 线性DP ：\n注意点： 算法先从最简单的方法想起，DP先用二维想，实现完之后再优化。\n因为每次计算状态时会修改$ j-1, j-2, j-3, j-4, j-5, j-6$, 而$j+1$会计算 $j+1-1=j, j+1-2=j-1, \u0026hellip;$ j-1会计算$j-1-1=j-2,j-1-2=j-3,\u0026hellip;$没有单调性，所以不能优化第一维空间\nclass Solution(object): def numberOfDice(self, n): \u0026#34;\u0026#34;\u0026#34; :type n: int :rtype: List[int] \u0026#34;\u0026#34;\u0026#34; N = 6*n+10 f = [[0]*N for _ in range(N)] f[0][0]=1 for i in range(1,n+1): for j in range(1,n*6+1): for k in range(1,min(j, 6)+1): f[i][j] += f[i-1][j-k] return f[n][1*n:6*n+1] 数组中数值和下标相等的元素 class Solution(object): def getNumberSameAsIndex(self, nums): \u0026#34;\u0026#34;\u0026#34; :type nums: List[int] :rtype: int \u0026#34;\u0026#34;\u0026#34; l, r = 0, len(nums)-1 while l\u0026lt;r: mid = l+r+1\u0026gt;\u0026gt;1 if nums[mid]\u0026gt;mid: r=mid-1 elif nums[mid]\u0026lt;mid: l=mid else: return mid break return l if nums[l]==l else -1 复杂链表的复刻 class Solution(object): def copyRandomList(self, head): hash = {} hash[None] = None cloneHead = ListNode(-1) cur = cloneHead while head: if head not in hash: hash[head] = ListNode(head.val) if head.random not in hash: hash[head.random] = ListNode(head.random.val) cur.next = hash[head] cur = cur.next cur.random = hash[head.random] head = head.next return cloneHead.next 矩阵中的路径 class Solution(object): def hasPath(self, matrix, string): if not matrix or not(matrix[0]): return False dx = [1, 0, -1, 0] dy = [0, 1, 0, -1] def dfs(x, y, idx): if matrix[x][y]!=string[idx]: return False if idx==len(string)-1: return True for h,v in zip(dx, dy): xx, yy = x+h, y+v if xx\u0026lt;0 or xx\u0026gt;=len(matrix) or yy\u0026lt;0 or yy\u0026gt;=len(matrix[0]): continue memo = matrix[x][y] matrix[x][y] = \u0026#39;#\u0026#39; if dfs(xx,yy,idx+1): return True matrix[x][y] = memo return False for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j]==string[0]: if dfs(i,j,0): return True return False 正则表达式匹配 DP:\nclass Solution(object): def isMatch(self, s, p): \u0026#34;\u0026#34;\u0026#34; :type s: str :type p: str :rtype: bool \u0026#34;\u0026#34;\u0026#34; n, m = len(s), len(p) s, p = \u0026#39; \u0026#39;+s, \u0026#39; \u0026#39;+p f = [[False]*(m+1) for _ in range(n+1)] f[0][0] = True for i in range(2,m+1): if p[i]==\u0026#39;*\u0026#39;: f[0][i] = f[0][i-2] for i in range(1,n+1): for j in range(1,m+1): if s[i]==p[j] or p[j]==\u0026#39;.\u0026#39;: f[i][j] = f[i-1][j-1] elif p[j]==\u0026#39;*\u0026#39;: if s[i]==p[j-1] or p[j-1]==\u0026#39;.\u0026#39;: f[i][j] = f[i-1][j] f[i][j] |= f[i][j-2] return f[n][m] HOT100 301. 删除无效的括号 给你一个由若干括号和字母组成的字符串 s ，删除最小数量的无效括号，使得输入的字符串有效。\n返回所有可能的结果。答案可以按 任意顺序 返回。\n回溯 class Solution: def removeInvalidParentheses(self, s: str) -\u0026gt; List[str]: l, r = 0, 0 ret = [] n = len(s) for c in s: if c==\u0026#39;(\u0026#39;: l+=1 elif c==\u0026#39;)\u0026#39;: if l==0: r+=1 else: l-=1 def check(st): cnt=0 for c in st: if c==\u0026#39;(\u0026#39;: cnt+=1 elif c==\u0026#39;)\u0026#39;: cnt-=1 if cnt\u0026lt;0: return False return (cnt==0) def backtrace(st, start, ln, rn): print(st, ln, rn) if ln==0 and rn==0 and check(st): ret.append(st[:]) return for i in range(start, len(st)): if i\u0026gt;start and st[i]==st[i-1]: continue if ln+rn\u0026gt;n-1-i+1: break if ln and st[i]==\u0026#39;(\u0026#39;: backtrace(st[:i]+st[i+1:], i, ln-1, rn) elif rn and st[i]==\u0026#39;)\u0026#39;: backtrace(st[:i]+st[i+1:], i, ln, rn-1) backtrace(s, 0, l, r) return ret 广搜 class Solution: def removeInvalidParentheses(self, s: str) -\u0026gt; List[str]: ret = [] def check(st): cnt=0 for c in st: if c==\u0026#39;(\u0026#39;: cnt+=1 elif c==\u0026#39;)\u0026#39;: if cnt==0: return False cnt-=1 return cnt==0 cur = set([s]) while True: for st in cur: if check(st): ret.append(st) if len(ret): break nxt = set() for st in cur: for i in range(len(st)): if i\u0026gt;0 and st[i]==st[i-1]: continue if st[i]==\u0026#39;(\u0026#39; or st[i]==\u0026#39;)\u0026#39;: nxt.add(st[:i]+st[i+1:]) cur = nxt return ret 297. 二叉树的序列化与反序列化 不止第一次遇到了。\n# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Codec: def serialize(self, root): \u0026#34;\u0026#34;\u0026#34;Encodes a tree to a single string. :type root: TreeNode :rtype: str \u0026#34;\u0026#34;\u0026#34; if not root: return \u0026#39;#\u0026#39; return str(root.val)+\u0026#39; \u0026#39;+self.serialize(root.left)+\u0026#39; \u0026#39;+self.serialize(root.right) def deserialize(self, data): \u0026#34;\u0026#34;\u0026#34;Decodes your encoded data to tree. :type data: str :rtype: TreeNode \u0026#34;\u0026#34;\u0026#34; self.s = data return self.DerWork() def DerWork(self): if len(self.s)==0: return None try: idx = self.s.index(\u0026#39; \u0026#39;) except: idx = -1 node = self.s if idx==-1 else self.s[:idx] self.s = \u0026#39;\u0026#39; if idx==-1 else self.s[idx+1:] if node==\u0026#39;#\u0026#39;: return None t = TreeNode(int(node)) t.left = self.DerWork() t.right = self.DerWork() return t # Your Codec object will be instantiated and called as such: # ser = Codec() # deser = Codec() # ans = deser.deserialize(ser.serialize(root)) 84. 柱状图中最大的矩形 class Solution: def largestRectangleArea(self, heights: List[int]) -\u0026gt; int: n=len(heights) l, r = [-1]*(n+5), [n]*(n+5) stk = list() for i in range(n): while stk and heights[stk[-1]]\u0026gt;=heights[i]: r[stk[-1]]=i stk.pop() if stk: l[i]=stk[-1] stk.append(i) return max( (r[i]-l[i]-1)*heights[i] for i in range(n) ) if n\u0026gt;0 else 0 85. 最大矩形 class Solution: def maximalRectangle(self, matrix: List[List[str]]) -\u0026gt; int: # 转化为矩形最大面积问题 n, m = len(matrix), len(matrix[0]) area = 0 left = [[0]*m for _ in range(n)] for i in range(n): for j in range(m): if matrix[i][j]==\u0026#39;1\u0026#39;: left[i][j] += left[i][j-1]+1 if j else 1 for j in range(m): stk = [] up, down = [-1]*n, [n]*n for i in range(n): #行 while stk and left[ stk[-1] ][j]\u0026gt;=left[i][j]: down[stk[-1]] = i stk.pop() up[i] = stk[-1] if stk else -1 stk.append(i) for i in range(n): height = down[i]-up[i]-1 area = max(area, height*left[i][j]) return area 76. 最小覆盖子串 class Solution: def minWindow(self, s: str, t: str) -\u0026gt; str: n, m = len(s), len(t) need = defaultdict(int) needCnt = m left = 0 res = (0, n) for ch in t: need[ch]+=1 for right, ch in enumerate(s): if need[ch]\u0026gt;0: needCnt-=1 need[ch]-=1 if needCnt==0: while need[s[left]]!=0: need[s[left]]+=1 left+=1 if right-left \u0026lt; res[1]-res[0]: res = (left, right) need[s[left]]+=1 needCnt+=1 left+=1 return \u0026#39;\u0026#39; if res[1]\u0026gt;n-1 else s[res[0]:res[1]+1] 312. 戳气球 **题意：**给定n个数字num[0~n-1],每次戳破一个气球可以获得nums[i-1]*nums[i]*nums[i+1]个硬币，最两旁默认为1，问最终获得的最大硬币数量。 思路：区间DP，逆向思维, 思考如何放气球能使硬币最大，f[i][j]代表开区间i~j可以获得的最大硬币， 先枚举小区间，再枚举大区间，枚举区间内每个数字，状态转移有：f[i][j] = max(f[i][j], f[i][k]+f[k][j]+nums[i]*nums[k]*nums[j])。最终输出f[0][n+1] class Solution: def maxCoins(self, nums: List[int]) -\u0026gt; int: n = len(nums) nums = [1]+nums+[1] f = [[0]*(n+5) for _ in range(n+5)] # 开区间 (left, right) 区间内能获得的最大硬币 for l in range(2,n+2): # len:2~n+1 for i in range(n+1-l+1): # left:0~n+1-len j=i+l # right = left + len for k in range(i+1, j): # 开区间(i,j) 即[i+1, j-1] f[i][j] = max(f[i][j], f[i][k]+f[k][j]+nums[i]*nums[k]*nums[j]) return f[0][n+1] 301. 删除无效的括号 题目大意：给定一个由字母和括号组成的字符串s，要求删除最小数量的括号，使得字符串成为有效的括号组合，并返回所有可能的结果。\n实现思路：\n首先定义一个辅助函数check(st)，用于检查字符串st是否为有效的括号组合。遍历字符串中的每个字符，维护一个计数器cnt，遇到左括号增加计数，遇到右括号减少计数，若出现cnt为负数，或者遍历结束后cnt不为0，则说明括号不匹配，返回False，否则返回True。\n初始化一个空列表ret，用于存储结果。\n初始化一个集合cur，初始时将输入字符串s作为唯一元素加入其中。\n使用while循环，直到找到符合条件的结果为止：\n遍历集合cur中的每个字符串，检查其是否为有效括号组合，若是则将其加入结果列表ret。\n若结果列表ret不为空，则说明已找到符合条件的结果，结束循环。\n否则，初始化一个空集合nxt，用于存储下一轮迭代的候选字符串集合。\n遍历集合cur中的每个字符串，对于每个字符串，尝试删除一个字符（括号），生成新的字符串，并将其加入nxt中。\n更新cur为nxt，继续下一轮迭代。\n返回结果列表ret。\nclass Solution: def removeInvalidParentheses(self, s: str) -\u0026gt; List[str]: ret = [] def check(st): cnt=0 for c in st: if c==\u0026#39;(\u0026#39;: cnt+=1 elif c==\u0026#39;)\u0026#39;: if cnt==0: return False cnt-=1 return cnt==0 cur = set([s]) while True: for st in cur: if check(st): ret.append(st) if len(ret): break nxt = set() for st in cur: for i in range(len(st)): if i\u0026gt;0 and st[i]==st[i-1]: continue if st[i]==\u0026#39;(\u0026#39; or st[i]==\u0026#39;)\u0026#39;: nxt.add(st[:i]+st[i+1:]) cur = nxt return ret 线段树 729. 我的日程安排表 I\nclass MyCalendar: def __init__(self): self.tree = set() self.lazy = set() def query(self, start: int, end: int, l: int, r: int, idx: int) -\u0026gt; bool: if r \u0026lt; start or end \u0026lt; l: return False if idx in self.lazy: # 如果该区间已被预订，则直接返回 return True if start \u0026lt;= l and r \u0026lt;= end: return idx in self.tree mid = (l + r) // 2 return self.query(start, end, l, mid, 2 * idx) or \\ self.query(start, end, mid + 1, r, 2 * idx + 1) def update(self, start, end, l, r, idx): if start\u0026gt;r or end\u0026lt;l: return False if start\u0026lt;=l and r\u0026lt;=end: self.tree.add(idx) self.lazy.add(idx) else: mid = (l+r)\u0026gt;\u0026gt;1 self.update(start, end, l, mid, idx*2) self.update(start, end, mid+1, r, idx*2+1) self.tree.add(idx) if 2*idx in self.lazy and 2*idx+1 in self.lazy: self.lazy.add(idx) def book(self, start: int, end: int) -\u0026gt; bool: if self.query(start, end-1, 0, 10**9, 1): return False self.update(start, end-1, 0, 10**9, 1) return True 每日一题 2009. 使数组连续的最少操作数 **题意：**给定一个可能有重复元素的数组，可以修改数组中值为任意其他值，问使数组连续的最小操作数。\n**思路：**由于只能改动元素，所以最后的元素个数不变，去重后，枚举每个值作为左端点，则右端点为nums[i]+n-1, 用双指针计算在区间内的元素个数即为可以保留的数字，其他数字修改元素值填满空隙即可。\nclass Solution: def minOperations(self, nums: List[int]) -\u0026gt; int: n = len(nums) nums = sorted(set(nums)) j, ans = 0, 0 for i in range(len(nums)): right = nums[i]+ n-1 if len(nums)-1 - i + 1 \u0026lt;= ans: break while j\u0026lt;len(nums) and nums[j]\u0026lt;=right: j+=1 ans = max(ans, j-i) return n-ans 1600. 王位继承顺序 **题意：**国王继承次序按嫡长子次序，实现ThroneInheritance(string kingName)初始化,void birth(string parentName, string childName) 出生，void death(string name)人死亡，string[] getInheritanceOrder() 返回 除去 死亡人员的当前继承顺序列表。\n**思路：**类似树形结构，国王先继承，之后是国王的长子，之后是长子的长子， 如果不存在则为国王的次子以此类推， 所以可以用defaultdict()存储每个的儿子情况，然后查询时，先将自己入结果列表，然后是第一个儿子\u0026hellip;；并记录每个人的存活情况，排除掉已经死掉的人。\nclass ThroneInheritance: def __init__(self, kingName: str): self.son = defaultdict(list) self.die = set() self.king = kingName def birth(self, parentName: str, childName: str) -\u0026gt; None: self.son[parentName].append(childName) def death(self, name: str) -\u0026gt; None: self.die.add(name) def getInheritanceOrder(self) -\u0026gt; List[str]: ret = [] def dfs(root): if root not in self.die: ret.append(root) for child in self.son[root]: dfs(child) dfs(self.king) return ret 1483. 树节点的第 K 个祖先 **题意：**给定n个点(0~n-1)每个点的父亲节点，快速查询每个节点的第k个祖宗节点。\n**思路：**LCA倍增原理，$ancestor[j][i] = ancestor[ ancestor[j][i-1] ][i-1]$ 节点j的第$2^i$个祖宗节点为节点第$2^{i-1}$个祖宗的第$2^{i-1}$个祖宗，即$2^{i-1}*2$个祖宗节点， 所以先预处理好每个节点的各个二进制位上的祖宗节点是谁，之后分解二进制位据可以得知任意第k个祖宗节点是谁。\nclass TreeAncestor: def __init__(self, n: int, parent: List[int]): self.level = 16 self.ancestor = [[-1]*self.level for _ in range(n)] for i in range(1, n): self.ancestor[i][0] = parent[i] for i in range(1, self.level): for j in range(1, n): if self.ancestor[j][i-1]!=-1: self.ancestor[j][i] = self.ancestor[ self.ancestor[j][i-1] ][i-1] def getKthAncestor(self, node: int, k: int) -\u0026gt; int: while k: t = k\u0026amp;-k k -= t t = t.bit_length()-1 node = self.ancestor[node][t] if node==-1: return -1 return node 面试题 08.12. 八皇后 class Solution: def solveNQueens(self, n: int) -\u0026gt; List[List[str]]: def generate(): board = [] for r in range(n): c = pos[r] row[c] = \u0026#39;Q\u0026#39; board.append(\u0026#34;\u0026#34;.join(row)) row[c] = \u0026#39;.\u0026#39; ret.append(board) def solve(row, column, diag1, diag2): if row==n: generate() else: avail = ( (1\u0026lt;\u0026lt;n)-1) \u0026amp; ( ~(column|diag1|diag2) ) while avail: colPos = avail\u0026amp;(-avail) avail -= colPos colNum = bin(colPos-1).count(\u0026#34;1\u0026#34;) pos[row]=colNum solve(row+1, column|colPos, (diag1|colPos)\u0026lt;\u0026lt;1, (diag2|colPos)\u0026gt;\u0026gt;1) pos = [0]*n ret = [] row = [\u0026#39;.\u0026#39;]*n solve(0, 0, 0, 0) return ret 1702. 修改后的最大二进制字符串 **题意：**给定一个二进制字符串00-\u0026gt;10, 10-\u0026gt;01问任意次操作后能达到的最大二进制字符串。\n思路：构造，根据条件推过程，10-\u0026gt;01可以看作后面的0浮到前面，所有的0聚到一起可以变成10串，所以最后至多只有一个0。根据构造来做，统计第一个0的位置和0的个数，最后构造出最后的0的位置；双指针来做：遇到0时找到后面第一个0的位置，将其浮到旁边，并换成10。\n构造：\nclass Solution: def maximumBinaryString(self, binary: str) -\u0026gt; str: cnt = binary.count(\u0026#39;0\u0026#39;) if cnt\u0026lt;=1: return binary n = len(binary) ans = [\u0026#39;1\u0026#39;]*n index = binary.index(\u0026#39;0\u0026#39;) ans[index+cnt-1]=\u0026#39;0\u0026#39; return \u0026#39;\u0026#39;.join(ans) 双指针：\nclass Solution: def maximumBinaryString(self, binary: str) -\u0026gt; str: n = len(binary) s = list(binary) j = 0 for i in range(n): if s[i]==\u0026#39;0\u0026#39;: while j\u0026lt;=i or (j\u0026lt;n and s[j]==\u0026#39;1\u0026#39;): j+=1 if j\u0026lt;n: s[i], s[j], s[i+1] = \u0026#39;1\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;0\u0026#39; return \u0026#39;\u0026#39;.join(s) 24. 两两交换链表中的节点 **题意：**给定一个链表，分别两个一组交换相对位置。\n**思路：**链表交换next指针操作，prev-\u0026gt;A-\u0026gt;B-\u0026gt;C变成prev-\u0026gt;B-\u0026gt;A-\u0026gt;C，一共要变三条边。需要记录前面的点，后面的点。\nclass Solution: def swapPairs(self, head: Optional[ListNode]) -\u0026gt; Optional[ListNode]: dummy = head prev = None while head and head.next: tmp = head.next.next #A-\u0026gt;B 变成 B-\u0026gt;A nxt = head.next #nxt是B, head是A nxt.next = head head.next = tmp if prev: prev.next = nxt prev = nxt.next #是头节点(即没有前面的点)的时候不需要这一步 if dummy==head: dummy = nxt prev = nxt.next head = tmp return dummy 25. K 个一组翻转链表 **题意：**每隔k个数字翻转链表。\n**思路：**链表交换指针操作。\n# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def reverseKGroup(self, head: Optional[ListNode], k: int) -\u0026gt; Optional[ListNode]: def reverse(head, tail): # A-\u0026gt;B-\u0026gt;C 变成 C-\u0026gt;B-\u0026gt;A cur = tail.next dummy = head while cur != tail: nxt = dummy.next dummy.next = cur cur = dummy dummy = nxt return tail, head # 原来的tail和head位置没变，但中间点的指向关系变了 hair = ListNode(-1) # 伪头节点 hair.next = head pre = hair while head: tail = pre for i in range(k): # 走过k个点 tail = tail.next if not tail: return hair.next head, tail = reverse(head, tail) pre.next = head # pre-\u0026gt;C pre = tail # pre变成尾节点 head = tail.next # 头节点变成当前尾节点的下个一个节点 return hair.next 1766. 互质树 题意：给定一棵树0~n-1共n个节点， 每个节点有一个值，返回每个节点的 最近的 与自己互质的(gcd(a,b)=1) 祖宗节点的编号。值的范围为[1,50] 思路：DFS， 遍历一遍树，维护一个祖宗节点的列表，判断当前节点与祖宗节点的互质关系。但朴素的将所有的祖宗节点都加入列表中，到深层的子节点时会遍历整个列表，会超时。由于值的范围最大为50，所以可以先预处理50范围以内的互质关系，对于每个节点，只需要判断祖宗节点里面有没有这些互质的数即可，但是需要的是最近的祖宗节点，所以还要添加一个深度信息，这样才能保证在相同值的祖宗节点中选择离自己最近的祖宗节点。 class Solution: def getCoprimes(self, nums: List[int], edges: List[List[int]]) -\u0026gt; List[int]: n = len(nums) g = [[]*n for _ in range(n)] ret = [-1]*n store = [[] for _ in range(51)] mem = [(-1, -1)]*(51) for i in range(1, 51): for j in range(1, 51): if gcd(i, j)==1: store[i].append(j) for u, v in edges: g[u].append(v) g[v].append(u) def dfs(u, last, level): ret[u] = max(mem[i] for i in store[nums[u]])[1] tmp = mem[nums[u]] mem[nums[u]] = (level, u) for son in g[u]: if son==last: continue dfs(son, u, level+1) mem[nums[u]] = tmp dfs(0, -1, 0) return ret 924. 尽量减少恶意软件的传播 题目大意：给定一个由n个节点组成的网络，用n x n个邻接矩阵图graph表示。节点之间存在直接连接当且仅当graph[i][j] = 1。一些节点initial最初被恶意软件感染，如果两个节点直接连接且至少一个节点被感染，则两个节点都将被感染。移除一个节点后，返回使得整个网络中感染恶意软件的最终节点数最小的节点，若有多个节点满足条件，则返回索引最小的节点。\n实现思路：首先使用并查集将节点分组，然后计算每个分组的大小和其中感染节点的数量。遍历initial列表，找到使得其所在分组中只有一个感染节点且分组大小最大的节点，返回其索引。\nclass Solution: def minMalwareSpread(self, g: List[List[int]], initial: List[int]) -\u0026gt; int: n, m = len(g), len(initial) f = [i for i in range(n)] size = [1 for _ in range(n)] # 连通块内的点数 num = [0 for _ in range(n)] # 连通块内的感染点数 for x in initial: num[x]=1 def find(x): if f[x] != x: f[x] = find(f[x]) return f[x] for i in range(n): for j in range(i+1, n): if g[i][j]: fi, fj = find(i), find(j) if fi!=fj: f[fi] = fj num[fj] += num[fi] size[fj] += size[fi] ma = -1 initial.sort() idx = initial[0] for x in initial: if num[find(x)]==1 and size[find(x)]\u0026gt;ma: ma = size[find(x)] idx = x return idx 928. 尽量减少恶意软件的传播 II 题目大意：给定一个由n个节点组成的网络，用n x n个邻接矩阵graph表示。节点之间存在直接连接当且仅当graph[i][j] = 1。一些节点initial最初被恶意软件感染，如果两个节点直接连接且至少一个节点被感染，则两个节点都将被感染。移除一个节点及其连接后，返回移除后能使整个网络中感染恶意软件的最终节点数最小的节点，若有多个节点满足条件，则返回索引最小的节点。\n实现思路：首先通过并查集将不在initial中的节点进行合并，然后计算每个initial节点的直接感染节点数。最后选择使得感染节点数最小且索引最小的initial节点返回。\nclass Solution: def minMalwareSpread(self, g: List[List[int]], initial: List[int]) -\u0026gt; int: n = len(g) def find(x): if f[x] != x: f[x] = find(f[x]) return f[x] f = [i for i in range(n)] source = [[] for _ in range(n)] cnt = [0]*n init = [0]*n for i in initial: init[i] = 1 for i in range(n): if init[i]: continue for j in range(n): if init[j] or not g[i][j]: continue fi, fj = find(i), find(j) if fi!=fj: f[fi] = fj for x in initial: infected = [0]*n for j in range(n): if not g[x][j] or init[j] or infected[find(j)]: continue infected[find(j)] = 1 for j in range(n): if infected[j]: source[j].append(x) for i in range(n): if len(source[i])==1: root = source[i][0] for j in range(n): if find(i)==find(j): # 是一个连通块 cnt[root]+=1 idx = initial[0] for x in initial: if cnt[x]\u0026gt;cnt[idx] or (cnt[x]==cnt[idx] and x\u0026lt;idx): idx = x return idx 其他题目 3031. 将单词恢复初始状态所需的最短时间 II Z函数 题目大意： 给定一个字符串 word 和一个整数 k，每秒需要执行两种操作：移除字符串 word 的前 k 个字符，并在字符串末尾添加 k 个任意字符。要求返回将 word 恢复到初始状态所需的最短时间。\n实现思路： 首先，我们可以利用 Z 函数（Z algorithm）来找到字符串的最长前缀后缀匹配长度。然后，我们可以利用 Z 函数的性质，将字符串分割成不同的前缀子串，找到满足条件的最小时间。\n具体步骤如下：\n初始化一个数组 z，用于存储字符串 s 的 Z 函数值。 使用双指针 l 和 r 来维护当前匹配的子串。 遍历字符串 s，计算 z[i] 的值，即以第 i 个字符为起始的最长前缀后缀匹配长度。 在每次遍历中，更新 l 和 r 的值，保持当前匹配的子串范围。 如果当前位置 i 能够满足条件：即 i 是 k 的倍数且 z[i] 等于剩余字符串的长度（n - i），则返回 i 除以 k。 若遍历完字符串后仍未找到满足条件的位置，则返回 (n - 1) 除以 k 再加 1，表示需要把剩余的字符串都移除并添加到末尾。 class Solution: def minimumTimeToInitialState(self, s: str, k: int) -\u0026gt; int: n = len(s) z = [0] * n l, r = 0, 0 for i in range(1, n): if i \u0026lt;= r and z[i - l] \u0026lt; r - i + 1: z[i] = z[i - l] else: z[i] = max(0, r - i + 1) while i + z[i] \u0026lt; n and s[z[i]] == s[i + z[i]]: z[i] += 1 if i + z[i] - 1 \u0026gt; r: l = i r = i + z[i] - 1 if i%k==0 and z[i] == n-i: return i//k return (n-1)//k+1 5. 最长回文子串马拉车算法 题意：求字符串内的最大回文串长度 思路：马拉车算法，由当前已知的最大回文串长度，我们可以由已知的回文串长度，推出其覆盖的点的最大回文串长度。如下图，p[i]位置的回文串长度可以由最长的回文串(以a为中心)得出，因为回文串两边是对称的，所以p[i] = p[c + c-i], 但是对于覆盖不到的部分，需要取下限r-i。 class Solution: # 推荐教学视频 ：https://www.bilibili.com/video/BV1Sx4y1k7jG/?spm_id_from=333.337.search-card.all.click\u0026amp;vd_source=a4a2b56f746715b34521bfb853094cf4 def longestPalindrome(self, s: str) -\u0026gt; str: s = \u0026#39;#\u0026#39; + \u0026#39;#\u0026#39;.join(list(s)) + \u0026#39;#\u0026#39; n = len(s) p = [0]*n #每个点的 最长回文字串 能到的 右侧位置 c, r = 0, 0 # 右边能到达最远的蘑菇的位置 和 其最右边能达到的位置 for i in range(n): if i\u0026lt;=r: p[i] = min(r-i, p[c + c-i]) # 由已知条件得到当前位置能达到的最大右侧距离( 需要取min(镜像位置的值, 当前最大蘑菇能覆盖到的最大值) ) while i+p[i]+1 \u0026lt; n and s[i-p[i]-1] == s[i+p[i]+1]: p[i]+=1 if p[i]+i \u0026gt; r: r = p[i] + i c = i ma = max(p) idx = p.index(ma) return s[idx-ma+1:idx+ma+1:2] Prompt 下面我给出一个题目，代码实现，和对题目的总结和实现思路， 你需要的是学习我是如何总结的，如果你看懂了则回复我你懂了\r\u0026#34;\u0026#34;\u0026#34;\r给你一个 n 个节点的树（也就是一个无环连通无向图），节点编号从 0 到 n - 1 ，且恰好有 n - 1 条边，每个节点有一个值。树的 根节点 为 0 号点。\r给你一个整数数组 nums 和一个二维数组 edges 来表示这棵树。nums[i] 表示第 i 个点的值，edges[j] = [uj, vj] 表示节点 uj 和节点 vj 在树中有一条边。\r当 gcd(x, y) == 1 ，我们称两个数 x 和 y 是 互质的 ，其中 gcd(x, y) 是 x 和 y 的 最大公约数 。\r从节点 i 到 根 最短路径上的点都是节点 i 的祖先节点。一个节点 不是 它自己的祖先节点。\r请你返回一个大小为 n 的数组 ans ，其中 ans[i]是离节点 i 最近的祖先节点且满足 nums[i] 和 nums[ans[i]] 是 互质的 ，如果不存在这样的祖先节点，ans[i] 为 -1 。\r示例 1：\r输入：nums = [2,3,3,2], edges = [[0,1],[1,2],[1,3]]\r输出：[-1,0,0,1]\r解释：上图中，每个节点的值在括号中表示。\r- 节点 0 没有互质祖先。\r- 节点 1 只有一个祖先节点 0 。它们的值是互质的（gcd(2,3) == 1）。\r- 节点 2 有两个祖先节点，分别是节点 1 和节点 0 。节点 1 的值与它的值不是互质的（gcd(3,3) == 3）但节点 0 的值是互质的(gcd(2,3) == 1)，所以节点 0 是最近的符合要求的祖先节点。\r- 节点 3 有两个祖先节点，分别是节点 1 和节点 0 。它与节点 1 互质（gcd(3,2) == 1），所以节点 1 是离它最近的符合要求的祖先节点。\r示例 2：\r输入：nums = [5,6,10,2,3,6,15], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]]\r输出：[-1,0,-1,0,0,0,-1]\r提示：\rnums.length == n\r1 \u0026lt;= nums[i] \u0026lt;= 50\r1 \u0026lt;= n \u0026lt;= 105\redges.length == n - 1\redges[j].length == 2\r0 \u0026lt;= uj, vj \u0026lt; n\ruj != vj\r代码实现：\rclass Solution:\rdef getCoprimes(self, nums: List[int], edges: List[List[int]]) -\u0026gt; List[int]:\rn = len(nums)\rg = [[]*n for _ in range(n)]\rret = [-1]*n\rstore = [[] for _ in range(51)]\rmem = [(-1, -1)]*(51) for i in range(1, 51):\rfor j in range(1, 51):\rif gcd(i, j)==1:\rstore[i].append(j)\rfor u, v in edges:\rg[u].append(v)\rg[v].append(u)\rdef dfs(u, last, level):\rret[u] = max(mem[i] for i in store[nums[u]])[1]\rtmp = mem[nums[u]]\rmem[nums[u]] = (level, u)\rfor son in g[u]:\rif son==last:\rcontinue\rdfs(son, u, level+1)\rmem[nums[u]] = tmp\rdfs(0, -1, 0)\rreturn ret\r\u0026#34;\u0026#34;\u0026#34; 好的，你现在需要做的是 ： 我给你其他题目，并给出已经AC的代码实现，你需要补充：1、题目大意 2、实现思路\r如果你已经了解了我的需求，请回复我懂了 ","permalink":"https://showguan.github.io/en/posts/tech/leetcode%E7%AC%94%E8%AE%B0/","summary":"LeetCode笔记 目标：2500分 剑指Offer + 数据流中的中位数 用两个堆模拟， 左边大顶堆，右边小顶堆，则两个堆顶是最中间的数字。 添加数字","title":" LeetCode笔记"},{"content":"Linux 快捷键：\nctrl + l 清空屏幕\nLinux文件系统 FHS3.0（File system Hierarchy Standard） / etc 配置文件 bin 必要命令 usr 二级目录 home 家目录 var 动态数据 VFS虚拟文件系统 内核层抽象出通用的文件系统接口\n支持文件、网络、特殊文件系统\n抽象对象：\n超级快：文件系统 目录项：文件路径 索引节点：具体文件 文件：进程打开的文件 属性分层结构\n一切皆文件\n数据盘挂载 fdisk -l inode ：存储数据的元数据\nLinux没有盘符的概念，只有一个根目录/，所有文件都在其下\n/\n根目录 层级关系 命令 通用格式：\ncommand [-options] [parameter] command ：命令本身 -options： [可选，非必填] 命令的一些选项，可以通过选项控制命令的行为细节 parameter： [可选，非必填]命令的参数，多数用于命令的指向目标等 语法中[]表示可选\nls ls [-a -l -h] [Linux路径] -a all 前面带.的文件使隐藏文件/文件夹，只有通过-a选项才能看到 -l 以列表（竖向排列） -h 表示以易于阅读的形式，列出文件大小，如K，M，G /home/用户名\n组合使用\ncd change directory\ncd [Linux路径] 不写参数回到用户的HOME目录下\n绝对路径 相对路径 . 表示当前目录\n.. 表示上一级目录\n~ 表示HOME目录\nmkdir 创建目录\nmkdir [-p] 路径 -p可选，创建多级不存在的目录时使用\ntouch 创建文件\ntouch 路径\ncat 查看内容\ncat 路径\nmore 查看内容，支持翻页，空格翻页，q退出\nmore 路径\ncp 可以用于复制文件\\文件夹\ncp [-r] 参数1 参数2 -r选项，可选，用于复制文件夹使用，表示递归 参数1，Linux路径，表示被复制的文件或文件夹 参数2，Linux路径，表示要复制去的地方 mv mv 参数1 参数2 可以用于改名\nrm 删除文件，文件夹\nrm [-r -f] 参数1 参数2 参数n -r， 删除文件夹 -f，force，强制删除（不会弹出提示信息） 普通用户删除内容不会弹出提示，只有root管理员用户删除内容会有提示 所以一般普通用户用不到-f 参数1，参数2， \u0026hellip;，参数n 表示要删除的文件或文件夹路径，按照空格隔开。 支持用通配符来模糊匹配\npwd Print Work Directory\ntree 树状目录\nwhich Linux命令本体就是一个个的二进制可执行文件\nwhich 命令 find find 起始路径 -name \u0026#34;被查找文件名\u0026#34; find 起始路径 -size + | -n[kMG] +, - 表示大于和小于 n表示大小数字 kMG表示大小单位，k表示kb,M表示MB，G表示GB grep 通过grep命令，从文件中通过关键字过滤文件行\ngrep [-n] 关键字 文件路径 选项 -n 可选，表示在结果中显示匹配的行的行号\n参数，关键字，必填，表示过滤的关键字，带有空格或其它特殊符号，建议使用“ ”将关键字包围起来\n参数，文件路径，必填，表示要过滤内容的文件路径，可作为内容输入端口\nwc wc [-c -m -l -w] 文件路径 选项， -c， 统计bytes数量 选项，-m，统计字符数量 选项，-l，统计行数 选项，-w，统计单词数量 参数，文件路径， 被统计的文件，可作为内容输入端口 默认行数、字数、字符数\n管道符 左 | 右。 将左边的结果作为右边的输入\necho 命令行内输出指定内容\n反引号` 在echo中，用``括起来表示命令信息\necho `pwd` 重定向符号 \u0026gt; 将左侧命令的结果，覆盖写入到符号右侧指定的文件中 \u0026gt;\u0026gt; 将左侧命令的结果，追加写入到符号右侧指定的文件中 tail tail [-f -num] 参数 参数，linux命令，表示被跟踪的文件路径 选项，-f，表示持续跟踪 选项，-num，表示尾部多少行，不填默认10行 Vim 命令模式 i : 在当前光标位置进入输入模式\na : 在当前光标位置 之后 进入输入模式\nI ： 在当前行的开头，进入输入模式\nA ： 在当前行的结尾，进入输入模式\no : 在当前行的下一行进入输入模式\nO ： 在当前行的上一行进入输入模式\n0 : 移动光标至开头\n$ : 移动给光标至行结尾\npageup : 向上翻页\npagedown : 向下翻页\n/ ： 进入搜索模式\nn : 向下继续搜索\nN : 向上继续搜索\ndd ： 删除光标所在的行\nndd : n是数字，表示删除当前光标向下n行\nyy : 复制当前行\nnyy ： 复制当前行和下面的n行\np : 粘贴复制的内容\nu : 撤销修改\nctrl + r ： 反向撤销修改\ngg ： 跳到首行\nG ： 跳到尾行\ndG : 从当前行开始，向下全部删除\ndgg ： 从当前行开始，向上全部删除\ndS : 从当前光标开始，删除到本行的结尾\nd0 ： 从当前光标开始，删除到本行的开头\n底线命令模式 : wq 保存并退出 q 仅退出\nq! 强制退出\n:w 仅保存\n:set nu 显示行号\n:set paste 设置粘贴模式\nLinux权限和用户 su su [-] [用户名] sudo 普通用户使用sudo使用root权限\n用户与用户组\n用户和用户组 groupadd 创建用户组 groupdel 用户组名 useradd [-g -d] 用户名 选项： -g指定用户的组，不指定-g，会创建同名组加入，指定-g需要组已经存在，如已存在同名组，必须使用-g。 选项： -d指定用户HOME路径，不指定，HOME目录默认在： /home/用户名 userdel [-r] 用户名 选项：-r，删除用户的HOME目录，不使用-r，删除目录时，HOME目录保留 id [用户名] 参数：用户名，被查看的用户，如果不提供则查看自身。 usermod -aG 用户组 用户名 将指定用户加入指定用户组 getent passwd\rgetent group 使用getent命令，可以查看当前系统内有那些命令\n七份信息：\n用户名 ： 密码（X） ： 用户ID ： 组ID ： 描述信息（无用） ： HOME目录 ： 执行终端（默认bash）\n查看权限管控信息 文件或文件夹的控制信息\n文件或文件夹所属用户\n文件或文件夹所属用户组\n第一个d表示文件夹 所属用户 所有用户组 所属其他用户 r代表读 文件夹表示可以查看文件夹内容 w代表写 文件夹表示可以在文件夹内：创建，删除，改名等操作 x代表可执行权限，针对文件表示可以将文件作为程序执行 针对文件夹，表示可以更改工作目录到此文件夹，即cd进入 chmod 修改文件或目录的权限。\nchmod u = rwx, g = rx, o = x hello.txt -R选项可以将文件夹以及文件夹内全部内容权限设置为：rwxrwxrwx\nchmod -R u=rwx, g=rwx, o=rwx hello.tx 使用数字序号\nchmod 751 hello.txt chown 更改文件或目录的所有者为指定的用户或用户组。\nchown [-R] [用户] [:] [用户组] 文件或文件夹 选项，-R，同chmod，对文件夹内全部内容应用相同规则 选项，用户，修改所属用户 选项，用户组，修改所属用户组 ： 用于分隔用户和用户组 普通用户无法使用，只能用root用户\nLinux使用操作 快捷键： ctrl + c 强制停止,退出当前命令输入 ctrl + d 退出账户的登录 history 查看历史输入的命令 !搜索历史命令，自动匹配，例如！py ctrl + a，跳到命令开头 ctrl + e，跳到命令结尾 ctrl + 键盘左键， 向左跳一个单词 ctrl + 键盘右键， 向右跳一个单词 ctrl + l 清空终端内容 clear 清空终端内容 软件安装 yum ： RPM软件管理器，用于自动化安装配置Linux软件，并可以自动解决依赖问题。\nyum [-y] [install | remove | search] 软件名称 -y 自动确认，无需手动确认安装或卸载过程 yum命令需要root权限，可以su切换到root，或使用sudo权限，yum命令需要联网\nUbuntu apt [-y] [install | remove | search] wget systemctl systemctl start | stop | status | enable | disable 服务名 NetworkManager, 主网络服务 newwork, 副网络服务 firewalld , 防火墙服务 sshd, ssh服务（FinalShell远程登录Linux使用的就是此服务） 除了内置的服务以外，部分第三方软件安装后也可以用systemctl进行控制\n软链接 在系统中创建软链接，可以将文件、文件夹链接到其他位置。类似快捷方式\nln -s 参数1 参数2 -s ，创建软链接 参数1 ： 被链接的文件或文件夹 参数2 ： 要链接去的目的地 日期，时区 date [-d] [+格式化字符串] -d按照给定的字符串显示日期，一般用于日期计算\n格式化字符串： 通过特定的字符串标记，来控制显示的日期格式\n%Y ， 年 %y,， 年份后两位数字（00，99） %M 月份 （01，12） %d 日(01,31) %H 小时（00，23） %M 分钟（00，59） %S 秒（00，59） %s 自1970-01-01 00:00:00到现在的秒数 使用-d支持的时间标记：(同样支持格式化字符串)\nyear 年 month 月 day 天 hour 小时 minute 分钟 second 秒 ntp 可以自动联网同步时间，也可以通过ntp -u ntp.aliyun.com 手动校准时间\nIP地址 DHCP : 动态获取IP地址，即每次重启设备后都会获取一次，可能导致IP地址频繁变更\n每一台联网的电脑都会有一个地址，用于和其他计算机进行通信，IP地址主要有两个版本，V4和V6版本\nIPv4的地址格式为a.b.c.d，其中abcd表示0~255的数字，如192.168.88.101\n通过ipconfig查看本机的IP地址。\n127.0.0.1表示本机\n0.0.0.0\n可以用于指代本机 可以在端口绑定中用来确定绑定关系 在一些IP地址中，表示所有IP的意思，如放行规则设置为0.0.0.0，表示允许任意IP访问 主机名 hostname 修改主机名\nhostnamectl set-hostname name 域名解析 ping 可以通过ping命令来检查指定的网络服务器是否是可联通的。\nping [-c num] ip或主机名 选项， -c，检查的次数，不适用-c选项，将无限次数持续检查 参数：ip或主机名，被检查的服务器的ip地址或主机名地址 wget 非交互式的文件下载器，可以在命令行内下载网络文件\nwget [-b] url 选项 ： -b ，后台下载，会将日志写入到当前工作目录的wget-log文件 参数：url，下载链接 curl 发送http网络请求，可用于下载文件，获取信息等\ncurl [-O] url 选项：-O，用于下载文件，当url是下载链接时，可以使用此选项保存文件 参数：url，要发起请求的网络地址 端口 端口，是设备与外界通讯交流的出入口，端口可以分为物理端口和虚拟端口\n物理端口：又可称之为接口，是可见的端口，如USB接口，RJ45网口，HDMI端口等 虚拟端口：是指计算机内部的端口，是不可见的，是用来操作系统和外部进行交互使用的 Linux支持65535个端口，分为3类进行使用：\n公认端口：1~1023，通常用于一些系统内置或知名程序的预留使用，如SSH服务的22端口，HTTPS服务的443端口，非特殊需要，不要占用这个范围的端口 注册端口：1024~49151，通常可以随意使用，用于松散的绑定一些程序/服务 动态端口：49152~65535，通常不会固定绑定程序，而是当程序对外进行网络链接时，用于临时使用。 进程管理 ps [-e -f] -e 显示出全部的进程 -f 以完全格式化的形式展示信息（展示全部信息） 一般来说，固定用法就是 ps -ef 列出全部进程的全部信息 UID ： 进程所属的用户ID\nPID ： 进程的进程号ID\nPPID ： 进程的父ID（启动此进程的其他进程）\nC ： 此进程的CPU占用率（百分比）\nSTIME ： 进程的启动时间\nTTY ： 启动此进程的终端序号，如果显示？，表示非终端启动\nTIME ： 进程启用CPU的时间\nCMD ： 进程对应的名称或启动路径和启动命令\n关闭进程 kill -9 进程ID -9, 表示强制关闭进程，不适用此选项会向进程发送信号要求其关闭，但是否关闭看进程自身的处理机制 主机状态 查看CPU，内存使用情况\ntop 第一行 ：\ntop ： 命令名称\n14：08 ：23 当前系统时间，up 6min：启动了六分钟\n2 users : 2个用户登录， load ：15分钟负载\n第二行：\nTasks : 175个进程 1 running : 1个子进程在运行\n174 sleeping : 174个进程睡眠，0个停止进程， 0个僵尸进程\n第三行：\n%Cpu(s) : CPU使用率，us：用户CPU使用率，sy ：系统CPU使用率，ni：高优先级进程占用CPU时间百分比，id：空闲CPU率，wa：IO等待CPU占用率，hi：CPU硬件中断率，si：CPU软件中断率，st：强制等待占用CPU率\n第四、五行\nKib Mem : 物理内存，total : 总量， free : 空闲， used ： 使用， buff/cache : buff和cache占用\nKibSwap : 虚拟内存（交换空间），total : 总量，free : 空闲，used：使用，buff/cache : buff和cache占用\nPID ： 进程ID USER ： 进程所属用户 PR ： 进程优先级，越小越好 NI ： 负值表示高优先级，正表示低优先级 VIRT ： 进程使用虚拟内存，单位KB RES ： 进程使用物理内存，单位KB SHR ： 进程使用共享内存， 单位KB S ： 进程状态(S休眠，R运行，Z僵死状态，N负数优先级，I空闲状态) %CPU ： 进程占用CPU率 %MEM： 进程占用内存率 TIME+ ： 进程使用CPU时间总计，单位10毫秒 COMMAND ： 进程的命令或名称或程序文件路径 -p : 只显示某个进程信息 -d : 设置刷新时间，默认为5s -c : 显示产生进程的完整命令，默认是进程名 -n : 制定刷新次数，比如 top -n 3 是新输出三次后退出 -b : 以非交互非全屏模式运行，以批次的方式执行top，一般配合-n制定输出几次统计信息，将输出重定向到制定文件，比如 top -b -n 3 \u0026gt; /tmp/top.tmp -i : 不显示任何闲置（idle）或无用的进程 -u ： 查找特定用户启动的进程 top以交互式运行：\nh ： 按下h键，会显示帮助画面 c ： 按下c键，会显示产生进程的完整命令，等同于-c参数 f ： 可以选择需要展示的项目 M ： 根据驻留内存大小（RES）排序 T ： 根据CPU使用百分比大小进行排序 T ： 根据时间/累计时间进行排序 E ： 切换顶部内存显示单位 e ： 切换进程内存显示单位 l ： 切换显示平均负载和启动时间信息 i ： 不显示闲置或无用的进程，等同于-i参数 t ： 切换显示CPU状态信息 m ： 切换显示内存信息 硬盘使用情况：\ndf -h -h， 以更加人性化的单位显示 磁盘信息监控：\niostat [-x] [num1] [num2] 网络状态监控：\n可以使用sar命令查看网络的相关统计 sar -n DEV num1 num2 -n 查看网络，DEV表示查看网络接口 num1 : 刷新间隔（不填就查看一次阶数）num2 : 查看次数（不填无限次数） 环境变量 环境变量是一组信息记录，类型是Key Value类型（名称=值），用于操作系统运行的时候记录关键信息\nenv 查看环境变量\n环境变量： PATH，通过$取出环境变量的值\n环境变量PATH会记录一组目录，目录之间用：隔开。记录的是命令的搜索路径。当执行命令会从记录中记录的目录中挨个搜索要执行的命令并执行\n可以通过这个项目的值，加入自定义的命令搜索路径\n如\nexport PATH = $PATH 修改环境变量\n临时生效 ： export 名称= 值 永久生效 针对用户 ： ~/bashrc文件中配置 针对全部用户 文件上传和下载 通过finalShell或者xshell 上传或下载，拖动\n压缩和解压 .tar 称之为tarball，对党文件，即简单的将文件组装到一个.tar的文件中，并没有太多文件体积的减少，仅仅是简单的封装 .gz，也常见为.tar.gz，gzip格式压缩文件，即使用gzip压缩算法将文件压缩到一个文件内，可以极大的减少压缩后的体积 tar [-c -v -x -f -z -C] 参数1 参数2 ... 参数N -c 创建压缩文件，用于压缩模式 -v 显示压缩，解压过程，用于查看进度 -x 解压模式 -f 要创建的文件，或者要解压的文件，-f选项必须在所有选项中位置处于最后一个 -z gzip模式，不适用-z就是普通的tarball模式 -C 选择解压的目的地，用于解压模式 zip [-r] 参数 -r 压缩文件夹使用 unzip unzip [-d] 参数\n-d 制定解压的目录 Mysql wget --no-check-certificate https: /dlcdn.apache.org/tomcat/tomcat10/v10.0.27/bin/apache-tomcat-10.0.27.tar.gz Redis ElasticSearch Tomcat Nginx RabbitMq ","permalink":"https://showguan.github.io/en/posts/tech/linux/","summary":"Linux 快捷键： ctrl + l 清空屏幕 Linux文件系统 FHS3.0（File system Hierarchy Standard） / etc 配置文件 bin 必要命令 usr 二级目录 home 家目录 var 动态数据 VF","title":" Linux"},{"content":"Java20天速成——进阶课程(2) 正则表达式 符号 含义 举例 [] 匹配方括号内的任一字符 [abc] ^ 匹配除指定字符外的任意字符 [^abc] \u0026amp;\u0026amp; 匹配两个字符集的交集，需作为整体出现 [a-z\u0026amp;\u0026amp;m-p] . 匹配除换行符外的任意字符 a.b （匹配 \u0026ldquo;a\u0026rdquo; 后接任意字符，再接 \u0026ldquo;b\u0026rdquo;） \\ 转义字符，用于匹配特殊字符 \\\\d \\\\d 匹配数字 0-9 \\\\d+ \\\\D 匹配非数字字符 \\\\D+ \\\\s 匹配空白字符 \\s匹配空格、制表符、换行符等等 \\\\S 匹配非空白字符 \\\\S+ （匹配非空白字符序列） \\\\w 匹配单词字符 [a-zA-Z_0-9] \\\\W 匹配非单词字符 [^\\w] * 匹配前面的元素零次或多次，即可有可无 a*b （匹配 \u0026ldquo;b\u0026rdquo;、\u0026ldquo;ab\u0026rdquo;、\u0026ldquo;aab\u0026rdquo;、等等） ? 匹配前面的元素零次或一次，即可有可无 colou?r （匹配 \u0026ldquo;color\u0026rdquo; 或 \u0026ldquo;colour\u0026rdquo;） () 分组，将其中的字符视为一个单元 a(bc)+ ` ` 或，用于匹配多个模式中的任意一个 \\f 匹配换页符 \\f 这样整理包括了 * 和 ? 的含义及举例，更全面了。\npublic static void method1() { // 给定的字符串包含了电话号码和邮箱地址的信息 String data = \u0026#34; 来黑马程序员学习Java，\\n\u0026#34; + \u0026#34; 电话：1866668888，18699997777\\n\u0026#34; + \u0026#34; 或者联系邮箱：boniu@itcast.cn，\\n\u0026#34; + \u0026#34; 座机电话：01036517895，010-98951256\\n\u0026#34; + \u0026#34; 邮箱：bozai@itcast.cn，\\n\u0026#34; + \u0026#34; 邮箱：dlei0009@163.com，\\n\u0026#34; + \u0026#34; 热线电话：400-618-9090 ，400-618-4000，4006184000，4006189090\u0026#34;; // 定义正则表达式来匹配电话号码和邮箱地址 String regex = \u0026#34;(1[3-9]\\\\d{9})|\u0026#34; + \u0026#34;(0\\\\d{2,9}-?\\\\d{7,18})|\u0026#34; // 匹配固定电话号码，包括区号和分机号 + \u0026#34;(\\\\w{2,}@\\\\w{2,20}(\\\\.\\\\w{2,10}){1,2})\u0026#34; // 匹配邮箱地址 + \u0026#34;|(400-?\\\\d{3,7}-?\\\\d{3,7})\u0026#34;; // 匹配400电话号码，包括可能的分机号 // 编译正则表达式 Pattern pattern = Pattern.compile(regex); // 创建匹配器对象 Matcher matcher = pattern.matcher(data); // 循环查找匹配项并打印 while(matcher.find()){ String res = matcher.group(); // 获取匹配到的字符串 System.out.println(res); } } String s1 = \u0026#34;古力娜扎ai8888迪丽热巴999aa5566马尔扎哈fbbfsfs42425卡尔扎巴\u0026#34;; System.out.println(s1.replaceAll(\u0026#34;\\\\w+\u0026#34;, \u0026#34;-\u0026#34;)); String s2 = \u0026#34;我我我喜欢编编编编编编编编编编编编程程程\u0026#34;; System.out.println(s2.replaceAll(\u0026#34;(.)\\\\1+\u0026#34;, \u0026#34;$1\u0026#34;)); String s3 = \u0026#34;古力娜扎ai8888迪丽热巴999aa5566马尔扎哈fbbfsfs42425卡尔扎巴\u0026#34;; String[] names = s3.split(\u0026#34;\\\\w+\u0026#34;); System.out.println(Arrays.toString(names)); 异常 Error： 代表的系统级别错误（属于严重问题）， 也就是说系统一旦出现问题，sun公司会把这些问题封装成Error对象给出了，即Error是Sun公司自己用的，而不是给程序员用的\nException：异常，它代表的才是程序可能出现的错误，所以通常会用Exception以及它的子类来封装程序出现的错误\n运行时异常：RuntimeException及其子类，编译阶段不会出现错误提醒，运行时出现的异常（数组索引越界异常） 编译时异常：编译阶段就会出现的错误提醒。（日期解析异常） 自定义异常 运行时异常 package com.showguan.Exception; // 自定义运行时异常类，用于表示年龄不合法的情况 public class AgeIllegalRuntimeException extends RuntimeException { // 默认构造函数 public AgeIllegalRuntimeException() { } // 带有消息参数的构造函数，用于传递异常信息 public AgeIllegalRuntimeException(String message) { super(message); } } public class Main { // 保存年龄的方法，如果年龄不合法则抛出自定义的运行时异常 public static void saveAge(int age) { if (age \u0026gt; 0 \u0026amp;\u0026amp; age \u0026lt; 150) { System.out.println(\u0026#34;年龄合法\u0026#34;); } else { throw new AgeIllegalRuntimeException(\u0026#34;/age is illegal, your age is \u0026#34; + age); } } public static void main(String[] args) { try { // 调用保存年龄的方法，传入一个不合法的年龄值 saveAge(-1); System.out.println(\u0026#34;底层执行成功了\u0026#34;); } catch (Exception e) { // 捕获自定义的异常并打印异常信息 e.printStackTrace(); System.out.println(\u0026#34;底层出现了异常\u0026#34;); } } } 编译时异常 package com.showguan.Exception; // 自定义异常类，继承自Exception类，用于表示年龄不合法的情况 public class AgeIllegalException extends Exception { // 默认构造函数 public AgeIllegalException() { } // 带有消息参数的构造函数，用于传递异常信息 public AgeIllegalException(String message) { super(message); } } public class Main { // 保存年龄的方法，如果年龄不合法则抛出自定义的受检查异常 public static void saveAge2(int age) throws AgeIllegalException { if (age \u0026gt; 0 \u0026amp;\u0026amp; age \u0026lt; 150) { System.out.println(\u0026#34;年龄合法\u0026#34;); } else { throw new AgeIllegalException(\u0026#34;/age is illegal, your age is \u0026#34; + age); } } public static void main(String[] args) { try { // 调用保存年龄的方法，传入一个合法的年龄值 saveAge2(1); System.out.println(\u0026#34;底层执行成功了\u0026#34;); } catch (Exception e) { // 捕获自定义的异常并打印异常信息 e.printStackTrace(); System.out.println(\u0026#34;底层出现了异常\u0026#34;); } } } public class Demo2 { public static void main(String[] args) { try { // 调用test1方法，该方法声明了可能抛出ParseException和FileNotFoundException异常 test1(); } catch (ParseException e) { // 捕获ParseException异常，并输出错误提示信息 System.out.println(\u0026#34;日期格式错误，请检查日期格式\u0026#34;); // 抛出一个新的RuntimeException异常，将原始异常作为其cause throw new RuntimeException(e); } catch (FileNotFoundException e) { // 捕获FileNotFoundException异常，并输出错误提示信息 System.out.println(\u0026#34;指定文件夹内没有该文件，请检查文件路径\u0026#34;); // 抛出一个新的RuntimeException异常，将原始异常作为其cause throw new RuntimeException(e); } } // test1方法声明了可能抛出ParseException和FileNotFoundException异常 public static void test1() throws ParseException, FileNotFoundException { // 创建SimpleDateFormat对象，用于解析日期字符串 SimpleDateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); // 解析日期字符串，如果日期格式不正确会抛出ParseException异常 Date d = sdf.parse(\u0026#34;2077-09-23 10:34:22\u0026#34;); System.out.println(d); // 调用test2方法，该方法声明了可能抛出FileNotFoundException异常 test2(); } // test2方法声明了可能抛出FileNotFoundException异常 public static void test2() throws FileNotFoundException { // 创建FileInputStream对象，如果指定文件不存在会抛出FileNotFoundException异常 InputStream is = new FileInputStream(\u0026#34;D:/Java.txt\u0026#34;); } } package com.showguan.Exception; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.InputStream; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; public class Demo3 { public static void main(String[] args) { try { // 调用test1方法，该方法声明了可能抛出Exception异常 test1(); } catch (Exception e) { // 捕获Exception异常，并输出错误提示信息 System.out.println(\u0026#34;操作有误\u0026#34;); // 抛出一个新的RuntimeException异常，将原始异常作为其cause throw new RuntimeException(e); } } // test1方法声明了可能抛出Exception异常 public static void test1() throws Exception { // 创建SimpleDateFormat对象，用于解析日期字符串 SimpleDateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); // 解析日期字符串，如果日期格式不正确会抛出ParseException异常 Date d = sdf.parse(\u0026#34;2077-09-23 10:34:22\u0026#34;); System.out.println(d); // 调用test2方法，该方法声明了可能抛出Exception异常 test2(); } // test2方法声明了可能抛出Exception异常 public static void test2() throws Exception { // 创建FileInputStream对象，如果指定文件不存在会抛出FileNotFoundException异常 InputStream is = new FileInputStream(\u0026#34;D:/Java.txt\u0026#34;); } } 集合 Collection集合特点：\nList系列集合：添加的元素是有序、可重复、有索引的。\nArrayList, LinkedList：有序、可重复、有索引 Set系列集合：添加的元素是无序、不重复、无索引\nHashSet: 无序、不重复、无索引 LinkedHashSet: 有序、不重复、无索引 TreeSet : 按照大小默认升序排列、不重复、无索引 Collection import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; public class Main { public static void main(String[] args) { // 创建一个ArrayList对象，并向其中添加元素 Collection\u0026lt;String\u0026gt; c = new ArrayList\u0026lt;\u0026gt;(); c.add(\u0026#34;java1\u0026#34;); c.add(\u0026#34;java2\u0026#34;); c.add(\u0026#34;java3\u0026#34;); c.add(\u0026#34;java1\u0026#34;); // 可以添加重复元素 System.out.println(c); // 输出集合中的所有元素 // 清空集合中的所有元素 // c.clear(); System.out.println(c); // 判断集合是否为空 System.out.println(c.isEmpty()); // 获取集合中元素的个数 System.out.println(c.size()); // 判断集合是否包含指定元素 System.out.println(c.contains(\u0026#34;java1\u0026#34;)); // 移除集合中的指定元素 c.remove(\u0026#34;java1\u0026#34;); System.out.println(c); // 将集合转换为数组 Object[] arr = c.toArray(); System.out.println(Arrays.toString(arr)); // 将集合转换为指定类型的数组 String[] arr2 = c.toArray(new String[c.size()]); System.out.println(Arrays.toString(arr2)); // 创建另一个集合，并将其元素全部添加到当前集合中 Collection\u0026lt;String\u0026gt; c2 = new ArrayList\u0026lt;\u0026gt;(); c2.add(\u0026#34;Java8\u0026#34;); c2.add(\u0026#34;java9\u0026#34;); c.addAll(c2); System.out.println(c); } } 迭代器 import java.util.ArrayList; import java.util.Collection; import java.util.function.Consumer; public class Main { public static void main(String[] args) { // 创建一个 ArrayList 集合对象 Collection\u0026lt;String\u0026gt; c = new ArrayList\u0026lt;\u0026gt;(); // 向集合中添加元素 c.add(\u0026#34;Kennem\u0026#34;); c.add(\u0026#34;999\u0026#34;); c.add(\u0026#34;show\u0026#34;); // 使用 forEach 方法遍历集合，传统方式 c.forEach(new Consumer\u0026lt;String\u0026gt;() { @Override public void accept(String s) { System.out.println(s); } }); // 使用 Lambda 表达式遍历集合，Lambda 参数类型推断 c.forEach((String s) -\u0026gt; { System.out.println(s); }); // 使用 Lambda 表达式遍历集合，简化参数类型 c.forEach((String s) -\u0026gt; System.out.println(s)); // 使用方法引用遍历集合，等同于 Lambda 表达式 System.out::println c.forEach( System.out::println ) ; } } public class Main { public static void main(String[] args) { // 创建一个 Movie 类型的集合对象 Collection\u0026lt;Movie\u0026gt; movies = new ArrayList\u0026lt;\u0026gt;(); // 向集合中添加 Movie 对象 movies.add(new Movie(\u0026#34;《阿甘正传》\u0026#34;, 9.5, \u0026#34;汤姆\u0026#34;)); // 打印集合内容 System.out.println(movies); // 使用增强型 for 循环遍历集合中的 Movie 对象 for (Movie movie : movies) { // 获取电影名称并打印 System.out.println(movie.getName()); // 获取电影评分并打印 System.out.println(movie.getScore()); // 获取主演名称并打印 System.out.println(movie.getActor()); } } } List() ArrayList() import java.util.ArrayList; import java.util.List; public class Main { public static void main(String[] args) { // 创建一个 ArrayList 对象 ls List\u0026lt;String\u0026gt; ls = new ArrayList\u0026lt;\u0026gt;(); // 向 ls 中添加元素 ls.add(\u0026#34;Kennem\u0026#34;); ls.add(\u0026#34;K\u0026#34;); ls.add(\u0026#34;至尊宝\u0026#34;); ls.add(\u0026#34;牛夫人\u0026#34;); // 打印 ls 的内容 System.out.println(ls); // 在索引位置 2 插入元素 \u0026#34;紫霞仙子\u0026#34; ls.add(2, \u0026#34;紫霞仙子\u0026#34;); System.out.println(ls); // 移除索引位置 2 处的元素并打印移除的元素 System.out.println(ls.remove(2)); // 打印 ls 的内容 System.out.println(ls); // 获取索引位置 2 处的元素并打印 System.out.println(ls.get(2)); // 将索引位置 1 处的元素修改为 \u0026#34;牛魔王\u0026#34;，并打印被替换掉的元素 System.out.println(ls.set(1, \u0026#34;牛魔王\u0026#34;)); // 打印 ls 的内容 System.out.println(ls); } } LinkedList() import java.util.ArrayList; import java.util.Iterator; import java.util.List; public class Main { public static void main(String[] args) { // 创建一个 ArrayList 对象 ls List\u0026lt;String\u0026gt; ls = new ArrayList\u0026lt;\u0026gt;(); // 向 ls 中添加元素 ls.add(\u0026#34;孙悟空\u0026#34;); ls.add(\u0026#34;至尊宝\u0026#34;); ls.add(\u0026#34;蜘蛛精\u0026#34;); // 打印 ls 的内容 System.out.println(ls); // 使用普通 for 循环遍历 ls for (int i = 0; i \u0026lt; ls.size(); i++) { String s = ls.get(i); System.out.println(s); } // 使用迭代器 Iterator 遍历 ls Iterator\u0026lt;String\u0026gt; it = ls.iterator(); while (it.hasNext()) { System.out.println(it.next()); } // 使用增强型 for 循环遍历 ls for (String l : ls) { System.out.println(l); } // 使用 Lambda 表达式遍历 ls ls.forEach(s -\u0026gt; { System.out.println(s); }); } } Set() HashSet() 哈希值\n就是一个int类型的数值，Java中每个对象都有一个哈希值 Java中的所有对象，都可以调用Object类提供的hashCode方法，返回该对象自己的哈希值 哈希表\nJDK 8之前， 基于数组+链表\n创建一个默认长度为16的数组，默认加载因子为0.75， 数组名为table 使用元素的哈希值对数组长度求余计算出应存入的位置 判断当前位置是否为null， 如果是null直接存入 如果不为null， 表示有元素，则调用equals方法比较 若相等则不存入，否则存入 JDK 8之前，新元素存入数组，占老元素位置，老元素挂下面 JDK 8开始之后， 新元素直接挂在老元素下面 JDK 8开始之后，哈希表中引入了红黑树，进一步提高了操作数据的性能\n树：\n二叉树中，任意节点的度\u0026lt;=2\n度：每一个节点的子节点数量 树高：树的总层数 根节点：最顶层的节点 二叉查找树（二叉排序树）\n**规则：**小的存左边，大的存右边，一样的不存\n平衡二叉树：左右子树的高度差不超过1\n红黑树：可以自平衡的二叉树, 是一种增删改查性能都相对较好的结构\n从JDK8开始，当链表的长度超过8，且数组长度\u0026gt;=64时，自动将链表转成红黑树\npublic static void main(String[] args) { // 创建一个 HashSet 对象，用于存储整数数据 Set\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); // 往 HashSet 中添加整数元素 // HashSet 会自动去重，不会存储重复的元素 set.add(999); // 添加整数 999 set.add(999); // 添加重复的整数 999，但由于 HashSet 不允许重复元素，此次添加无效 set.add(777); // 添加整数 777 // 打印 HashSet 中的元素 // 输出结果：[777, 999] // HashSet 中的元素无序，并且已经去重了，只保留了一个 999 System.out.println(set); } LinkedHashSet public static void main(String[] args) { // 创建一个 LinkedHashSet 对象，用于存储整数数据，并保持元素的插入顺序 Set\u0026lt;Integer\u0026gt; set = new LinkedHashSet\u0026lt;\u0026gt;(); // 往 LinkedHashSet 中添加整数元素 // LinkedHashSet 会保持元素的插入顺序，并且会自动去重，不会存储重复的元素 // 添加顺序：999, 000, 777, 888 // 由于 LinkedHashSet 会保持插入顺序，因此打印时也会按照添加顺序输出 set.add(999); set.add(000); // 注意：整数 000 在打印时会自动去掉前导零，变成 0 set.add(777); set.add(888); set.add(999); // 重复元素不会被添加进 LinkedHashSet // 打印 LinkedHashSet 中的元素 // 输出结果：[999, 0, 777, 888] // LinkedHashSet 中的元素按照插入顺序排列，并且去重了 System.out.println(set); } TreeSet() 基于红黑树实现排序，\npublic static void main(String[] args) { // 创建一个 TreeSet 对象，用于存储整数数据，并按照自然顺序进行排序 Set\u0026lt;Integer\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(); // 往 TreeSet 中添加整数元素 // TreeSet 会自动去重，不会存储重复的元素 // 添加顺序：999, 000, 777, 888 // 由于 TreeSet 是有序的，它会根据自然顺序（从小到大）对元素进行排序 set.add(999); set.add(000); // 注意：整数 000 在打印时会自动去掉前导零，变成 0 set.add(777); set.add(888); set.add(999); // 重复元素不会被添加进 TreeSet // 打印 TreeSet 中的元素 // 输出结果：[0, 777, 888, 999] // TreeSet 中的元素已经按照自然顺序排好序，并且去重了 System.out.println(set); } 对于自定义对象，确保存储的值相同就重复，重写hashCode方法\n@Override public int hashCode() { return Objects.hash(name, age, height);//只要内容一样，哈希值就相同 } 自定义排序规则： TreeSet集合存储自定义类型的对象时， 必须指定排序规则，支持如下两种方式来指定比较规则 方式一\n让自定义的类（如学生类）实现Comparable接口，重写里面的compareTo方法来执行比较规则 @Override public int compareTo(Student o) { return this.age - o.age; } 方式二\n通过调用TreeSet集合有参数构造器，可以设置Comparator对象（比较器对象，用于指定比较规则。） // 就近选择自己自带的比较器进行比较 // Set\u0026lt;Student\u0026gt; students = new TreeSet\u0026lt;\u0026gt;(new Comparator\u0026lt;Student\u0026gt;() { // @Override // public int compare(Student o1, Student o2) { // return Double.compare(o1.getHeight(), o2.getHeight()); // } // }); Set\u0026lt;Student\u0026gt; students = new TreeSet\u0026lt;\u0026gt;( (o1, o2) -\u0026gt; Double.compare(o1.getHeight(), o2.getHeight())); 集合的并发修改异常 public static void main(String[] args) { // 创建一个字符串列表 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;小李子\u0026#34;); list.add(\u0026#34;利玛窦\u0026#34;); list.add(\u0026#34;胡风云\u0026#34;); list.add(\u0026#34;胡面上\u0026#34;); list.add(\u0026#34;胡椒粉\u0026#34;); list.add(\u0026#34;kennem\u0026#34;); list.add(\u0026#34;百事快\u0026#34;); System.out.println(list); // 使用迭代器遍历列表并移除包含特定字符的元素 Iterator\u0026lt;String\u0026gt; it = list.iterator(); while (it.hasNext()) { String name = it.next(); if (name.contains(\u0026#34;胡\u0026#34;)) { it.remove(); // 解决集合的并发修改异常 } } System.out.println(list); // 使用普通for循环遍历列表并移除包含特定字符的元素 // 通过维护索引，避免并发修改异常 /* for (int i = 0; i \u0026lt; list.size(); i++) { String name = list.get(i); if (name.contains(\u0026#34;胡\u0026#34;)) { list.remove(name); i--; // 解决集合的并发修改异常 } } System.out.println(list); */ // 使用增强for循环遍历列表并移除包含特定字符的元素 // 不推荐，会导致ConcurrentModificationException异常 /* for (String s : list) { if (s.contains(\u0026#34;胡\u0026#34;)) { list.remove(s); } } System.out.println(list); */ } 可变参数 public static void main(String[] args) { // 调用test方法，传入单个整数参数 test(1); // 调用test方法，传入单个整数参数 test(10); // 调用test方法，传入多个整数参数，其中最后一个参数为可变参数 test(100, 10, 0); // 调用test方法，传入一个整数参数和一个整数数组参数 test(1, new int[] {1, 2, 4, 4, 3, 3, 3, 3, 4, 3}); } // 1. 一个形参列表中，只能有一个可变参数 // 2. 可变参数必须放在形参列表的最后面 public static void test(int age, int...nums){ // 打印可变参数数组 System.out.println(Arrays.toString(nums)); // 打印可变参数数组的长度 System.out.println(nums.length); // 打印分隔线 System.out.println(\u0026#34;----------\u0026#34;); } Collections public static void main(String[] args) { // 创建一个字符串列表 List\u0026lt;String\u0026gt; names = new ArrayList\u0026lt;\u0026gt;(); // 向列表中添加元素 Collections.addAll(names, \u0026#34;Kennem\u0026#34;, \u0026#34;张一\u0026#34;,\u0026#34;李三\u0026#34;,\u0026#34;王六\u0026#34;); // 打印列表内容 System.out.println(names); // 打乱列表中元素的顺序 Collections.shuffle(names); // 打印打乱后的列表内容 System.out.println(names); // 创建一个整数列表 List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); // 向列表中添加元素 list.add(3); list.add(4); list.add(1); // 对列表中的元素进行排序 Collections.sort(list); // 打印排序后的列表内容 System.out.println(list); // 创建一个学生对象列表 List\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;\u0026gt;(); // 创建学生对象并添加到列表中 Student s1 = new Student(\u0026#34;至尊宝\u0026#34;, 21, 181.9); Student s2 = new Student(\u0026#34;蜘蛛精\u0026#34;, 21, 188); Student s3 = new Student(\u0026#34;牛魔王\u0026#34;, 20, 165.3); Student s4 = new Student(\u0026#34;蝎子精\u0026#34;, 20, 165.3); Student s5 = new Student(\u0026#34;葫芦娃\u0026#34;, 20, 165.3); Student s6 = new Student(\u0026#34;至尊宝\u0026#34;, 21, 181); students.add(s1); students.add(s2); students.add(s3); students.add(s4); students.add(s5); students.add(s6); // 打印学生列表内容 System.out.println(students); // 使用Lambda表达式对学生列表按身高进行排序 Collections.sort(students, (o1, o2) -\u0026gt; Double.compare(o1.getHeight(), o2.getHeight())); // 打印按身高排序后的学生列表内容 System.out.println(students); } Map HashMap ：无序、不重复、无索引；（用的最多） LinkedHashMap：由键决定的特点：有序，不重复，无索引 TreeMap:按照大小默认升序排序，不重复，无索引 public static void main(String[] args) { // 创建一个HashMap对象 Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // 向map中添加键值对 map.put(\u0026#34;手表\u0026#34;, 100); map.put(\u0026#34;手机\u0026#34;, 20); map.put(\u0026#34;Java\u0026#34;, 120); map.put(null, null); // 允许键和值为null // 打印map的内容 System.out.println(map); // 获取map的大小 System.out.println(map.size()); // 清空map // map.clear(); // 打印清空后的map System.out.println(map); // 判断map是否为空 System.out.println(map.isEmpty()); // 获取指定键对应的值 System.out.println(map.get(\u0026#34;手机\u0026#34;)); // 获取一个不存在的键对应的值 System.out.println(map.get(\u0026#34;666\u0026#34;)); // 移除指定键对应的键值对，并返回对应的值 System.out.println(map.remove(\u0026#34;手机\u0026#34;)); // 判断map中是否包含指定的键 System.out.println(map.containsKey(\u0026#34;手机\u0026#34;)); System.out.println(map.containsKey(\u0026#34;手机\u0026#34;)); // 获取map中所有的键，并存储到Set集合中 Set\u0026lt;String\u0026gt; keys = map.keySet(); System.out.println(keys); // 获取map中所有的值，并存储到Collection集合中 Collection\u0026lt;Integer\u0026gt; values = map.values(); System.out.println(values); // 创建另一个HashMap对象 Map\u0026lt;String, Integer\u0026gt; map1 = new HashMap\u0026lt;\u0026gt;(); map1.put(\u0026#34;Java1\u0026#34;, 100); map1.put(\u0026#34;Java2\u0026#34;, 200); map1.put(\u0026#34;Java3\u0026#34;, 300); // 创建另一个HashMap对象 Map\u0026lt;String, Integer\u0026gt; map2 = new HashMap\u0026lt;\u0026gt;(); map2.put(\u0026#34;Java3\u0026#34;, 400); map2.put(\u0026#34;Java4\u0026#34;, 500); // 打印map1和map2的内容 System.out.println(map1); System.out.println(map2); // 将map2中的键值对全部添加到map1中 map1.putAll(map2); // 打印合并后的map1 System.out.println(map1); } 遍历Map public class Main { public static void main(String[] args) { // 创建一个HashMap对象，键为String类型，值为Double类型 Map\u0026lt;String, Double\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // 向map中添加键值对 map.put(\u0026#34;蜘蛛精\u0026#34;, 167.2); // 如果键已存在，则覆盖原有值 map.put(\u0026#34;蜘蛛精\u0026#34;, 169.2); map.put(\u0026#34;至尊宝\u0026#34;, 164.2); map.put(\u0026#34;牛魔王\u0026#34;, 187.2); // 获取map中所有的键，并存储在Set集合中 Set\u0026lt;String\u0026gt; keys = map.keySet(); // 打印所有的键 System.out.println(keys); // 遍历Set集合，获取每个键对应的值，并打印键值对 for (String key : keys) { double value = map.get(key); System.out.println(key + \u0026#34; \u0026#34; + map.get(key)); } } } entry遍历方式 // 获取map中所有的键值对，并存储在Set集合中 Set\u0026lt;Map.Entry\u0026lt;String, Double\u0026gt;\u0026gt; entries = map.entrySet(); // 遍历Set集合，获取每个键值对，并打印键值对 for (Map.Entry\u0026lt;String, Double\u0026gt; entry : entries) { String key = entry.getKey(); double value = entry.getValue(); System.out.println(key + \u0026#34;-----\u0026gt;\u0026#34; + value); } forEach方式遍历\n// 使用forEach方法遍历map，打印每个键值对 map.forEach((k, v) -\u0026gt; { System.out.println(k + \u0026#34;---\u0026gt;\u0026#34; + v); }); LinkedHashMap 类似LinkedHashSet(), 而且LinkedHashSet()底层使用的就是linkedHashMap()\npublic static void main(String[] args) { // 创建一个LinkedHashMap对象，键为Student类型，值为Integer类型 Map\u0026lt;Student, Integer\u0026gt; lmap = new LinkedHashMap\u0026lt;\u0026gt;(); // 向lmap中添加键值对，其中键为Student对象，值为Integer对象 // 注意：Student类需要正确实现equals()和hashCode()方法以确保对象的唯一性 lmap.put(new Student(\u0026#34;Ken\u0026#34;, 25, 150), 100); lmap.put(new Student(\u0026#34;Mary\u0026#34;, 23, 182), 123300); lmap.put(new Student(\u0026#34;Bob\u0026#34;, 21, 1180), 12300); lmap.put(new Student(\u0026#34;Paul\u0026#34;, 22, 130), 12); lmap.put(new Student(\u0026#34;Sam\u0026#34;, 15, 280), 120); lmap.put(new Student(\u0026#34;Ken\u0026#34;, 25, 150), 10); // 注意：与第一个Ken对象相同，但是值不同 // 使用forEach方法遍历lmap，打印每个键值对 lmap.forEach((k, v) -\u0026gt; { System.out.println(k + \u0026#34; \u0026#34; + v); }); } 重写equals方法可以去除重复值\n@Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return age == student.age \u0026amp;\u0026amp; Double.compare(height, student.height) == 0 \u0026amp;\u0026amp; Objects.equals(name, student.name); } TreeMap 比较规则用重写Comparable接口，或者重写Comparator方法\npublic static void main(String[] args) { // 创建一个TreeMap对象，键为Student类型，值为Integer类型 // 在构造TreeMap对象时，传入一个Comparator对象，用于按照学生身高进行排序 Map\u0026lt;Student, Integer\u0026gt; tmap = new TreeMap\u0026lt;\u0026gt;((o1, o2) -\u0026gt; Double.compare(o1.getHeight(), o2.getHeight())); // 向tmap中添加键值对，其中键为Student对象，值为Integer对象 // 注意：Student类需要正确实现equals()和hashCode()方法以确保对象的唯一性 tmap.put(new Student(\u0026#34;Ken\u0026#34;, 25, 150), 100); tmap.put(new Student(\u0026#34;Mary\u0026#34;, 23, 182), 123300); tmap.put(new Student(\u0026#34;Bob\u0026#34;, 21, 1180), 12300); tmap.put(new Student(\u0026#34;Paul\u0026#34;, 22, 130), 12); tmap.put(new Student(\u0026#34;Sam\u0026#34;, 15, 280), 120); tmap.put(new Student(\u0026#34;Ken\u0026#34;, 25, 150), 10); // 与第一个Ken对象相同，但是值不同 // 使用forEach方法遍历tmap，打印每个键值对 tmap.forEach((k, v) -\u0026gt; { System.out.println(k + \u0026#34; \u0026#34; + v); }); } 重写Comparable中的compareTo方法\n@Override public int compareTo(Student o) { return this.age - o.age; } 集合的嵌套 public static void main(String[] args) { // 创建一个HashMap对象，键为String类型，值为List\u0026lt;String\u0026gt;类型 Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // 创建第一个城市列表，存储江苏省的城市信息 List\u0026lt;String\u0026gt; cities1 = new ArrayList\u0026lt;\u0026gt;(); // 使用Collections.addAll方法向cities1中添加多个元素 Collections.addAll(cities1, \u0026#34;南京市\u0026#34;, \u0026#34;扬州市\u0026#34;, \u0026#34;苏州市\u0026#34;, \u0026#34;无锡市\u0026#34;, \u0026#34;常州市\u0026#34;); // 将键值对添加到map中，键为\u0026#34;江苏省\u0026#34;，值为cities1列表 map.put(\u0026#34;江苏省\u0026#34;, cities1); // 创建第二个城市列表，存储湖北省的城市信息 List\u0026lt;String\u0026gt; cities2 = new ArrayList\u0026lt;\u0026gt;(); Collections.addAll(cities2, \u0026#34;武汉市\u0026#34;, \u0026#34;孝感市\u0026#34;, \u0026#34;十堰市\u0026#34;, \u0026#34;宜昌市\u0026#34;, \u0026#34;鄂州市\u0026#34;); map.put(\u0026#34;湖北省\u0026#34;, cities2); // 打印整个map System.out.println(map); // 打印湖北省对应的城市列表 System.out.println(map.get(\u0026#34;湖北省\u0026#34;)); // 使用增强for循环遍历第二个城市列表，打印其中的城市信息 for (String s : cities2) { System.out.println(s); } // 使用forEach方法遍历map，打印每个省份及其对应的城市列表 map.forEach((k, v) -\u0026gt; System.out.println(k + \u0026#34;---\u0026gt;\u0026#34; + v)); } Stream import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.stream.Collectors; public class Main { public static void main(String[] args) { // 创建一个字符串列表 List\u0026lt;String\u0026gt; names = new ArrayList\u0026lt;\u0026gt;(); // 向列表中添加多个元素 Collections.addAll(names, \u0026#34;张某\u0026#34;, \u0026#34;张五一\u0026#34;, \u0026#34;张无忌\u0026#34;, \u0026#34;张三丰\u0026#34;, \u0026#34;Kennem\u0026#34;); // 打印列表中的所有元素 System.out.println(names); // 创建一个新的列表，用于存储以\u0026#34;张\u0026#34;开头且长度为3的字符串 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); // 使用增强for循环遍历原始列表 for (String name : names) { // 如果字符串以\u0026#34;张\u0026#34;开头且长度为3，则添加到新列表中 if (name.startsWith(\u0026#34;张\u0026#34;) \u0026amp;\u0026amp; name.length() == 3) { list.add(name); } } // 打印新列表中的元素 System.out.println(list); // 使用流进行筛选，获取以\u0026#34;张\u0026#34;开头且长度为3的字符串，然后收集到新的列表中 List\u0026lt;String\u0026gt; list2 = names.stream() .filter(s -\u0026gt; s.startsWith(\u0026#34;张\u0026#34;)) // 筛选以\u0026#34;张\u0026#34;开头的字符串 .filter(a -\u0026gt; a.length() == 3) // 筛选长度为3的字符串 .collect(Collectors.toList()); // 收集到新的列表中 // 打印新列表中的元素 System.out.println(list2); } } ArrayList, HashSet, Map的Stream流 public static void main(String[] args) { // 创建一个字符串列表 List\u0026lt;String\u0026gt; names = new ArrayList\u0026lt;\u0026gt;(); // 向列表中添加多个元素 Collections.addAll(names, \u0026#34;张三丰\u0026#34;, \u0026#34;张某人\u0026#34;, \u0026#34;张某某\u0026#34;, \u0026#34;张某\u0026#34;, \u0026#34;张某某人\u0026#34;); // 创建一个流，并对其中包含\u0026#34;某\u0026#34;的元素进行筛选并打印 Stream\u0026lt;String\u0026gt; stream1 = names.stream(); stream1.filter(s -\u0026gt; s.contains(\u0026#34;某\u0026#34;)).forEach(System.out::println); // 创建一个HashSet集合，并将多个元素添加到其中 Set\u0026lt;String\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); Collections.addAll(set, \u0026#34;张三丰\u0026#34;, \u0026#34;张某人\u0026#34;, \u0026#34;张某某\u0026#34;, \u0026#34;张某\u0026#34;, \u0026#34;张某某人\u0026#34;); // 创建一个流，并对其中包含\u0026#34;某\u0026#34;的元素进行筛选并打印 Stream\u0026lt;String\u0026gt; stream2 = set.stream(); stream2.filter(s -\u0026gt; s.contains(\u0026#34;某\u0026#34;)).forEach(System.out::println); // 创建一个HashMap对象，并向其中添加键值对 Map\u0026lt;String, Double\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;张某\u0026#34;, 165.3); map.put(\u0026#34;Kennem\u0026#34;, 181.2); map.put(\u0026#34;Karl\u0026#34;, 180.1); // 获取map中所有值的集合 Collection\u0026lt;Double\u0026gt; values = map.values(); // 创建一个流，并对其中包含\u0026#34;某\u0026#34;的键值对进行筛选并打印 Set\u0026lt;Map.Entry\u0026lt;String, Double\u0026gt;\u0026gt; entries = map.entrySet(); Stream\u0026lt;Map.Entry\u0026lt;String, Double\u0026gt;\u0026gt; stream3 = entries.stream(); stream3.filter(e -\u0026gt; e.getKey().contains(\u0026#34;某\u0026#34;)) .forEach(e -\u0026gt; System.out.println(e.getKey() + \u0026#34;--\u0026gt;\u0026#34; + e.getValue())); // 创建一个字符串数组，并将多个元素添加到其中 String[] names2 = {\u0026#34;张某人\u0026#34;, \u0026#34;东方不败\u0026#34;}; // 使用Arrays.stream方法创建一个流，并对其中的元素进行打印 Stream\u0026lt;String\u0026gt; stream4 = Arrays.stream(names2); stream4.forEach(System.out::println); // 使用Stream.of方法创建一个流，并对其中的元素进行打印 Stream\u0026lt;String\u0026gt; names21 = Stream.of(names2); names21.forEach(System.out::println); } 排序以及筛选 public static void main(String[] args) { // 创建一个Double类型的列表，存储考试成绩 List\u0026lt;Double\u0026gt; scores = new ArrayList\u0026lt;\u0026gt;(); Collections.addAll(scores, 88.5, 89.5, 90.0, 12.0, 1.0); // 使用流对考试成绩进行筛选，只打印及格的成绩 scores.stream().filter(s -\u0026gt; s \u0026gt;= 60) .forEach(System.out::println); System.out.println(\u0026#34;---------------\u0026#34;); // 创建一个Student对象的列表，存储学生信息 List\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;\u0026gt;(); // 创建多个Student对象，并添加到列表中 Student s1 = new Student(\u0026#34;至尊宝\u0026#34;, 21, 181.2); Student s2 = new Student(\u0026#34;蜘蛛精\u0026#34;, 21, 181.3); Student s3 = new Student(\u0026#34;牛魔王\u0026#34;, 20, 165.3); Student s4 = new Student(\u0026#34;蝎子精\u0026#34;, 20, 165.2); Student s5 = new Student(\u0026#34;蜘蛛精\u0026#34;, 22, 181.3); Collections.addAll(students, s1, s2, s3, s4, s5); // 使用流对学生信息进行筛选和排序，并打印结果 students.stream().filter(s -\u0026gt; s.getAge() \u0026gt;= 10 \u0026amp;\u0026amp; s.getAge() \u0026lt;= 30) .sorted((o1, o2) -\u0026gt; o2.getAge() - o1.getAge()) .forEach(System.out::println); System.out.println(\u0026#34;--------------\u0026#34;); // 使用流对学生信息按身高进行排序，并打印身高最高的前三名学生 students.stream().sorted(((o1, o2) -\u0026gt; Double.compare(o2.getHeight(), o1.getHeight()))) .limit(3) .forEach(System.out::println); System.out.println(\u0026#34;---------------\u0026#34;); // 使用流对学生信息按身高进行排序，并打印身高最低的两名学生 students.stream().sorted(((o1, o2) -\u0026gt; Double.compare(o2.getHeight(), o1.getHeight()))) .skip(students.size() - 2) .forEach(System.out::println); System.out.println(\u0026#34;-----------------\u0026#34;); // 使用流对学生信息进行筛选，找出身高大于168的学生，并打印他们的姓名（去重） students.stream() .filter(s -\u0026gt; s.getHeight() \u0026gt; 168) .map(Student::getName) .distinct() .forEach(System.out::println); // 使用Stream.concat方法将两个流合并，然后打印合并后的结果 Stream\u0026lt;Student\u0026gt; s11 = Stream.of(s1, s2); Stream\u0026lt;Student\u0026gt; s12 = Stream.of(s3, s4); Stream\u0026lt;Student\u0026gt; concat = Stream.concat(s11, s12); concat.forEach(System.out::println); } Stream终结方法 public static void main(String[] args) { // 创建学生列表 List\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;\u0026gt;(); // 创建学生对象并添加到列表中 Student s1 = new Student(\u0026#34;至尊宝\u0026#34;, 21, 181.2); Student s2 = new Student(\u0026#34;蜘蛛精\u0026#34;, 21, 181.3); Student s3 = new Student(\u0026#34;牛魔王\u0026#34;, 20, 165.3); Student s4 = new Student(\u0026#34;蝎子精\u0026#34;, 20, 165.2); Student s5 = new Student(\u0026#34;蜘蛛精\u0026#34;, 21, 181.3); Collections.addAll(students, s1, s2, s3, s4, s5); // 使用流过滤身高大于168的学生，并将结果收集到列表中 List\u0026lt;Student\u0026gt; res1 = students.stream() .filter(s -\u0026gt; s.getHeight() \u0026gt; 168) .collect(Collectors.toList()); System.out.println(res1); // 使用流过滤身高大于168的学生，并将结果收集到集合中 Set\u0026lt;Student\u0026gt; res2 = students.stream() .filter(s -\u0026gt; s.getHeight() \u0026gt; 168) .collect(Collectors.toSet()); System.out.println(res2); // 使用流过滤身高大于168的学生，去除重复的学生对象，并将姓名和身高映射到Map中 Map\u0026lt;String, Double\u0026gt; res3 = students.stream() .filter(s -\u0026gt; s.getHeight() \u0026gt; 168) .distinct() .collect(Collectors.toMap(a -\u0026gt; a.getName(), a -\u0026gt; a.getHeight())); System.out.println(res3); // 使用流过滤身高大于168的学生，去除重复的学生对象，并将结果转换为对象数组 Object[] res4 = students.stream() .filter(s -\u0026gt; s.getHeight() \u0026gt; 168) .distinct() .toArray(); System.out.println(Arrays.toString(res4)); // 使用流过滤身高大于168的学生，去除重复的学生对象，并将结果转换为指定长度的学生数组 Student[] res5 = students.stream() .filter(s -\u0026gt; s.getHeight() \u0026gt; 168) .distinct() .toArray(len -\u0026gt; new Student[len]); System.out.println(Arrays.toString(res5)); } 总结程序的知识点，并将知识点写到程序注释中去 ","permalink":"https://showguan.github.io/en/posts/tech/java20%E5%A4%A9%E9%80%9F%E6%88%90%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B2/","summary":"Java20天速成——进阶课程(2) 正则表达式 符号 含义 举例 [] 匹配方括号内的任一字符 [abc] ^ 匹配除指定字符外的任意字符 [^abc] \u0026amp;\u0026amp; 匹配两个字符集的交集，需","title":"Java20天速成——进阶课程(2)"},{"content":"LeetCode第 393 场周赛 第三题3116. 单面值组合的第 K 小金额 题目大意： 给定一个整数数组coins表示不同面额的硬币，另给定一个整数k。你有无限量的每种面额的硬币，但是，你不能组合使用不同面额的硬币。要求返回使用这些硬币能制造的第kth小金额。\n实现思路：\n首先，对于给定的硬币数组，我们需要求出它们的所有可能的组合方式。 使用位运算来枚举所有的组合方式，对于数组中的每个硬币，分别考虑选取和不选取两种情况，通过位运算将这两种情况枚举出来。 对于每种组合方式，计算其对应的最小公倍数（LCM）作为该组合的金额。 根据组合的奇偶性，将金额的正负号记录下来，并存储在列表ls中。 利用二分查找来求解第kth小的金额，通过不断调整左右边界，直到找到满足条件的金额。 返回最终找到的金额作为结果。 这种方法利用了位运算和二分查找的思想，可以在较短的时间内求解出结果。\nclass Solution: def findKthSmallest(self, coins: List[int], k: int) -\u0026gt; int: n = len(coins) ls = [] for i in range(1, 1\u0026lt;\u0026lt;n): Lcm = 1 for j, x in enumerate(coins): if i\u0026gt;\u0026gt;j \u0026amp; 1: Lcm = lcm(Lcm, x) ls.append((1, Lcm)) if i.bit_count()\u0026amp;1 else ls.append((-1, Lcm)) l, r = 1, int(5e10) while l\u0026lt;r: mid = l+r\u0026gt;\u0026gt;1 cnt = 0 for sign, val in ls: cnt += sign*(mid//val) if cnt\u0026gt;=k: r = mid else: l = mid+1 return l 第四题3117. 划分数组得到最小的值之和 题目大意： 给定两个数组nums和andValues，长度分别为n和m。数组的值等于该数组的最后一个元素。需要将nums划分为m个不相交的连续子数组，对于第ith个子数组[li, ri]，子数组元素的按位AND运算结果等于andValues[i]。返回将nums划分为m个子数组所能得到的可能的最小子数组值之和。如果无法完成这样的划分，则返回-1。\n实现思路：\n使用动态规划来解决此问题，具体来说，可以采用递归加记忆化搜索的方法。 定义dfs函数用于递归求解，其中i表示当前处理到nums的第i个元素，j表示当前处理到andValues的第j个元素，k表示当前子数组的按位AND运算结果。 在dfs函数中，首先进行边界条件的判断，如果i等于n，表示nums已经处理完毕，则返回0（如果j等于m）或者正无穷（如果j不等于m）。 然后，对当前nums[i]进行按位AND运算，并更新k的值。如果更新后的k小于andValues[j]，则返回正无穷。 如果更新后的k等于andValues[j]，则递归调用dfs函数继续处理下一个元素，同时更新i和j，并将k重置为-1。递归调用的结果加上nums[i]的值即为当前划分情况的子数组值之和。 最后，返回所有划分情况中的最小值作为答案，如果答案为正无穷，则返回-1。 这种方法利用了递归和记忆化搜索的思想，避免了重复计算，提高了效率。\nclass Solution: def minimumValueSum(self, nums: List[int], andValues: List[int]) -\u0026gt; int: n = len(nums) m = len(andValues) @cache def dfs(i, j, k): if i==n: return 0 if j==m else inf if j==m: return inf k\u0026amp;=nums[i] if k\u0026lt;andValues[j]: return inf res = dfs(i+1, j, k) if k==andValues[j]: res = min(res, dfs(i+1, j+1, -1)+nums[i]) return res ans = dfs(0, 0, -1) return ans if ans\u0026lt;inf else -1 ","permalink":"https://showguan.github.io/en/posts/tech/leetcode%E7%AC%AC-393-%E5%9C%BA%E5%91%A8%E8%B5%9B/","summary":"LeetCode第 393 场周赛 第三题3116. 单面值组合的第 K 小金额 题目大意： 给定一个整数数组coins表示不同面额的硬币，另给定一个整数k。你","title":"LeetCode周赛240414"},{"content":"进阶课程(1) OOP static 静态， 可以修饰成员变量，成员方法 成员变量按照有无static修饰，分为两种 类变量 ： 有static修饰，属于类，在计算机里只有一份，会被类的全部对象共享 实例变量（对象的变量）：无static修饰，属于每个对象 // 推荐赋值方式 Student.name = \u0026#34;Java\u0026#34;; // 不推荐赋值方式 Student s1 = new Student(); s1.name = \u0026#34;True Java\u0026#34;; Student s2 = new Student(); s2.name = \u0026#34;False Java\u0026#34;; System.out.println(s2.name); //False Java System.out.println(Student.name); //False Java s1.age = 25; s2.age = 15; System.out.println(s1.age); //25 System.out.println(s2.age); //15 //User类 public static int number; public User(){ number+=1; //类中访问自己的变量可以不写 User(). } //Test类 public static void main(String[] args) { User u1 = new User(); User u2 = new User(); User u3 = new User(); System.out.println(User.number); //3 } 类方法：有static修饰的成员方法，属于类。 实例方法：无static修饰的成员方法，属于对象 //Student double score; public static void printHelloWorld(){ System.out.println(\u0026#34;Hello World\u0026#34;); System.out.println(\u0026#34;Hello World\u0026#34;); } public void printPass(){ System.out.println(\u0026#34;成绩：\u0026#34; + (score \u0026gt;= 60 ? \u0026#34;及格\u0026#34; : \u0026#34;不及格\u0026#34;)); } //Test Student.printHelloWorld();//Hello World Hello World Student s = new Student(); s.score = 100; s.printPass(); //成绩：及格 类方法的常见应用案例 类方法最常见的应用场景是做工具类 工具类：工具类中的方法都是一些类方法，每个方法都是用来完成一个功能的，工具类是给开发人员共同使用的\n可以提高代码复用：调用方便，提高了开发效率\n使用类方法、实例方法时的几点注意事项\n类方法中可以直接访问类的成员，不可以直接访问实例成员 实例方法中既可以直接访问类成员，也可以直接访问实例成员 实例方法中可以出现this关键字，类方法中不可以出现this关键字 代码块 静态代码块 格式 ： static{ } 特点：类加载时自动执行，由于类只会加载一次，所以静态代码块只会执行一次 作用：完成类的初始化，例如：对类变量的初始化赋值 实例代码块： 格式：{ } 特点：每次创建对象时，执行实例代码块，并在构造器前执行 作用：和构造器一样，都是用来完成对象的初始化的，例如：对实例变量进行初始化赋值 单例设计模式 设计模式（Design pattern） 就是解决问题的最优解。\n单例设计模式：确保一个类只有一个对象\n饿汉式单例类\n把类的构造器私有 定义一个类变量记为类的一个对象 定义一个类方法，返回对象 public class A { private static A a = new A(); private A(){ } public static A getObject(){ return a; } } 继承 继承的好处：减少重复代码的编写\npublic class people { private String name; public String getName(){ return this.name; } public void setName(String name){ this.name = name; } } public class teacher extends people{ private String skill; public String getSkill() { return skill; } public void setSkill(String skill) { this.skill = skill; } public void printInfo(){ System.out.println(getName() + \u0026#34;具备的技能 ： \u0026#34; + skill); } } public class Test { public static void main(String[] args) { teacher t1 = new teacher(); t1.setName(\u0026#34;Kennem\u0026#34;); t1.setSkill(\u0026#34;Java\u0026#34;); System.out.println(t1.getName()); //Kennem System.out.println(t1.getSkill()); //Java t1.printInfo(); //Kennem具备的技能 ： Java } } 继承的注意事项：\n权限修饰符 单继承，Object类 方法重写 子类中访问其他成员的特点 子类构造器的特点 注意事项的小结 修饰符 本类中 同一个包下的其他类继承 任意包下的子类继承 任意包下的任何类继承 private ✓ 缺省 ✓ ✓ protected ✓ ✓ ✓ public ✓ ✓ ✓ ✓ 注意：用protected修饰，只能在子类中访问，而不是子类的对象访问\n单继承 java不支持多继承，支持多层继承\nObject类 Object类是任何类的父亲。\n方法重写 重写注意事项\n使用Override注解\n@Override public void print(){ System.out.println(\u0026#34;88888888\u0026#34;); } @Override public void print2(){ System.out.println(\u0026#34;8\u0026#34;); } 子类复写父类方法时，访问权限必须大于或者等于父类该方法的权限（publc -\u0026gt; protected -\u0026gt; 缺省）\n重写的方法返回值类型，必须与被重写方法的返回值类型一致，或者范围更小\n私有方法、静态方法不能被重写\n声明不变，重新实现\ntoString()方法重写\n@Override public String toString() { return \u0026#34;Student{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } 子列构造器的特点：\n子类的全部构造器，都会先调用父类的构造器，再执行自己的构造器。 子类构造器是符合实现调用父类构造器的： 默认情况下，子类全部构造器的第一行都是super()（默认都有），它会调用父类的无参数构造器。 如果父类没有无参数构造器，则我们必须再子类构造器的第一行手写super(...)， 指定去调用父类的有参数构造器。 class Student extends People{ private String skill; public Student(String name, int age, String skill){ super(name, age); //调用父类的有参构造器 父类中name和age构造器 this.skill = skill; } public String getSkill() { return skill; } public void setSkill(String skill) { this.skill = skill; } } 补充知识：this(...)调用兄弟构造器\n任意类的构造器中，是可以通过this(...)去调用该类的其他构造器的。 this(...) 和 super(...) 使用时的注意事项 this(...)、super(...)都只能放在构造器的第一行，因此，有了this(...)就不能写super(...)了，反之亦然 public Boy(String name, int age) { this(name, age, \u0026#34;黑马程序员\u0026#34;); } public Boy(String name, int age, String schoolName) { this.name = name; this.age = age; this.schoolName = schoolName; } 多态 多态是在继承/实现情况下的一种现象，表现为：对象多态，行为多态。\n在多态形式下，右边对象是解耦合的，更偏于扩展和维护。 public class People { public String name = \u0026#34;我是人\u0026#34;; public void run(){ System.out.println(\u0026#34;人可以跑\u0026#34;); } } public class Student extends People{ public String name = \u0026#34;我是学生\u0026#34;; @Override public void run() { System.out.println(\u0026#34;学生跑得很快！\u0026#34;); } public void test(){ System.out.println(\u0026#34;学生要考试...\u0026#34;); } } public class Teacher extends People{ public String name = \u0026#34;我是老师\u0026#34;; @Override public void run() { System.out.println(\u0026#34;老师跑的气喘吁吁！\u0026#34;); } } public class Test { public static void main(String[] args) { People p = new People(); System.out.println(p.name); People p1 = new Student(); System.out.println(p1.name); p1.run(); //编译看父类， 运行看子类 People p2 = new Teacher(); System.out.println(p2.name); p2.run(); } } if(p instanceof Student){ Student s = (Student) p; s.test(); }else if(p instanceof Teacher){ Teacher t = (Teacher) p; t.work(); } public class People { public String name = \u0026#34;我是人\u0026#34;; public void run(){ System.out.println(\u0026#34;人可以跑\u0026#34;); } } public class Student extends People { public String name = \u0026#34;我是学生\u0026#34;; @Override public void run() { System.out.println(\u0026#34;学生跑得很快！\u0026#34;); } public void test(){ System.out.println(\u0026#34;学生要考试\u0026#34;); } } public class Teacher extends People { public String name = \u0026#34;我是老师\u0026#34;; @Override public void run() { System.out.println(\u0026#34;老师跑的气喘吁吁！\u0026#34;); } public void work(){ System.out.println(\u0026#34;老师要上班\u0026#34;); } } final final关键字是最终的意思，可以修饰（类， 方法， 变量） 修饰类：该类被成为最终类，特点是不能被继承了 修饰方法：该方法被称为最终方法，特点是不能被重写了 修饰变量：该变量只能被赋值一次 public class Test { // 3.常量，建议名称全部大写，多个单词下划线连接 public static final String CURRENT_NAME = \u0026#34;Kennem\u0026#34;; public static void main(String[] args) { // final double pi = 3.14; //pi = 3.1; 报错，final修饰的变量不能修改 final int[] arr = {11, 22, 33}; arr[1] = 13; // 4.final修饰的地址不能变，但地址内的内容可以变 } } final class A{ // 1.final 修饰类，类不能被继承了 } // 2.final 修饰方法，方法不能被重写了 class C{ public final void test(){ } } class D extends C{ } 常量 使用了static final修饰的成员变量被称为常量\n作用：通常用于记录系统的配置信息\n使用常量记录系统配置信息的优势，执行原理\n代码可读性更好，可维护性也更好 程序编译后，常量会被\u0026quot;宏替换\u0026quot;；出现常量的地方全部会被替换成其记住的字面量，这样可以保证使用常量和直接用字面量的性能是一样的。 抽象类 public abstract class A { private String name; public static String schoolName; public abstract void run(); } public class B extends A{ @Override public void run() { System.out.println(\u0026#34;run\u0026#34;); } } 抽象类的好处：\n父类知道每个子类都要做某个行为，但每个子类要做的情况不一样，父类就定义成抽象方法，交给子类去重写实现，我们设计这样的抽象类，就是为了更好的支持多态。 抽象类可以制作模板类\n模板类 public abstract class People { public abstract String write(); public final void WriteOn(){ System.out.println(\u0026#34;\\t\\t今天是2023/04/14\u0026#34;); System.out.println(\u0026#34;\\t身份:\u0026#34;); System.out.println(write()); System.out.println(\u0026#34;以上就是我发表的内容\u0026#34;); System.out.println(\u0026#34;\\t\\t感谢大家！\u0026#34;); } } public class Teacher extends People { @Override public String write() { //只用重写每个类中需要不同实现的方法即可 return \u0026#34;我是老师，这里是老师类\u0026#34;; } } public class Student extends People { @Override public String write() { return \u0026#34;我是学生，这里是学生类\u0026#34;; } } public class Test { public static void main(String[] args) { Teacher t = new Teacher(); t.WriteOn(); Student s = new Student(); s.WriteOn(); } } 建议使用final关键字修饰模板类\n模板方法是给对象直接使用的不能被修改 一旦子类重写了模板方法，模板方法就失效了 接口 Java提供了一个关键字interface public class Test { public static void main(String[] args) { Driver d = new A(); d.drive(); } } class A extends Student implements Driver, Singer{ @Override public void drive() { } @Override public void sing() { } } class Student{ } interface Driver{ void drive(); } interface Singer{ void sing(); } 接口的好处：\n可以解决类单继承的问题，通过接口， 可以让一个类有一个继承父类的同时，还可以去找多个接口去拓展自己的功能 因为通过接口可以显性的知道你是谁 一个类可以实现多个接口，同样，一个接口也可以被多个类实现，这样的好处是我们的程序可以面向接口编程了，这样程序员就可以很方便的灵活切换各种业务实现了。 接口的综合案例:\n使用接口(StudentOperator)之后，在不同的继承接口的类(StudentOperatorImpl1, StudentOperatorImpl2)里面编写不同的程序，用接口对象实现操作时，仅需要改变不同的实现类即可。\n接口的其他方法 public class Student { private String name; private char sex; private int score; public Student() { } } public interface StudentOperator { void printInfo(ArrayList\u0026lt;Student\u0026gt; students); void printAverageScore(ArrayList\u0026lt;Student\u0026gt; students); } public class StudentOperatorImpl1 implements StudentOperator{ @Override public void printInfo(ArrayList\u0026lt;Student\u0026gt; students) { System.out.println(\u0026#34;==全班全部信息如下==\u0026#34;); for (int i = 0; i \u0026lt; students.size(); i++) { Student s = students.get(i); System.out.println(\u0026#34;姓名为 ： \u0026#34; + s.getName() + \u0026#34;, 性别为 ： \u0026#34; + s.getSex() + \u0026#34;, 得分为 ： \u0026#34; + s.getScore()); } System.out.println(\u0026#34;-------------------\u0026#34;); } @Override public void printAverageScore(ArrayList\u0026lt;Student\u0026gt; students) { double total = 0; for (int i = 0; i \u0026lt; students.size(); i++) { Student s = students.get(i); total += s.getScore(); } System.out.println(\u0026#34;班级平均分为 ： \u0026#34; + (total/(students.size()))); } } public class StudentOperatorImpl2 implements StudentOperator{ @Override public void printInfo(ArrayList\u0026lt;Student\u0026gt; students) { System.out.println(\u0026#34;==全班全部信息如下==\u0026#34;); int count1 = 0; for (int i = 0; i \u0026lt; students.size(); i++) { Student s = students.get(i); System.out.println(\u0026#34;姓名为 ： \u0026#34; + s.getName() + \u0026#34;, 性别为 ： \u0026#34; + s.getSex() + \u0026#34;, 得分为 ： \u0026#34; + s.getScore()); if(s.getSex()==\u0026#39;男\u0026#39;){ count1+=1; } } System.out.println(\u0026#34;男生人数为 ： \u0026#34; + count1 + \u0026#34;, 女生人数为 ： \u0026#34; + (students.size()-count1)); System.out.println(\u0026#34;班级总人数为 : \u0026#34; + (students.size())); System.out.println(\u0026#34;-------------------\u0026#34;); } @Override public void printAverageScore(ArrayList\u0026lt;Student\u0026gt; students) { double total = 0; double max = students.get(0).getScore(); double min = students.get(0).getScore(); for (int i = 0; i \u0026lt; students.size(); i++) { Student s = students.get(i); total += s.getScore(); if(s.getScore()\u0026gt;max){ max = s.getScore(); } else if(s.getScore()\u0026lt;min){ min = s.getScore(); } } System.out.println(\u0026#34;学生的最高分为 ： \u0026#34; + max + \u0026#34;, 学生的最低分为\u0026#34; + min); System.out.println(\u0026#34;去除最低分和最高分后，班级平均分为 ： \u0026#34; + (total/(students.size()))); } } public class ClassManagement { private ArrayList\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;\u0026gt;(); StudentOperator so = new StudentOperatorImpl2(); public ClassManagement() { students.add(new Student(\u0026#34;小明\u0026#34;, \u0026#39;男\u0026#39;, 99)); students.add(new Student(\u0026#34;小黄\u0026#34;, \u0026#39;女\u0026#39;, 100)); students.add(new Student(\u0026#34;小白\u0026#34;, \u0026#39;男\u0026#39;, 94)); students.add(new Student(\u0026#34;小亮\u0026#34;, \u0026#39;女\u0026#39;, 90)); } public void printInfo(){ so.printInfo(students); } public void printScore(){ so.printAverageScore(students); } } public class Test { public static void main(String[] args) { ClassManagement cm = new ClassManagement(); cm.printInfo(); cm.printScore(); } } 接口的其他方法：\n/** 1. 默认方法：必须使用default 修饰，默认会被public修饰 * */ default void test1(){ System.out.println(\u0026#34;===默认方法===\u0026#34;); test2(); } /** 2. 私有方法：必须使用private修饰，（JDK9开始支持） * 实例方法对象的方法 */ private void test2(){ System.out.println(\u0026#34;===私有方法===\u0026#34;); } /** * 3. 静态方法，必须使用static修饰，默认会被public修饰 */ public static void test3(){ System.out.println(\u0026#34;===静态方法===\u0026#34;); } 接口的多继承 一个接口可以同时继承多个接口\n一个接口继承多个接口，如果多个接口中存在方法名冲突，则此时不支持多继承\ninterface I{ void test1(); } interface J{ void test1(); } interface C implements I, J{ //报错 } 一个类实现多个接口，如果多个接口存在方法名冲突，则此时不支持多实现\ninterface I{ void test1(); } interface J{ void test1(); } class C implements I, J{ //报错 } 一个类继承了父类，又实现了接口，父类中和接口中有同名的默认方法，实现类会优先使用父类的\nclass Fu{ public void run(){ System.out.println(\u0026#34;===父类的run方法执行了\u0026#34;); } } interface IT{ default void run(){ System.out.println(\u0026#34;===接口IT中的run方法执行了\u0026#34;); } } class Zi extends Fu implements IT{ } public class Demo2 { public static void main(String[] args) { Zi zi = new Zi(); zi.run(); //===父类的run方法执行了 } } 一个类实现多个接口，多个接口中存在同名的默认方法，可以不冲突， 这个类重写该方法即可\ninterface I{ void test1(); } interface J{ void test1(); } //interface C implements I, J{ //报错 // //} class C implements I, J{ @Override public void test1() { } //重写后不会报错 } 内部类 成员内部类 public class Outer { private String outerName; private int age=88; public static int outerNumber; public class Inner{ private String name; public static int number; // JDK16才开始支持 private int age=99; public void test(){ } public void test2(){ System.out.println(outerName); System.out.println(outerNumber); int age = 66; System.out.println(age); System.out.println(this.age); System.out.println(Outer.this.age); } public Inner() { System.out.println(\u0026#34;Inner has been created.\u0026#34;); } public String getName() { return name; } public void setName(String name) { this.name = name; } public static int getNumber() { return number; } public static void setNumber(int number) { Inner.number = number; } } } public static void main(String[] args) { Outer.Inner in = new Outer().new Inner(); in.test2(); /** * Inner has been created. * null * 0 * 66 * 99 * 88 */ } 静态内部类 可以直接访问外部类的静态变量，而不能访问外部类的实例变量\npublic class StaticInner { private String name; // 实例变量，只能由外部对象来访问 public static int age; // 静态变量，可以由类名直接访问 // 静态内部类 public static class Inner { // 在静态内部类中访问外部类的静态变量是合法的 public void test() { System.out.println(age); // 无法在静态内部类中直接访问外部类的实例变量，会导致编译错误 //System.out.println(name); } } } 局部内部类：定义在方法，代码块，构造器中。\n匿名内部类 创建一个类的实例的一种方式，同时定义并实现该类。\npublic class Demo1 { public static void main(String[] args) { Animal cat = new Animal(){ //cat类可以不用单另新创建，实现的同时定义该类即可 @Override public void cry() { System.out.println(\u0026#34;猫喵喵喵的叫~~\u0026#34;); } }; cat.cry(); } } // 用抽象方法实现匿名内部类 abstract class Animal{ public abstract void cry(); } public class Demo2 { public static void main(String[] args) { go(new Swimming() { @Override public void swim() { System.out.println(\u0026#34;狗游的很快！\u0026#34;); } }); } public static void go(Swimming s){ System.out.println(\u0026#34;===GO====\u0026#34;); s.swim(); } } // 用接口实现匿名内部类 interface Swimming{ void swim(); } public class Demo3 { public static void main(String[] args) { JFrame win = new JFrame(\u0026#34;登录界面\u0026#34;); JPanel panel = new JPanel(); win.add(panel); JButton btn = new JButton(\u0026#34;登录\u0026#34;); panel.add(btn); //匿名内部类的实际使用场景 btn.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { JOptionPane.showConfirmDialog(win, \u0026#34;你点击了登录按钮\u0026#34;); } }); win.setSize(400, 800); win.setLocationRelativeTo(null); win.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); win.setVisible(true); } } 枚举 枚举是一种特殊的类\n枚举类的第一行，只能写一些合法的标识符（名称）， 多个名称用逗号隔开 这些名称，本质是常量，每个常量都会记住枚举类的一个对象 public enum A { X, Y, Z; private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } } public class Test { public static void main(String[] args) { A a1 = A.X; System.out.println(a1); //X A a2 = A.Y; A[] as = A.values(); System.out.println(as); //[Lcom.showguan.Enum.A;@3b07d329 A a3 = A.valueOf(\u0026#34;Z\u0026#34;); System.out.println(a3); //Z System.out.println(a3.ordinal()); //2 } } 枚举类的特点：\n枚举类的第一行只能罗列一些名称，这些名称都是常量，并且每个常量记住的都是枚举类的一个对象 枚举都是最终类，不可以被继承 枚举类中，从第二行开始，可以定义类的其他各种成员 编译器为枚举类新增了几个方法，并且枚举类都是继承 ：java.lang.Enum类的，从enum类也会继承到一些方法 枚举的实际作用：\npublic enum Constant2 { BOY, GIRL; } public static void check(Constant2 sex) { switch (sex) { case BOY: System.out.println(\u0026#34;你是个男孩！\u0026#34;); break; case GIRL: System.out.println(\u0026#34;你是个女孩！\u0026#34;); break; } } public static void main(String[] args) { check(Constant2.BOY); } 泛型 定义类，接口，方法时，同时声明一个或者多个类型变量（如\u0026lt;E\u0026gt;)，成为泛型类，泛型接口，泛型方法，它们统称为泛型。 public class Test { public static void main(String[] args) { ArrayList list = new ArrayList(); list.add(\u0026#34;Java1\u0026#34;); list.add(\u0026#34;Java2\u0026#34;); list.add(\u0026#34;Java3\u0026#34;); list.add(new Cat()); for (int i = 0; i \u0026lt; list.size(); i++) { // Object o = list.get(i); // String s = (String) list.get(i); //报错 Cat()对象时Object类型，不能转换成String类型 // System.out.println(s); } ArrayList\u0026lt;String\u0026gt; list2 = new ArrayList(); //泛型为String list2.add(\u0026#34;Java1\u0026#34;); list2.add(\u0026#34;Java2\u0026#34;); list2.add(\u0026#34;Java3\u0026#34;); // list2.add(new Cat()); //在编译阶段就限制添加对象的类型 ArrayList\u0026lt;Cat\u0026gt; list3 = new ArrayList(); //泛型为Cat() } } 拓展:\npublic class MyArrayList\u0026lt;E, T\u0026gt; //可以多个类型 public class MyArrayList\u0026lt;E, T extends Animal\u0026gt; //指定类型需要继承某个类 泛型接口 public interface Data\u0026lt;E\u0026gt;{ void get(E e); ArrayList\u0026lt;E\u0026gt; getName(String name); } public class TeacherData implements Data\u0026lt;Teacher\u0026gt;{ //指定泛型类型后，重写的方法都会自动换成该类型 @Override public void get(Teacher teacher) { } @Override public ArrayList\u0026lt;Teacher\u0026gt; getName(String name) { return null; } } 使用通配符 ?\npublic static void main(String[] args) { System.out.println(test(\u0026#34;Java\u0026#34;)); Dog d = test(new Dog()); ArrayList\u0026lt;Car\u0026gt; cars = new ArrayList\u0026lt;\u0026gt;(); cars.add(new Car()); cars.add(new Car()); cars.add(new Car()); go(cars); ArrayList\u0026lt;BMW\u0026gt; bmws = new ArrayList\u0026lt;\u0026gt;(); bmws.add(new BMW()); bmws.add(new BMW()); bmws.add(new BMW()); bmws.add(new BMW()); go(bmws); ArrayList\u0026lt;BENZ\u0026gt; benzs = new ArrayList\u0026lt;\u0026gt;(); benzs.add(new BENZ()); benzs.add(new BENZ()); benzs.add(new BENZ()); go(benzs); } public static \u0026lt;T\u0026gt; T test(T t){ return t; } public static void go(ArrayList\u0026lt;? extends Car\u0026gt; cars){ } } API toString()方法和equals() @Override public String toString() { return \u0026#34;Student{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return age == student.age \u0026amp;\u0026amp; Objects.equals(name, student.name); } clone() public static void main(String[] args) throws CloneNotSupportedException { Student s1 = new Student(\u0026#34;Kennem\u0026#34;, 21, new double[]{0.0}); System.out.println(s1.toString()); System.out.println(s1.getName()); System.out.println(s1.getAge()); System.out.println(s1); System.out.println(s1.getClass()); System.out.println(s1.getScores()); /** * Student{name=\u0026#39;Kennem\u0026#39;, age=21} * Kennem * 21 * Student{name=\u0026#39;Kennem\u0026#39;, age=21} * class com.showguan.APIObject.Student * [D@27d6c5e0 */ Student s2 = new Student(\u0026#34;Kennem\u0026#34;, 21, new double[]{0.0}); System.out.println(s1.equals(s2)); //true Student s3 = (Student) s1.clone(); System.out.println(s3.getName()); System.out.println(s3.getAge()); System.out.println(s3); System.out.println(s3.getClass()); System.out.println(s3.getScores()); /** * Kennem * 21 * Student{name=\u0026#39;Kennem\u0026#39;, age=21} * class com.showguan.APIObject.Student * [D@4f3f5b24 */ } @Override protected Object clone() throws CloneNotSupportedException { Student tmp = (Student) super.clone(); tmp.scores = tmp.scores.clone(); return tmp; } Objects.\npublic static void main(String[] args) { String s1 = \u0026#34;Java\u0026#34;; String s2 = null; System.out.println(s1.equals(s2)); // System.out.println(s2.equals(s1)); //空指针异常 System.out.println(Objects.equals(s1, s2)); System.out.println(Objects.isNull(s1)); //false System.out.println(Objects.nonNull(s1)); //true System.out.println(Objects.isNull(s2)); //true System.out.println(Objects.nonNull(s2)); //false } 包装类 public static void main(String[] args) { Integer a = Integer.valueOf(12); Integer b = 12; int c = b; ArrayList\u0026lt;Integer\u0026gt; arr = new ArrayList\u0026lt;\u0026gt;(); arr.add(12); arr.add(10); arr.get(1); Integer d = 25; String s1 = Integer.toString(d); System.out.println(s1); String s2 = d.toString(); String s3 = d + \u0026#34;\u0026#34;; System.out.println(s2); System.out.println(s3); String s4 = \u0026#34;29\u0026#34;; // int age = Integer.parseInt(s4); int age = Integer.valueOf(s4); System.out.println(age); String s5 = \u0026#34;99.9\u0026#34;; // double score = Double.parseDouble(s5); double score = Double.valueOf(s5); System.out.println(score+0.1); } StringBuilder 适合多次拼接，修改\npublic static void main(String[] args) { StringBuilder s = new StringBuilder(); s.append(\u0026#34;Java\u0026#34;); s.append(\u0026#34;666\u0026#34;).append(\u0026#34;888\u0026#34;).append(\u0026#34;999\u0026#34;); System.out.println(s); s.reverse(); System.out.println(s); System.out.println(s.length()); String ss = s.toString(); System.out.println(ss); /** * Java666888999 * 999888666avaJ * 13 * 999888666avaJ */ } StringBuffer方法和StringBuilder类似，但是是线程安全的，而StringBuilder是线程不安全的\nStringJoiner StringJoiner sj = new StringJoiner(\u0026#34;,\u0026#34;, \u0026#34;[\u0026#34;, \u0026#34;]\u0026#34;); sj.add(\u0026#34;1\u0026#34;); sj.add(\u0026#34;2\u0026#34;); sj.add(\u0026#34;3\u0026#34;); sj.add(\u0026#34;4\u0026#34;); System.out.println(sj); System public class Main { public static void main(String[] args) { // 主函数入口 // 以下代码块被注释掉，使用 System.exit(0) 可以立即终止程序的执行 // System.exit(0); // 打印分隔线 System.out.println(\u0026#34;----------------\u0026#34;); // 以下代码块被注释掉，用于打印当前时间的毫秒表示 // System.out.println(System.currentTimeMillis()); // 记录程序开始时间 long t1 = System.currentTimeMillis(); // 初始化一个空字符串 String s = \u0026#34;\u0026#34;; // 循环将字符串\u0026#34;abc\u0026#34;追加到字符串s中，重复200000次 for (int i = 0; i \u0026lt; 200000; i++) { s += \u0026#34;abc\u0026#34;; } // 记录程序结束时间 long t2 = System.currentTimeMillis(); // 计算程序执行时间并将结果以秒为单位打印出来 System.out.println((t2 - t1) / 1000.0 + \u0026#34;s\u0026#34;); //4.656s } } BigDecimal public class Main { public static void main(String[] args) { // 主函数入口 // 使用双精度浮点数进行运算 double a = 0.1; double b = 0.2; double c = a + b; // 直接相加 System.out.println(c); // 输出结果 // 使用 BigDecimal 类进行精确运算 BigDecimal a1 = BigDecimal.valueOf(a); // 将双精度浮点数转换为 BigDecimal 类型 BigDecimal b1 = BigDecimal.valueOf(b); // 使用 BigDecimal 的 multiply 方法进行乘法运算 BigDecimal c1 = a1.multiply(b1); System.out.println(c1); // 输出结果 // 使用 BigDecimal 的 add 方法进行加法运算 BigDecimal c2 = a1.add(b1); System.out.println(c2); // 输出结果 // 使用 BigDecimal 的 subtract 方法进行减法运算 BigDecimal c3 = a1.subtract(b1); System.out.println(c3); // 输出结果 // 使用 BigDecimal 的 divide 方法进行除法运算 BigDecimal c4 = a1.divide(b1); System.out.println(c4); // 输出结果 // 使用 BigDecimal 进行除法运算，并设置精确度和舍入模式 BigDecimal i = BigDecimal.valueOf(0.1); BigDecimal j = BigDecimal.valueOf(0.3); BigDecimal k = i.divide(j, 2, RoundingMode.HALF_UP); // 设置精确度为2位小数，采用四舍五入模式 System.out.println(k); // 输出结果，0.33 } } Date parse方法和format方法\nSimpleDateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy年MM月dd日 HH:mm:ss EEE a\u0026#34;); String rs = sdf.format(d); System.out.println(rs); String rs2 = sdf.format(time); System.out.println(rs2); // Date d2 = sdf2.parse(dat) String dateStr = \u0026#34;2022-12-12 12:12:11\u0026#34;; SimpleDateFormat sdf2 = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); Date d2 = sdf2.parse(dateStr); System.out.println(d2); public static void main(String[] args) throws ParseException { String start = \u0026#34;2024年12月12日 00:00:00\u0026#34;; String end = \u0026#34;2024年12月12日 00:10:00\u0026#34;; String xj = \u0026#34;2024年12月12日 00:01:18\u0026#34;; String xp = \u0026#34;2024年12月12日 00:10:57\u0026#34;; SimpleDateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy年MM月dd日 HH:mm:ss\u0026#34;); Date startDt = sdf.parse(start); Date endDt = sdf.parse(end); Date xjDt = sdf.parse(xj); Date xpDt = sdf.parse(xp); long startTime = startDt.getTime(); long endTime = endDt.getTime(); long xjTime = xjDt.getTime(); long xpTime = xpDt.getTime(); if(xjTime\u0026gt;=startTime \u0026amp;\u0026amp; xjTime\u0026lt;=endTime){ System.out.println(\u0026#34;小贾你秒杀成功了\u0026#34;); }else{ System.out.println(\u0026#34;小贾你秒杀失败了\u0026#34;); } if(xpTime\u0026gt;=startTime \u0026amp;\u0026amp; xpTime\u0026lt;=endTime){ System.out.println(\u0026#34;小皮你秒杀成功了\u0026#34;); }else{ System.out.println(\u0026#34;小皮你秒杀失败了\u0026#34;); } } Calendar public class Main { public static void main(String[] args) { // 获取当前日期和时间的 Calendar 对象 Calendar now = Calendar.getInstance(); System.out.println(\u0026#34;当前日期和时间：\u0026#34; + now); // 获取当前年份 int year = now.get(Calendar.YEAR); System.out.println(\u0026#34;当前年份：\u0026#34; + year); // 获取一年中的第几天 int days = now.get(Calendar.DAY_OF_YEAR); System.out.println(\u0026#34;一年中的第几天：\u0026#34; + days); // 获取Date对象 Date d = now.getTime(); System.out.println(\u0026#34;Date对象：\u0026#34; + d); // 获取时间戳 long time = now.getTimeInMillis(); System.out.println(\u0026#34;时间戳：\u0026#34; + time); // 设置月份为4月，日期为4月1日 now.set(Calendar.MONTH, Calendar.APRIL); now.set(Calendar.DAY_OF_MONTH, 1); System.out.println(\u0026#34;设置后的日期：\u0026#34; + now.getTime()); // 获取设置后的日期 Date d1 = now.getTime(); System.out.println(\u0026#34;设置后的Date对象：\u0026#34; + d1); // 增加105天 now.add(Calendar.DAY_OF_YEAR, 105); Date d2 = now.getTime(); System.out.println(\u0026#34;增加105天后的日期：\u0026#34; + d2); } } JDK之后新增的时间\n设计更合理，功能丰富，使用更方便 都是不可变对象，修改后会返回新的实践对象，不会丢失最开始的时间 线程安全 能精确到毫秒、纳秒 LocalDate， LocalTime, LocalDateTime LocalDate public static void main(String[] args) { // 获取当前日期 LocalDate ld = LocalDate.now(); System.out.println(ld); // 获取日期的年、月、日、年中的第几天、星期几等信息 int year = ld.getYear(); int month = ld.getMonthValue(); int day = ld.getDayOfMonth(); int dayOfYear = ld.getDayOfYear(); int dayOfWeek = ld.getDayOfWeek().getValue(); System.out.println(year); System.out.println(month); System.out.println(day); System.out.println(dayOfYear); System.out.println(dayOfWeek); // 使用 with 方法设置日期的年、月 LocalDate ld2 = ld.withYear(2077); LocalDate ld3 = ld.withMonth(11); System.out.println(ld2); System.out.println(ld3); // 使用 plus 方法增加日期的天数、月数 LocalDate ld4 = ld.plusDays(2); LocalDate ld5 = ld.plusMonths(3); // 使用 minus 方法减少日期的天数、月数 LocalDate ld6 = ld.minusDays(10); LocalDate ld7 = ld.minusMonths(2); // 使用 of 方法创建指定日期的 LocalDate 对象 LocalDate ld8 = LocalDate.of(2077, 12, 12); // 使用 equals、isAfter、isBefore 方法比较日期 System.out.println(ld5.equals(ld6)); System.out.println(ld5.isAfter(ld6)); System.out.println(ld5.isBefore(ld6)); } LocalTime public static void main(String[] args) { // 0、获取本地时间对象 java.time.LocalTime lt = java.time.LocalTime.now(); // 获取当前时间 System.out.println(lt); // 1、获取时间中的信息 int hour = lt.getHour(); // 获取小时 int minute = lt.getMinute(); // 获取分钟 int second = lt.getSecond(); // 获取秒 int nano = lt.getNano(); // 获取纳秒 // 2、修改时间：withHour、withMinute、withSecond、withNano java.time.LocalTime lt3 = lt.withHour(10); // 设置小时为10 java.time.LocalTime lt4 = lt.withMinute(10); // 设置分钟为10 java.time.LocalTime lt5 = lt.withSecond(10); // 设置秒为10 java.time.LocalTime lt6 = lt.withNano(10); // 设置纳秒为10 // 3、加多少：plusHours、plusMinutes、plusSeconds、plusNanos java.time.LocalTime lt7 = lt.plusHours(10); // 增加10小时 java.time.LocalTime lt8 = lt.plusMinutes(10); // 增加10分钟 java.time.LocalTime lt9 = lt.plusSeconds(10); // 增加10秒 java.time.LocalTime lt10 = lt.plusNanos(10); // 增加10纳秒 // 4、减多少：minusHours、minusMinutes、minusSeconds、minusNanos java.time.LocalTime lt11 = lt.minusHours(10); // 减少10小时 java.time.LocalTime lt12 = lt.minusMinutes(10); // 减少10分钟 java.time.LocalTime lt13 = lt.minusSeconds(10); // 减少10秒 java.time.LocalTime lt14 = lt.minusNanos(10); // 减少10纳秒 // 5、获取指定时间的LocalTime对象： // public static LocalTime of(int hour, int minute, int second) java.time.LocalTime lt15 = java.time.LocalTime.of(12, 12, 12); // 创建指定时间的LocalTime对象 java.time.LocalTime lt16 = java.time.LocalTime.of(12, 12, 12); // 创建指定时间的LocalTime对象 // 6、判断2个时间对象，是否相等，在前还是在后： equals isBefore isAfter System.out.println(lt15.equals(lt16)); // 判断两个时间是否相等 System.out.println(lt15.isAfter(lt)); // 判断lt15是否在lt之后 System.out.println(lt15.isBefore(lt)); // 判断lt15是否在lt之前 } LocalDateTime public static void main(String[] args) { // 获取当前日期和时间 LocalDateTime ldt = LocalDateTime.now(); System.out.println(\u0026#34;当前日期和时间：\u0026#34; + ldt); // 获取日期和时间中的信息 int year = ldt.getYear(); // 年份 int month = ldt.getMonthValue(); // 月份 int day = ldt.getDayOfMonth(); // 日 int hour = ldt.getHour(); // 小时 int minute = ldt.getMinute(); // 分钟 int second = ldt.getSecond(); // 秒 int nano = ldt.getNano(); // 纳秒 System.out.println(\u0026#34;年份：\u0026#34; + year); System.out.println(\u0026#34;月份：\u0026#34; + month); System.out.println(\u0026#34;日：\u0026#34; + day); System.out.println(\u0026#34;小时：\u0026#34; + hour); System.out.println(\u0026#34;分钟：\u0026#34; + minute); System.out.println(\u0026#34;秒：\u0026#34; + second); System.out.println(\u0026#34;纳秒：\u0026#34; + nano); // 设置日期和时间 LocalDateTime ldt2 = ldt.withYear(2025) .withMonth(6) .withDayOfMonth(15) .withHour(18) .withMinute(30) .withSecond(0) .withNano(0); System.out.println(\u0026#34;修改后的日期和时间：\u0026#34; + ldt2); // 增加和减少日期和时间 LocalDateTime ldt3 = ldt.plusDays(10) .plusHours(2) .minusMinutes(15); System.out.println(\u0026#34;增加和减少后的日期和时间：\u0026#34; + ldt3); // 创建指定日期和时间的 LocalDateTime 对象 LocalDateTime ldt4 = LocalDateTime.of(2030, 12, 31, 23, 59, 59); System.out.println(\u0026#34;指定日期和时间：\u0026#34; + ldt4); // 判断两个 LocalDateTime 对象的关系 System.out.println(\u0026#34;当前日期和时间是否在指定日期和时间之后：\u0026#34; + ldt.isAfter(ldt4)); System.out.println(\u0026#34;当前日期和时间是否在指定日期和时间之前：\u0026#34; + ldt.isBefore(ldt4)); } Arrays 对于自定义对象的排序：\n@Override public int compareTo(Student o) { // if(this.age \u0026gt; o.age){ //左边大，正整数 // return 1; // } // else if(this.age \u0026lt; o.age){ //右边大， 负整数 // return -1; // } // return 0; //相等 0 return o.age-this.age; } @Override public String toString() { return \u0026#34;Student{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, height=\u0026#34; + height + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } Student[] students = new Student[4]; students[0] = new Student(\u0026#34;Kenn\u0026#34;, 180, 21); students[1] = new Student(\u0026#34;ken\u0026#34;, 181, 22); students[2] = new Student(\u0026#34;ken\u0026#34;, 189, 22); students[3] = new Student(\u0026#34;k\u0026#34;, 168, 20); Arrays.sort(students); System.out.println(Arrays.toString(students)); Arrays.sort(students, new Comparator\u0026lt;Student\u0026gt;() { @Override public int compare(Student o1, Student o2) { return Integer.compare(o1.getAge(), o2.getAge()); } }); Lambda表达式 Lambda表达式只能简化函数式接口的匿名内部类！\n函数式接口：\n有且仅有一个抽象方法的接口 注意：将来见到的大部分函数式接口，上面都可能会有一个@FunctionalInterface的注解，有该注解的接口必定是函数式接口 // Arrays.sort(students, new Comparator\u0026lt;Student\u0026gt;() { // @Override // public int compare(Student o1, Student o2) { // return Integer.compare(o1.getAge(), o2.getAge()); // } // }); // Arrays.sort(students, (Student o1, Student o2) -\u0026gt;{ // return Double.compare(o1.getHeight(), o2.getHeight()); // }); Arrays.sort(students, ( o1, o2) -\u0026gt;{ return Double.compare(o1.getHeight(), o2.getHeight()); }); Arrays.sort(students, ( o1, o2) -\u0026gt; Double.compare(o1.getHeight(), o2.getHeight())); // Arrays.setAll(prices, new IntToDoubleFunction() { // @Override // public double applyAsDouble(int value) { // return prices[value]*0.8; // } // }); // Arrays.setAll(prices, (int value) -\u0026gt; { // return prices[value]*0.8; // }); // Arrays.setAll(prices, value -\u0026gt; { // return prices[value]*0.8; // }); Arrays.setAll(prices, value -\u0026gt; prices[value]*0.8); 方法引用 静态方法的引用 //CompareByAge.java public class CompareByAge { public static int comparByAge(Student o1, Student o2){ return o1.getAge() - o2.getAge(); } } //Test.java // Arrays.sort(students, (o1, o2) -\u0026gt; CompareByAge.comparByAge(o1, o2)); Arrays.sort(students, CompareByAge::comparByAge); //与上面的作用相同 实例方法引用 public class CompareByHeight { public int comparebyHeight(Student o1, Student o2){ return (int) (o2.getHeight() - o1.getHeight()); } } CompareByHeight cmpH = new CompareByHeight(); // Arrays.sort(students, (o1, o2) -\u0026gt; cmpH.comparebyHeight(o1, o2)); Arrays.sort(students, cmpH::comparebyHeight); 特定类型的方法引用 // Arrays.sort(names, (o1, o2) -\u0026gt; o1.compareToIgnoreCase(o2)); Arrays.sort(names, String::compareToIgnoreCase); 构造器引用 // CreateCar cc = new CreateCar() { // @Override // public Car create(String name, double price) { // return new Car(name, price); // } // }; // CreateCar cc = (name, price) -\u0026gt; new Car(name, price); CreateCar cc = Car::new; 综合案例 Hospital ","permalink":"https://showguan.github.io/en/posts/tech/java20%E5%A4%A9%E9%80%9F%E6%88%90%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B1/","summary":"进阶课程(1) OOP static 静态， 可以修饰成员变量，成员方法 成员变量按照有无static修饰，分为两种 类变量 ： 有static修饰，属于类，在计算机里只","title":"Java20天速成——进阶课程"},{"content":"JAVA 20天速成 有志者事竟成\n没有完完全全的投入，检测，学习是学不到东西的。\n自欺欺人，眼高手低是绝对没有任何作用的。\nJAVA背景信息 JAVA是一门高级编程语言。\n属于ORACLE公司\nJAVA之父——詹姆斯·高斯林\nJAVA主要做互联网系统的开发\n主要技术平台：JAVASE， JAVEEE， JAVAME\nJDK的发展史 Java Development Kit 开发者工具包\n当前使用更多的是JDK-8，JDK-11\n教学只用JDK-17\n技术类网站 ： 安装路径下不要包含中文和空格\n所有的开发工具最好安装到统一目录\n电脑内JAVA安装路径：\nF:\\Java\\jdk17 C:\\Program Files\\Java\\jdk1.8.0_311\njavac.exe : 编译工具 java.exe : 执行工具\n常用命令\ncls： 清屏 退回到盘符根目录 ： cd\\ 先切换盘符在切换目录 Java 程序要经历的步骤：\n编写、编译（javac), 运行(java) Java代码编写有什么基本要求？\n文件名称和后缀必须是java结尾 文件名称必须与代码的类名称一致 必须使用英文模式下的符号 javac .\\HelloWorld.java\rjava HelloWorld public class Main{ public static void main(String[] args){ System.out.println(\u0026#34;Hello World!\u0026#34;); } } JDK11开始支持java直接运行源代码文件\nJDK 组成 JRE（Java Runtime Environment）：Java的运行环境\nJVM（Java Vitual Machine）：Java虚拟机， 真正运行java程序的地方。\n核心类库：Java自己写好的程序，给程序员调用的\n开发工具：java, javac\nJDK（Java Development Kit）：Java开发工具包（包括上面所有）。\nJava的跨平台、工作原理\n一次编译，处处可用 Path环境变量：用于记住程序路径，方便在命令行窗口的任意目录启动程序\nIDEA管理JAVA程序的结构\nproject（项目，工程） module（模块） package（包） class（类） IDEA快捷键\nmain/psvm sout\nctrl + D 复制当前行到下一行\nctrl + Y 删除所在行，建议用ctrl + x\nctrl + alt + L 格式化代码\nALT + SHIFT + ⬆ | ⬇ 上下移动当前代码\nctrl + /, ctrl + shift + / 对代码进行注释\nIDEA常用操作：\n删除类文件 修改类名称 修改模块 导入模块 方法1：\n方法2：\n复制代码到， 之后再导入\n删除模块 打开工程 关闭工程 JAVA基础语法 1、注释 // 单行注释 /* 多行注释 */ /** 文档注释 * 目标： */ 2、变量 变量就是内存中的一块区域。\n// 二进制表示，前缀 0b 表示二进制 int a1 = 0b01100001; System.out.println(a1); // 输出：97 // 十进制表示 int a2 = 97; System.out.println(a2); // 输出：97 // 八进制表示，前缀 0 表示八进制 int a3 = 0141; System.out.println(a3); // 输出：97 // 十六进制表示，前缀 0x 表示十六进制 int a4 = 0xFA; System.out.println(a4); // 输出：250 // 声明并初始化不同类型的变量 byte a = 10; // byte类型，表示范围为 -128 到 127 short b = 8888; // short类型，表示范围为 -32768 到 32767 int c = 130; // int类型，表示范围为 -2147483648 到 2147483647 long d = 9393939393993L; // long类型，需要在结尾加上L或l，表示范围为 -9223372036854775808 到 9223372036854775807 // 输出不同类型的整数变量 System.out.println(a); // 输出：10 System.out.println(b); // 输出：130 System.out.println(c); // 输出：9393939393993 System.out.println(d); // 输出：8888 // 浮点数类型 float e = 2.17F; // float类型，需要在结尾加上F或f double f = 3.141592657; // double类型，默认为double，可以不加任何标识 // 输出浮点数变量 System.out.println(e); // 输出：2.17 System.out.println(f); // 输出：3.141592657 // 字符类型 char ch = \u0026#39;c\u0026#39;; // char类型，表示单个字符 System.out.println(ch); // 输出：c // 布尔类型 boolean flag = false; // boolean类型，表示true或false System.out.println(flag); // 输出：false // 字符串类型 String st = \u0026#34;string\u0026#34;; // String类型，表示字符串 System.out.println(st); // 输出：string 类型转换 byte a = 10; // 声明并初始化byte类型变量a int b = a; // 将byte类型的变量a赋值给int类型的变量b，发生拓宽转换 System.out.println(b); // 输出：10 int c = 100; // 声明并初始化int类型变量c double d = c; // 将int类型的变量c赋值给double类型的变量d，发生拓宽转换 System.out.println(d); // 输出：100.0 char e = \u0026#39;b\u0026#39;; // 声明并初始化char类型变量e int f = e; // 将char类型的变量e赋值给int类型的变量f，发生拓宽转换 System.out.println(f); // 输出：98（字符\u0026#39;b\u0026#39;对应的ASCII码值） byte a = 10; // 声明并初始化byte类型变量a short b = 20; // 声明并初始化short类型变量b int c = 30; // 声明并初始化int类型变量c long d = 40; // 声明并初始化long类型变量d // 对a、b、c、d进行加法运算，结果存储在long类型变量res1中 long res1 = a + b + c + d; System.out.println(res1); // 输出：100 // 对a、b进行加法运算，并将1.0（double类型）相加，结果存储在double类型变量res2中 double res2 = a + b + 1.0; System.out.println(res2); // 输出：31.0 // 对a、b进行加法运算，结果存储在int类型变量res3中 int res3 = a + b; System.out.println(res3); // 输出：30 byte a1 = 10; // 声明并初始化byte类型变量a1 byte a2 = 20; // 声明并初始化byte类型变量a2 // 对a1、a2进行加法运算，由于byte类型相加可能溢出，因此结果存储在int类型变量res4中 int res4 = a1 + a2; // 进行运算时a1和a2自动转换成int类型，然后相加 System.out.println(res4); // 输出：30 强制类型转换 int a = 1111111; char b = (char) a; // 快捷键， ALT+ENTER System.out.println(b); double c = 99.8; int d = (int) c; // 丢掉小数部分 System.out.println(d); 3、运算符 使用+符号做连接符的情况 int a = 10; // 声明并初始化整数变量a // 使用字符串连接符将字符串 \u0026#34;abc\u0026#34; 和整数变量a 连接起来并打印 System.out.println(\u0026#34;abc\u0026#34; + a); // 输出：\u0026#34;abc10\u0026#34; // 打印整数变量a 加 5 的结果 System.out.println(a + 5); // 输出：15 // 将字符串 \u0026#34;abc\u0026#34;、整数变量a 和字符 \u0026#39;a\u0026#39; 连接起来并打印 // 注：\u0026#39;a\u0026#39; 的ASCII码值为97，与整数变量a相加后再转换为字符 System.out.println(\u0026#34;abc\u0026#34; + a + \u0026#39;a\u0026#39;); // 输出：\u0026#34;abc10a\u0026#34; // 将字符 \u0026#39;a\u0026#39; 的ASCII码值（97）和整数变量a 相加，再将结果与字符串 \u0026#34;abc\u0026#34; 连接起来并打印 // 注：字符 \u0026#39;a\u0026#39; 的ASCII码值被当作整数参与运算，然后再将结果转换为字符 System.out.println(\u0026#39;a\u0026#39; + a + \u0026#34;abc\u0026#34;); // 输出：\u0026#34;107abc\u0026#34; // 初始化变量n和m分别为3和5 int n = 3, m = 5; // 计算res的值 // ++m: 先自增m，m变成6，然后返回6 // --m: 先自减m，m变成5，然后返回5 // m--: 先返回m的值5，然后再自减m，m变成4 // ++n: 先自增n，n变成4，然后返回4 // n--: 先返回n的值4，然后再自减n，n变成3 // 计算：6 - 5 + 5 - 4 + 4 + 3 = 9 int res = ++m - --m + m-- - ++n + n-- + 3; System.out.println(res); // 输出res的值 System.out.println(n); // 输出n的值，此时n为3 System.out.println(m); // 输出m的值，此时m为4 // 初始化变量c和d分别为10和5 int c = 10, d = 5; // 计算res2的值 // c++: 先返回c的值10，然后再自增c，c变成11 // ++c: 先自增c，c变成12，然后返回12 // --d: 先自减d，d变成4，然后返回4 // ++d: 先自增d，d变成5，然后返回5 // 计算：10 + 12 - 4 - 5 + 1 + c--，其中c此时为12，然后再自减c，c变成11 // 计算：10 + 12 - 4 - 5 + 1 + 12 = 26 int res2 = c++ + ++c - --d - ++d + 1 + c--; System.out.println(res2); // 输出res2的值 System.out.println(c); // 输出c的值，此时c为11 System.out.println(d); // 输出d的值，此时d为5 逻辑运算 // 定义变量 double size = 9.8; // size的值为9.8 double storage = 16; // storage的值为16 // 第一组条件判断 System.out.println(\u0026#34;original \u0026#34; + storage); // 使用按位与运算符\u0026#34;\u0026amp;\u0026#34;，即使第一个条件不满足，storage也会自增 boolean res11 = size \u0026lt; 8 \u0026amp; storage++ \u0026gt;= 16; // false System.out.println(res11); // 输出false System.out.println(storage); // 输出17.0，因为storage在条件判断之后自增了 // 使用逻辑与运算符\u0026#34;\u0026amp;\u0026amp;\u0026#34;，若第一个条件不满足，则不会执行第二个条件，storage不会自增 boolean res12 = size \u0026lt; 8 \u0026amp;\u0026amp; storage++ \u0026gt;= 16; // false System.out.println(res12); // 输出false System.out.println(storage); // 输出17.0，因为storage没有自增 // 第二组条件判断 System.out.println(\u0026#34;-------------------\u0026#34;); System.out.println(\u0026#34;original \u0026#34; + storage); // 使用按位或运算符\u0026#34;|\u0026#34;，即使第一个条件满足，storage也会自增 boolean res21 = size \u0026gt;= 8 | storage++ \u0026gt;= 8; // true System.out.println(res21); // 输出true System.out.println(storage); // 输出18.0，因为storage在条件判断之后自增了 // 使用逻辑或运算符\u0026#34;||\u0026#34;，若第一个条件满足，则不会执行第二个条件，storage不会自增 boolean res22 = size \u0026gt;= 8 || storage++ \u0026gt;= 16; // true System.out.println(res22); // 输出true System.out.println(storage); // 输出18.0，因为storage没有自增 System.out.println(\u0026#34;-------------------\u0026#34;); // 其他操作 // 使用逻辑非运算符\u0026#34;!\u0026#34;，对true取反，结果为false System.out.println((!true)); // 输出false // 使用按位异或运算符\u0026#34;^\u0026#34;，对两个数的二进制进行异或操作，结果为0 System.out.println((1^1)); // 输出0 int grade = 10; // 定义成绩变量为10 // 使用三元运算符判断成绩是否合格 String res = grade \u0026gt;= 60 ? \u0026#34;成绩合格\u0026#34; : \u0026#34;成绩不合格\u0026#34;; System.out.println(res); // 输出 \u0026#34;成绩不合格\u0026#34;，因为grade的值为10，小于60 // 第一条逻辑表达式 System.out.println(10 \u0026gt; 3 || 10 \u0026gt; 3 \u0026amp;\u0026amp; 10 \u0026lt; 3); // 输出true // 逻辑运算符\u0026#34;\u0026amp;\u0026amp;\u0026#34;的优先级高于\u0026#34;||\u0026#34;，所以先执行10 \u0026gt; 3 \u0026amp;\u0026amp; 10 \u0026lt; 3，结果为false，然后执行10 \u0026gt; 3 || false，结果为true。 // 第二条逻辑表达式 System.out.println((10 \u0026gt; 3 || 10 \u0026gt; 3) \u0026amp;\u0026amp; 10 \u0026lt; 3); // 输出false // 加了括号后，先执行括号内的10 \u0026gt; 3 || 10 \u0026gt; 3，结果为true，然后与10 \u0026lt; 3进行逻辑与运算，结果为false。 输入 // 1. 创建Scanner对象sc，用于从System.in（即标准输入流，通常为控制台）读取用户输入 Scanner sc = new Scanner(System.in); // 2. 输出提示信息，要求用户输入年龄 System.out.println(\u0026#34;Please input your age:\u0026#34;); // 3. 使用Scanner对象sc读取用户输入的整数型年龄，并将其存储在变量age中 int age = sc.nextInt(); // 4. 根据用户输入的年龄计算其出生年份（假设当前为2024年），然后输出结果 System.out.println(\u0026#34;Your birth year is :\u0026#34; + (2024 - age)); // 5. 输出提示信息，要求用户输入姓名 System.out.println(\u0026#34;Please input your name:\u0026#34;); // 6. 使用Scanner对象sc读取用户输入的字符串型姓名，并将其存储在变量name中 String name = sc.next(); // 7. 重复输出用户出生年份（与步骤4相同，此处可能是代码冗余或笔误） System.out.println(\u0026#34;Your birth year is :\u0026#34; + (2024 - age)); // 8. 输出欢迎信息，包含用户输入的姓名 System.out.println(\u0026#34;Welcome: \u0026#34; + name); switch注意事项：\n表达式类型只能是byte， short, int, char, JDK5开始支持枚举， JDK7开始支持String，不支持double，float, long。 case给出的值不允许重复，且只能是字面量，不能是变量 正常使用时需要写break， 否则会出现穿透现象 switch 技巧：运用穿透性合并同样结果的分支。\n// 创建一个Random对象用于生成随机数 Random random = new Random(); // 生成1到100之间的随机数作为幸运数字 int luckNumber = random.nextInt(100) + 1; // 创建一个Scanner对象用于接收用户的输入 Scanner sc = new Scanner(System.in); // 提示用户输入猜测的数字 System.out.println(\u0026#34;请输入你猜的数字\u0026#34;); // 循环，直到用户猜中为止 while (true) { // 获取用户输入的猜测数字 int guessNumber = sc.nextInt(); // 判断用户输入的数字与幸运数字的关系，并给出相应提示 if (guessNumber == luckNumber) { // 如果猜中了，输出恭喜信息，并结束循环 System.out.println(\u0026#34;恭喜你，你中了100元大奖\u0026#34;); break; } else if (guessNumber \u0026gt; luckNumber) { // 如果猜的数字太大，提示用户数字太大 System.out.println(\u0026#34;你猜的数字太大了\u0026#34;); } else { // 如果猜的数字太小，提示用户数字太小 System.out.println(\u0026#34;你猜的数字太小了\u0026#34;); } } 数组 //1.标准写法 // 初始化整型数组ages，包含5个元素，分别为10, 20, 30, 40, 50 int[] ages = new int[]{ 10, 20, 30, 40, 50 }; // 初始化双精度浮点型数组scores，包含5个元素，分别为99.9, 88.8, 77.7, 66.6, 55.5 double[] scores = new double[]{ 99.9, 88.8, 77.7, 66.6, 55.5 }; // 输出整型数组ages的引用地址 System.out.println(ages); // 输出双精度浮点型数组scores的引用地址 //2.简化写法 // 使用简化语法初始化整型数组ages2，包含5个元素，分别为10, 20, 30, 40, 50 int[] ages2 = { 10, 20, 30, 40, 50 }; // 使用简化语法初始化双精度浮点型数组scores2，包含5个元素，分别为99.9, 88.8, 77.7, 66.6, 55.5 //3.写法三 // 使用写法三初始化整型数组age3，包含5个元素，分别为10, 20, 30, 40, 50 int age3[] = new int[10]; // 使用写法三初始化双精度浮点型数组score3，包含5个元素，分别为99.9, 88.8, 77.7, 66.6, 55.5 Java 内存分配 方法区\n栈\n堆\n本地方法栈\n程序计数器\nint a = 20; int[] arr = new int[3]; 以上两行代码的执行原理：\na是变量，直接放在栈中，a变量中存储的数据就是20这个值 new int[3]是创建一个数组对象，会在堆内存中开辟区存储3个整数 arr是变量，在栈中，arr中存储的是数组对象在堆内存中地址值 Java小案例——双色球 package com.show.test; import java.util.Random; import java.util.Scanner; public class Test4 { public static void main(String[] args) { System.out.println(1); int[] userNumber = userChooseNumber(); // 用户选择号码 int[] luckNumer = createLuckNumber(); // 创建幸运号码 check(userNumber, luckNumer); // 检查用户选择的号码与幸运号码的匹配情况 } // 用户选择号码的方法 public static int[] userChooseNumber() { System.out.println(\u0026#34;Welcome to this select ball system!\u0026#34;); // 欢迎语 int[] numbers = new int[6]; // 存储用户选择的号码数组 Scanner sc = new Scanner(System.in); for (int i = 0; i \u0026lt; 5; i++) { System.out.println(\u0026#34;Please input your No.\u0026#34; + (i + 1) + \u0026#34; ball\u0026#34;); // 提示用户输入号码 while (true) { int n = sc.nextInt(); // 接收用户输入的号码 if (n \u0026lt; 1 || n \u0026gt; 33) { // 判断号码是否在有效范围内 System.out.println(\u0026#34;Your number not in the available zone: [1,33], Please input again\u0026#34;); } else { if (exist(numbers, n)) { // 判断号码是否已经被选择 System.out.println(\u0026#34;Current number has been chosen, Please input again\u0026#34;); } else { numbers[i] = n; // 将号码存入数组 break; } } } System.out.println(\u0026#34;Your input number is :\u0026#34; + numbers[i]); // 输出用户输入的号码 } System.out.println(\u0026#34;Input your last number\u0026#34;); while (true) { int n = sc.nextInt(); if (n \u0026lt; 1 || n \u0026gt; 16) { System.out.println(\u0026#34;Your number is not available, Please input the number between 1 and 16\u0026#34;); } else { numbers[5] = n; // 存储最后一个号码 break; } } System.out.println(\u0026#34;Blow is your input numbers\u0026#34;); printArray(numbers); // 打印用户选择的号码 return numbers; } // 判断数字是否已存在于数组中的方法 public static boolean exist(int[] arr, int x) { for (int i = 0; i \u0026lt; arr.length; i++) { if (arr[i] == x) { return true; } } return false; } // 打印数组的方法 public static void printArray(int[] arr) { for (int i = 0; i \u0026lt; arr.length; i++) { System.out.print(arr[i] + \u0026#34; \u0026#34;); } System.out.println(); } // 创建幸运号码的方法 public static int[] createLuckNumber() { int[] numbers = new int[6]; // 存储幸运号码数组 Random r = new Random(); for (int i = 0; i \u0026lt; 5; i++) { while (true) { int n = r.nextInt(33) + 1; // 生成随机号码 if (exist(numbers, n)) { continue; } else { numbers[i] = n; // 将号码存入数组 break; } } } int n = r.nextInt(16) + 1; numbers[5] = n; // 存储最后一个号码（蓝球） System.out.println(\u0026#34;Blow is the LuckNumber!\u0026#34;); // 输出幸运号码 printArray(numbers); // 打印幸运号码 return numbers; } // 检查用户选择的号码与幸运号码的匹配情况 public static void check(int[] arr1, int[] arr2) { int redCount = 0, blueCount = 0; // 红球匹配数、蓝球匹配数初始化为0 for (int i = 0; i \u0026lt; arr1.length - 1; i++) { if (arr1[i] == arr2[i]) { // 判断红球是否匹配 redCount += 1; } } if (arr1[5] == arr2[5]) { // 判断蓝球是否匹配 blueCount += 1; } // 输出命中的红球数量和蓝球数量 System.out.println(\u0026#34;您命中的红球数量是：\u0026#34; + redCount); System.out.println(\u0026#34;您命中的蓝球数量是：\u0026#34; + blueCount); // 根据命中情况输出不同的中奖信息 if (redCount == 6 \u0026amp;\u0026amp; blueCount == 1) { System.out.println(\u0026#34;恭喜您，中奖1000万，可以开始享受人生了~~~\u0026#34;); } else if (redCount == 6 \u0026amp;\u0026amp; blueCount == 0) { System.out.println(\u0026#34;恭喜您，中奖500万，可以稍微开始享受人生了~~~\u0026#34;); } else if (redCount == 5 \u0026amp;\u0026amp; blueCount == 1) { System.out.println(\u0026#34;恭喜您，中奖3000元，可以出去吃顿小龙虾了~\u0026#34;); } else if (redCount == 5 \u0026amp;\u0026amp; blueCount == 0 || redCount == 4 \u0026amp;\u0026amp; blueCount == 1) { System.out.println(\u0026#34;恭喜您，中了小奖：200元~\u0026#34;); } else if (redCount == 4 \u0026amp;\u0026amp; blueCount == 0 || redCount == 3 \u0026amp;\u0026amp; blueCount == 1) { System.out.println(\u0026#34;中了10元~\u0026#34;); } else if (redCount \u0026lt; 3 \u0026amp;\u0026amp; blueCount == 1) { System.out.println(\u0026#34;中了5元~\u0026#34;); } else { System.out.println(\u0026#34;感谢您对福利事业做出的巨大贡献~~~\u0026#34;); } } } 面向对象 对象就是一张表。\nthis的执行原理 this：就是一个变量，可以用在方法中，来拿到当前对象。\nthis主要用来\npublic class PrintThis { public void printThis(){ System.out.println(this); } } public class Test1 { public static void main(String[] args) { PrintThis t = new PrintThis(); t.printThis();//com.show.thisDemo.PrintThis@3b07d329 System.out.println(t); //com.show.thisDemo.PrintThis@3b07d329 } } public class Student1 { int score; public void check(int score){ if(this.score\u0026gt;score){ System.out.println(\u0026#34;Congratulations!\u0026#34;); }else{ System.out.println(\u0026#34;What\u0026#39;s the pity!\u0026#34;); } } } public static void main(String[] args) { Student1 s1 = new Student1(); s1.score = 10; s1.check(100); } 构造器需要注意的问题 不写无参数构造器时，编译器会自动生成一个无参数构造器 而写了有参数构造器之后，就不会自动生成无参数构造器了， 需要手动写上。 封装 就是用类设计对象处理某一个事物的数据时，应该把要处理的数据，以及处理这些数据的方法，设计到一个对象中去 合理隐藏，合理暴露（get, set方法）\n实例JavaBean 实体类：一种特殊的类\nMovie package com.show.ObjectDemo; public class Movie { // 私有属性 private int id; // 电影ID private String name; // 电影名称 private double price; // 电影票价 private double score; // 电影评分 private String director; // 导演 private String actor; // 主演 private String info; // 电影信息 // 无参构造方法 public Movie() { } // 带参构造方法 public Movie(int id, String name, double price, double score, String director, String actor, String info) { this.id = id; this.name = name; this.price = price; this.score = score; this.director = director; this.actor = actor; this.info = info; } // Getter和Setter方法 public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public double getPrice() { return price; } public void setPrice(double price) { this.price = price; } public double getScore() { return score; } public void setScore(double score) { this.score = score; } public String getDirector() { return director; } public void setDirector(String director) { this.director = director; } public String getActor() { return actor; } public void setActor(String actor) { this.actor = actor; } public String getInfo() { return info; } public void setInfo(String info) { this.info = info; } } MovieOperator package com.show.ObjectDemo; public class MovieOperator { // 电影数组 private Movie[] movies; // 构造方法 public MovieOperator(Movie[] movies) { this.movies = movies; } // 打印所有电影信息 public void printAllMovies() { System.out.println(\u0026#34;系统全部电影信息如下————————————————————————————\u0026#34;); for (int i = 0; i \u0026lt; movies.length; i++) { Movie m = movies[i]; System.out.println(\u0026#34;编号：—————————————\u0026#34; + m.getId()); System.out.println(\u0026#34;电影名：—————————————\u0026#34; + m.getName()); System.out.println(\u0026#34;价格：—————————————\u0026#34; + m.getPrice()); System.out.println(\u0026#34;-----------------------\u0026#34;); } } // 根据ID查询电影信息 public void searchMovieById(int id) { for (int i = 0; i \u0026lt; movies.length; i++) { Movie m = movies[i]; if (id == m.getId()) { System.out.println(\u0026#34;存在该电影！\u0026#34;); System.out.println(\u0026#34;编号：—————————————\u0026#34; + m.getId()); System.out.println(\u0026#34;电影名：—————————————\u0026#34; + m.getName()); System.out.println(\u0026#34;价格：—————————————\u0026#34; + m.getPrice()); System.out.println(\u0026#34;导演：—————————————\u0026#34; + m.getDirector()); System.out.println(\u0026#34;演员：—————————————\u0026#34; + m.getActor()); System.out.println(\u0026#34;评分：—————————————\u0026#34; + m.getScore()); System.out.println(\u0026#34;其他信息：—————————————\u0026#34; + m.getInfo()); return; } } System.out.println(\u0026#34;不存在该电影\u0026#34;); } } Test package com.show.ObjectDemo; import java.util.Scanner; public class Test { public static void main(String[] args) { // 创建Movie对象数组，存储电影信息 Movie[] movies = new Movie[4]; movies[0] = new Movie(1, \u0026#34;水门桥\u0026#34;, 38.9, 9.8, \u0026#34;徐克\u0026#34;, \u0026#34;吴京\u0026#34;, \u0026#34;12万人想看\u0026#34;); movies[1] = new Movie(2, \u0026#34;出拳吧\u0026#34;, 39, 7.8, \u0026#34;唐晓白\u0026#34;, \u0026#34;田雨\u0026#34;, \u0026#34;3.5万人想看\u0026#34;); movies[2] = new Movie(3, \u0026#34;月球陨落\u0026#34;, 42, 7.9, \u0026#34;罗兰\u0026#34;, \u0026#34;贝瑞\u0026#34;, \u0026#34;17.9万人想看\u0026#34;); movies[3] = new Movie(4, \u0026#34;一点就到家\u0026#34;, 35, 8.7, \u0026#34;许宏宇\u0026#34;, \u0026#34;刘昊然\u0026#34;, \u0026#34;10.8万人想看\u0026#34;); // 创建MovieOperator对象，用于操作Movie数组 MovieOperator movieOperator = new MovieOperator(movies); System.out.println(\u0026#34;在这里，你可以查询关于最新的电影信息！\u0026#34;); Scanner sc = new Scanner(System.in); while (true) { System.out.println(\u0026#34;输入1查看所有电影信息\u0026#34;); System.out.println(\u0026#34;输入2可以查询某个特定电影的详细信息\u0026#34;); int cmd = sc.nextInt(); switch (cmd) { case 1: movieOperator.printAllMovies(); // 打印所有电影信息 break; case 2: System.out.println(\u0026#34;请输入你需要查询的电影ID\u0026#34;); int id = sc.nextInt(); movieOperator.searchMovieById(id); // 根据ID查询电影信息 break; default: System.out.println(\u0026#34;非法命令，请重新输入\u0026#34;); } } } } 成员变量和局部变量 成员变量：类中， 方法外， 有默认值， 存于堆内存中， 属于整个对象， 于对象同生共死\n局部变量：常见于方法中，无默认值，需要初始化， 存于栈内存中， 属于所属大括号中， 方法调用而生，结束而亡\nAPI 注意事项 同一个包下的程序，可以直接访问 访问其他包下的程序，必须导包才可以访问 自己的程序中调用Java提供的程序，也需要先导包才可以使用 注意Java.lang包下的程序是不需要导包， 可以直接使用 访问多个其他包下的程序，在这些程序名一样的情况下，默认只能只能导入一个程序，另外一个程序必须带包名和类名来访问。 Demo d = new Demo(); d.print(); Demo1 d1 = new Demo1(); d1.print(); com.show.pkgDemo3.Demo1 d2 = new com.show.pkgDemo3.Demo1(); d2.print(); String String name = \u0026#34;Java\u0026#34;; System.out.println(name); String rs1 = new String(); System.out.println(rs1); String rs2 = new String(\u0026#34;NewStringJava\u0026#34;); System.out.println(rs2); String 是不可变的 只要是“\u0026hellip;”的方式写出的字符串对象，会存储到字符串常量池中，且相同内容的字符只会存储一份 而new String创建字符串对象时，每次都会new出来一个新对象，放在堆内存中。 String s1 = \u0026#34;abc\u0026#34;; String s2 = \u0026#34;abc\u0026#34;; System.out.println(s1==s2); //true char[] ch = {\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;}; String s3 = new String(ch); String s4 = new String(ch); System.out.println(s3==s4); //false String s5 = new String(\u0026#34;abc\u0026#34;); // 实际创建了两个对象，一个在字符串常量池当中 // 另一个在堆内存中 String s6 = \u0026#34;abc\u0026#34;; // 实际创建了0个对象，因为\u0026#34;abc\u0026#34;已经在常量池当中了 System.out.println(s5==s6); //false String s7 = \u0026#34;abc\u0026#34;; String s8 = \u0026#34;a\u0026#34;+\u0026#39;b\u0026#39;+\u0026#34;c\u0026#34;; //编译器会自动处理 System.out.println(s7==s8); //true String s9 = \u0026#34;abc\u0026#34;; String s10 = \u0026#34;ab\u0026#34;; String s11 = s10 + \u0026#34;c\u0026#34;; //而对于变量则不会自动处理 System.out.println(s9==s11); //false ArrayList ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;heima\u0026#34;); list.add(\u0026#34;Java\u0026#34;); list.add(\u0026#34;爪洼\u0026#34;); System.out.println(list);//[heima, Java, 爪洼] list.add(1, \u0026#34;JAVAJAVA\u0026#34;); System.out.println(list); //[heima, JAVAJAVA, Java, 爪洼] System.out.println(list.get(1));//JAVAJAVA System.out.println(list.size());//4 System.out.println(list.remove(1));//JAVAJAVA System.out.println(list.remove(\u0026#34;Java\u0026#34;)); //true 默认删除第一个出现的元素 System.out.println(list);//[heima, 爪洼] System.out.println(list.set(1, \u0026#34;ZhuaWa\u0026#34;));//爪洼 System.out.println(list);//[heima, ZhuaWa] 综合实践项目——ATM Account package com.showguan; public class Account { private int userId; private String userName; private String cardId; private char sex; private String possword; private double money; private double limit; public int getUserId() { return userId; } public void setUserId(int userId) { this.userId = userId; } public String getUserName() { return userName + (this.sex == \u0026#39;男\u0026#39; ? \u0026#34;先生\u0026#34; : \u0026#34;女士\u0026#34;); } public void setUserName(String userName) { this.userName = userName; } public char getSex() { return sex; } public void setSex(char sex) { this.sex = sex; } public String getPossword() { return possword; } public void setPossword(String possword) { this.possword = possword; } public double getMoney() { return money; } public void setMoney(double money) { this.money = money; } public double getLimit() { return limit; } public void setLimit(double limit) { this.limit = limit; } public String getCardId() { return cardId; } public void setCardId(String cardId) { this.cardId = cardId; } } ATM package com.showguan; import java.util.ArrayList; import java.util.Random; import java.util.Scanner; public class ATM { private ArrayList\u0026lt;Account\u0026gt; accounts = new ArrayList\u0026lt;\u0026gt;(); private Account loginAcc; private Scanner sc = new Scanner(System.in); public void start() { /** * 启动ATM系统，展示欢迎界面 */ while (true) { System.out.println(\u0026#34;欢迎您进入ATM系统！\u0026#34;); System.out.println(\u0026#34;1. 用户登录\u0026#34;); System.out.println(\u0026#34;2. 用户开户\u0026#34;); System.out.println(\u0026#34;请输入你需要进行的操作：\u0026#34;); String command = sc.next(); switch (command) { case \u0026#34;1\u0026#34;: login(); break; case \u0026#34;2\u0026#34;: createAccount(); break; default: System.out.println(\u0026#34;你输入的操作有误，请重新书输入！\u0026#34;); System.out.println(); break; } } } private void createAccount() { System.out.println(\u0026#34;===系统开户操作===\u0026#34;); Account acc = new Account(); System.out.println(\u0026#34;请输入用户名\u0026#34;); String name = sc.next(); acc.setUserName(name); while (true) { System.out.println(\u0026#34;请输入性别：\u0026#34;); char sex = sc.next().charAt(0); if (sex == \u0026#39;男\u0026#39; || sex == \u0026#39;女\u0026#39;) { acc.setSex(sex); break; } else { System.out.println(\u0026#34;你输入的性别有误！请重新输入\u0026#34;); } } while (true) { System.out.println(\u0026#34;请输入您的账户密码：\u0026#34;); String password = sc.next(); System.out.println(\u0026#34;请输入您的确认密码：\u0026#34;); String confirmPassword = sc.next(); if (password.equals(confirmPassword)) { acc.setPossword(password); System.out.println(\u0026#34;密码设置成功！\u0026#34;); break; } else { System.out.println(\u0026#34;两次密码不一致，请重新设置密码！\u0026#34;); } } System.out.println(\u0026#34;请输入您的取现最大额度\u0026#34;); double limit = sc.nextDouble(); acc.setLimit(limit); String cardId = createCardId(); acc.setCardId(cardId); accounts.add(acc); System.out.println(\u0026#34;恭喜你！\u0026#34; + acc.getUserName() + \u0026#34;开户完成, 您的卡号是:\u0026#34; + acc.getCardId()); } private String createCardId() { while (true) { String cardId = \u0026#34;\u0026#34;; Random r = new Random(); for (int i = 0; i \u0026lt; 8; i++) { int data = r.nextInt(10); cardId += data; } Account acc = getAccountByCardID(cardId); if (acc == null) { return cardId; } } } private Account getAccountByCardID(String cardId) { for (int i = 0; i \u0026lt; accounts.size(); i++) { Account acc = accounts.get(i); if (acc.getCardId().equals(cardId)) { return acc; } } return null; } private void login() { System.out.println(\u0026#34;===系统登录===\u0026#34;); if (accounts.size() == 0) { System.out.println(\u0026#34;当前系统内还没有任何账户，请先创建账户再来登录！\u0026#34;); return; } System.out.println(\u0026#34;请输入您的卡号\u0026#34;); String cardId = sc.next(); Account acc = getAccountByCardID(cardId); if (acc == null) { System.out.println(\u0026#34;用户不存在\u0026#34;); } else { while (true) { System.out.println(\u0026#34;请输入用户密码\u0026#34;); String passWord = sc.next(); if (passWord.equals(acc.getPossword())) { System.out.println(\u0026#34;登陆成功！\u0026#34;); loginAcc = acc; showUerCommand(); break; } else { System.out.println(\u0026#34;密码错误！请重新输入\u0026#34;); } } } } private void showUerCommand() { while (true) { System.out.println(loginAcc.getUserName() + \u0026#34;您可以进行如下操作\u0026#34;); System.out.println(\u0026#34;1. 查询账户\u0026#34;); System.out.println(\u0026#34;2. 存款\u0026#34;); System.out.println(\u0026#34;3. 取款\u0026#34;); System.out.println(\u0026#34;4. 转账\u0026#34;); System.out.println(\u0026#34;5. 修改密码\u0026#34;); System.out.println(\u0026#34;6. 退出\u0026#34;); System.out.println(\u0026#34;7. 注销当前账户\u0026#34;); System.out.println(\u0026#34;请选择您要进行的操作：\u0026#34;); String command = sc.next(); switch (command) { case \u0026#34;1\u0026#34;: showloginAccount(); break; case \u0026#34;2\u0026#34;: depositMoney(); break; case \u0026#34;3\u0026#34;: withDrawMoney(); break; case \u0026#34;4\u0026#34;: transferMoney(); break; case \u0026#34;5\u0026#34;: updatePassword(); return; case \u0026#34;6\u0026#34;: System.out.println(\u0026#34;用户\u0026#34; + loginAcc.getUserName() + \u0026#34;成功退出系统！\u0026#34;); return; case \u0026#34;7\u0026#34;: if (deleteAccount()) { return; } break; default: break; } } } private void updatePassword() { System.out.println(\u0026#34;===账号密码修改操作===\u0026#34;); while (true) { System.out.println(\u0026#34;请输入当前账户密码\u0026#34;); String password = sc.next(); if (loginAcc.getPossword().equals(password)) { while (true) { System.out.println(\u0026#34;请输入你要修改为的新密码：\u0026#34;); String newPassword = sc.next(); System.out.println(\u0026#34;请重复你需要修改为的密码：\u0026#34;); String confirmNewPassword = sc.next(); if (newPassword.equals(confirmNewPassword)) { System.out.println(\u0026#34;密码修改成功\u0026#34;); loginAcc.setPossword(newPassword); return; } System.out.println(\u0026#34;两次密码不一致， 请重新输入\u0026#34;); } } else { System.out.println(\u0026#34;您当前输入的密码错误！\u0026#34;); } } } private boolean deleteAccount() { System.out.println(\u0026#34;===销户操作===\u0026#34;); System.out.println(\u0026#34;确定要销户吗？y/n\u0026#34;); String command = sc.next(); switch (command) { case \u0026#34;y\u0026#34;: if (loginAcc.getMoney() == 0) { accounts.remove(loginAcc); System.out.println(\u0026#34;销户成功\u0026#34;); return true; } else { System.out.println(\u0026#34;账户下余额不为0， 不允许销户\u0026#34;); } break; } return false; } private void transferMoney() { System.out.println(\u0026#34;===用户转账===\u0026#34;); if (accounts.size() \u0026lt; 2) { System.out.println(\u0026#34;系统内只有您一个账户，无法转账\u0026#34;); return; } if (loginAcc.getMoney() \u0026lt; 0) { System.out.println(\u0026#34;您自己都没钱了，就别转了吧！\u0026#34;); return; } while (true) { System.out.println(\u0026#34;请您输入对方的卡号:\u0026#34;); String receiveCardID = sc.next(); Account acc = getAccountByCardID(receiveCardID); if (acc == null) { System.out.println(\u0026#34;您输入的卡号不存在！\u0026#34;); } else { String receiveName = \u0026#34;*\u0026#34; + acc.getUserName().substring(1); System.out.println(\u0026#34;请您输入【\u0026#34; + receiveName + \u0026#34;】姓氏\u0026#34;); System.out.println(receiveName); String firstName = sc.next(); if (acc.getUserName().startsWith(firstName)) { System.out.println(\u0026#34;姓氏验证成功！\u0026#34;); while (true) { System.out.println(); System.out.println(\u0026#34;请您输入转让给对方的金额:\u0026#34;); double transfermoney = sc.nextDouble(); if (loginAcc.getMoney() \u0026gt;= transfermoney) { System.out.println(\u0026#34;转账成功！\u0026#34;); loginAcc.setMoney(loginAcc.getMoney() - transfermoney); acc.setMoney(acc.getMoney() + transfermoney); return; } else { System.out.println(\u0026#34;余额不足，无法转账！！最多可转\u0026#34; + loginAcc.getMoney()); } } } else { System.out.println(\u0026#34;对不起， 您认证的姓氏有问题！\u0026#34;); } } } } private void withDrawMoney() { System.out.println(\u0026#34;===取钱操作===\u0026#34;); if (loginAcc.getMoney() \u0026lt; 100) { System.out.println(\u0026#34;您的账户余额不足100元，不允许取钱\u0026#34;); return; } while (true) { System.out.println(\u0026#34;请您输入取款金额：\u0026#34;); double drawMoney = sc.nextDouble(); if (loginAcc.getMoney() \u0026gt;= drawMoney) { if (drawMoney \u0026gt; loginAcc.getLimit()) { System.out.println(\u0026#34;取款金额大于限定额度， 您当前的限定额度为:\u0026#34; + loginAcc.getLimit()); break; } else { loginAcc.setMoney(loginAcc.getMoney() - drawMoney); System.out.println(\u0026#34;取款成功， 取款金额为\u0026#34; + drawMoney + \u0026#34;账户内剩余余额:\u0026#34; + loginAcc.getMoney()); return; } } else { System.out.println(\u0026#34;余额不足， 您当前的账户余额是：\u0026#34; + loginAcc.getMoney()); } } } private void showloginAccount() { System.out.println(\u0026#34;===当前您的账户信息如下===\u0026#34;); System.out.println(\u0026#34;用户名: \u0026#34; + loginAcc.getUserName()); System.out.println(\u0026#34;性别: \u0026#34; + loginAcc.getSex()); System.out.println(\u0026#34;卡号: \u0026#34; + loginAcc.getCardId()); System.out.println(\u0026#34;余额: \u0026#34; + loginAcc.getMoney()); System.out.println(\u0026#34;取现最大额度: \u0026#34; + loginAcc.getLimit()); } private void depositMoney() { System.out.println(\u0026#34;==存款操作==\u0026#34;); System.out.println(\u0026#34;请输入你要存款的金额\u0026#34;); double money = sc.nextDouble(); loginAcc.setMoney(loginAcc.getMoney() + money); System.out.println(\u0026#34;恭喜您\u0026#34; + \u0026#34;存款：\u0026#34; + money + \u0026#34;存款后余额:\u0026#34; + loginAcc.getMoney()); } } Test package com.showguan; public class Test { public static void main(String[] args) { ATM atm = new ATM(); atm.start(); } } ","permalink":"https://showguan.github.io/en/posts/tech/java20%E5%A4%A9%E9%80%9F%E6%88%90%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/","summary":"JAVA 20天速成 有志者事竟成 没有完完全全的投入，检测，学习是学不到东西的。 自欺欺人，眼高手低是绝对没有任何作用的。 JAVA背景信息 JAVA是一门","title":"Java20天速成——基础课程"},{"content":"算法笔记（一）——基础+杂项（Python实现） 基础+杂项 快速排序 def quick_sort(q, l, r): if l\u0026gt;=r: return i,j,x=l-1,r+1,q[(l+r)\u0026gt;\u0026gt;1] while i\u0026lt;j: i+=1 while q[i]\u0026lt;x: i+=1 j-=1 while q[j]\u0026gt;x: j-=1 if i\u0026lt;j: q[i], q[j] = q[j], q[i] quick_sort(q, l, j) quick_sort(q, j+1, r) n=int(input()) arr=list(map(int, input().split())) quick_sort(arr,0,n-1) print(\u0026#34; \u0026#34;.join(map(str, arr))) 归并排序 j = mid+1 !!!\ndef merge_sort(q,l,r): if l\u0026gt;=r: return mid = (l+r)\u0026gt;\u0026gt;1 merge_sort(q, l, mid) merge_sort(q, mid+1, r) i,j,k = l, mid+1, 0 tmp = [0]*(r-l+1) while i\u0026lt;=mid and j\u0026lt;=r: if q[i]\u0026lt;q[j]: tmp[k]=q[i] k+=1 i+=1 else: tmp[k]=q[j] k+=1 j+=1 while i\u0026lt;=mid: tmp[k]=q[i] i+=1 k+=1 while j\u0026lt;=r: tmp[k]=q[j] j+=1 k+=1 for i in range(l, r+1): q[i]=tmp[i-l] # q[l:r+1] = tmp[:] n=int(input()) arr=list(map(int, input().split())) merge_sort(arr, 0, n-1) print(\u0026#34; \u0026#34;.join(map(str, arr))) 二分 def check(x): # 检查 x 是否满足某种性质 pass # 这里需要根据具体的情况实现 def bsearch_1(l, r): while l \u0026lt; r: mid = (l + r) // 2 if check(mid): r = mid else: l = mid + 1 return l def bsearch_2(l, r): while l \u0026lt; r: mid = (l + r + 1) // 2 if check(mid): l = mid else: r = mid - 1 return l # 示例用法 # 首先定义 check 函数来检查性质 # 然后使用 bsearch_1 或 bsearch_2 来进行二分搜索 最佳牛围栏 题意：n块地，每块地上有奶牛，现在需要用围栏围起一些奶牛， 但至少有f块地，问最终围起的地中牛的数量的最大值为多少。 浮点数二分最大数量，判断所有数减去当前二分的平均数后，有没有一段长度为f并且是全为正数的，如果有则合法。判断方法：b数组存原数组减去平均数，求前缀和，用前缀和数组求某一段内的和是否为正数即可， 只要长度大于f的所有段都要枚举，但是我们只要求$s[i]-s[0-\u0026gt;i-f]$是否有一个大于0即可，所以只用求$min(s[0:i-f])$即可。注意浮点数二分因为误差需要用eps判断，并且r会稍微大于答案，l会稍微小于答案，题目问的是向下取整最近的整数，所以取r向下取整。 import sys input = lambda:sys.stdin.readline().strip() N = int(1e5+10) a, b = [0]*N, [0]*N n, f = map(int , input().split()) for i in range(1, n+1): a[i] = int(input()) l, r = 0.0, 2e3+10 eps = 1e-6 while r-l \u0026gt; eps: mid = (l+r)/2 s, mi, cur = [0]*N, 1e18, -1e18 for i in range(1, n+1): b[i] = a[i]-mid for i in range(1, n+1): s[i] = s[i-1]+b[i] for i in range(f, n+1): mi = min(mi, s[i-f]) cur = max(cur, s[i]-mi) if cur\u0026gt;=0: l = mid else: r = mid print(int(r*1000)) 浮点数二分 def check(x): # 检查x是否满足某种性质 pass # 这里需要根据具体情况实现check函数 def bsearch_3(l, r): eps = 1e-6 # eps 表示精度，取决于题目对精度的要求 while r - l \u0026gt; eps: mid = (l + r) / 2 if check(mid): r = mid else: l = mid return l 一维前缀和 def prefixSum(arr): n = len(arr) prefixSum = [0] * n prefixSum[0] = arr[0] for i in range(1, n): prefixSum[i] = prefixSum[i-1] + arr[i] for i in range(n): print(prefixSum[i], end=\u0026#34; \u0026#34;) arr = [1, 2, 3, 4, 5] prefixSum(arr) 二维前缀和 def prefixSum2D(arr): n = len(arr) m = len(arr[0]) prefixSum = [[0] * m for _ in range(n)] # 计算第一行的前缀和 prefixSum[0][0] = arr[0][0] for j in range(1, m): prefixSum[0][j] = prefixSum[0][j-1] + arr[0][j] # 计算第一列的前缀和 for i in range(1, n): prefixSum[i][0] = prefixSum[i-1][0] + arr[i][0] # 计算其他部分的前缀和 for i in range(1, n): for j in range(1, m): prefixSum[i][j] = prefixSum[i-1][j] + prefixSum[i][j-1] - prefixSum[i-1][j-1] + arr[i][j] return prefixSum def submatrixSum(prefixSum, x1, y1, x2, y2): return prefixSum[x2][y2] - prefixSum[x1-1][y2] - prefixSum[x2][y1-1] + prefixSum[x1-1][y1-1] arr = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]] prefixSum = prefixSum2D(arr) print(prefixSum) x1, y1 = 1, 1 x2, y2 = 2, 2 submatrixSum = submatrixSum(prefixSum, x1, y1, x2, y2) print(submatrixSum) 一维差分 差分和前缀和是逆运算。\n需要计算某一段区间$+-$操作时，运用差分操作 updateRange 需要先构造差分数组\n$s[i] = s[i-1]+a[i]$ 逆运算 $d[i]=a[i]-a[i-1]$ （原数组看作为前缀和数组）\ndef updateRange(B, l, r, c): B[l] += c B[r + 1] -= c def printArray(arr): for i in range(len(arr)): print(arr[i], end=\u0026#34; \u0026#34;) print() n= 5 B = [0] * (n + 1) updateRange(B, 1, 3, 2) updateRange(B, 2, 4, 3) printArray(B) 二维差分 def updateSubmatrix(S, x1, y1, x2, y2, c): S[x1][y1] += c S[x2 + 1][y1] -= c S[x1][y2 + 1] -= c S[x2 + 1][y2 + 1] += c def printMatrix(S): rows = len(S) cols = len(S[0]) for i in range(rows): for j in range(cols): print(S[i][j], end=\u0026#34; \u0026#34;) print() rows = 3 cols = 3 S = [[0] * cols for _ in range(rows + 1)] updateSubmatrix(S, 0, 0, 1, 1, 1) updateSubmatrix(S, 1, 1, 2, 2, 2) printMatrix(S) 双指针 for i in range(n): j = 0 while j \u0026lt; i and check(j, i): j += 1 # 具体问题的逻辑 # 常见问题分类： # (1) 对于一个序列，用两个指针维护一段区间 # (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作 位运算 原码，反码，补码 求n二进制表示中第k位数字: n \u0026gt;\u0026gt; k \u0026amp; 1 返回n的最后一位1：lowbit(n) = n \u0026amp; -n 树状数组基本操作 离散化 alls = [] # 存储所有待离散化的值 # 将所有值排序 alls.sort() # 去掉重复元素 alls = list(set(alls)) # 二分求出x对应的离散化的值 def find(x): l, r = 0, len(alls) - 1 while l \u0026lt; r: mid = (l + r) // 2 if alls[mid] \u0026gt;= x: r = mid else: l = mid + 1 return r + 1 # 映射到1, 2, ...n 区间合并 def merge(segs): segs.sort() # 区间左端点排序 res = [] st, ed = -2e9, -2e9 for seg in segs: if ed \u0026lt; seg[0]: if st != -2e9: res.append((st, ed)) st, ed = seg[0], seg[1] else: ed = max(ed, seg[1]) if st != -2e9: res.append((st, ed)) segs[:] = res ","permalink":"https://showguan.github.io/en/posts/tech/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E4%B8%80%E5%9F%BA%E7%A1%80+%E6%9D%82%E9%A1%B9python%E5%AE%9E%E7%8E%B0/","summary":"算法笔记（一）——基础+杂项（Python实现） 基础+杂项 快速排序 def quick_sort(q, l, r): if l\u0026gt;=r: return i,j,x=l-1,r+1,q[(l+r)\u0026gt;\u0026gt;1] while i\u0026lt;j: i+=1 while q[i]\u0026lt;x: i+=1 j-=1 while q[j]\u0026gt;x: j-=1 if i\u0026lt;j: q[i], q[j] = q[j], q[i] quick_sort(q, l, j) quick_sort(q, j+1, r) n=int(input()) arr=list(map(int, input().split())) quick_sort(arr,0,n-1) print(\u0026#34; \u0026#34;.join(map(str,","title":"算法笔记（一）——基础+杂项（Python实现）"},{"content":"算法笔记（三）——图论（Python实现） 图论 树的存储 邻接矩阵 # 创建一个二维列表表示邻接矩阵 n = 10 # 顶点数量 g = [[0] * n for _ in range(n)] # 添加一条边a-\u0026gt;b def add_edge(a, b): g[a][b] = 1 # 初始化 g = [[0] * n for _ in range(n)] 邻接表 # 创建一个列表表示邻接表 n = 10 # 顶点数量 h = [-1] * n e = [0] * n ne = [0] * n idx = 0 # 添加一条边a-\u0026gt;b def add_edge(a, b): global idx e[idx] = b ne[idx] = h[a] h[a] = idx idx += 1 # 初始化 idx = 0 h = [-1] * n 树和图的存储 # 邻接表表示的图 N = 100010 # 根据具体需求设置合适的最大节点数量 # 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点 h = [-1] * N # 存储边的目标节点 e = [0] * N # 存储下一条边的索引 ne = [0] * N # 边的索引 idx = 0 # 添加一条边a-\u0026gt;b def add(a, b): global idx e[idx] = b ne[idx] = h[a] h[a] = idx idx += 1 # 初始化 idx = 0 for i in range(N): h[i] = -1 树和图的遍历 DFS def dfs(u): st[u] = True i = h[u] while i!=-1: j = e[i] if not st[j]: dfs(j) i = ne[i] BFS from collections import deque q = deque() st[1] = True q.append(1) while q: t = q.popleft() i = h[t] while i!=-1: j=e[i] if not st[j]: st[j] = True q.append(j) i=ne[i] 拓扑排序 def topsort(): hh, tt = 0, -1 for i in range(1, n+1): if d[i]==0: q.append(i) tt+=1 while hh\u0026lt;=tt: t = q[hh] hh+=1 i = h[t] while i!=-1: j = e[i] d[j]-=1 if d[j]==0: q.append(j) tt+=1 i = ne[i] return tt==n-1 LCA def lca(x,y): if dep[x] \u0026lt; dep[y]: x,y = y,x d = dep[x]-dep[y] while d: # 循环直到深度差为 0 v = d \u0026amp; -d # 获取 d 的最低位的 1 所在的位置 i = v.bit_length() - 1 # 计算最低位的位置索引 x = fa[i][x] # 将节点 x 上移到和节点 y 同一深度 d -= v # 更新深度差 if x==y: return x for k in range(K-1, -1, -1): if fa[k][x] != fa[k][y]: x = fa[k][x] y = fa[k][y] return fa[0][x] # 初始化深度以及父节点信息 dep[x]=dep[val]+1 dep[y]=dep[val]+1 fa[0][x] = val fa[0][y] = val for k in range(K-1): fa[k+1][x] = fa[k][fa[k][x]] # 自己的第2^(1+1)级父亲即为 自己的第2^(1)级父亲 的第2^(1)级父亲 fa[k+1][y] = fa[k][fa[k][y]] 最短路 单元最短路\n​\t所有边权为正：\n​\t朴素版Dijkstra $O(n^2)$,堆优化版的Dijkstra $O(mlogn)$, ​\t存在负权边\n​\tBellman-Ford $O(nm)$, SPFA 队列优化的Bellman-Ford, 一般情况：$O(m)$ 最坏情况：$O(nm)$ 多元汇最短路：\n​\tFloyed $O(n^3)$ 朴素Dijkstra Dijkstra不能处理负权边：\nN = int(5e2)+10 INF = 0x3f3f3f3f g = [[INF]*N for _ in range(N)] #g = defaultdict(lambda:defaultdict(lambda:INF)) 同样的效果 dis = [INF]*N st = [False]*N def dijkstra(): dis[1]=0 for i in range(n-1): t=-1 for j in range(1,n+1): if not st[j] and (t==-1 or dis[j]\u0026lt;dis[t]): t=j for j in range(1,n+1): dis[j]=min(dis[j], dis[t] + g[t][j]) st[t]=True if dis[n]==INF: return -1 return dis[n] n, m = map(int, input().split()) for _ in range(m): x, y, z = map(int ,input().split()) g[x][y] = min(g[x][y], z) print(dijkstra()) 堆优化版Dijkstra from heapq import * import sys input = lambda:sys.stdin.readline().strip() N = 150010 INF = 0x3f3f3f3f e, ne, head, w, dis= [0]*N, [0]*N, [-1]*N, [0]*N, [INF]*N st = [False]*N idx=0 def add(a, b, x): global idx e[idx]=b w[idx]=x ne[idx]=head[a] head[a]=idx idx+=1 def dijkstra(): dis[1]=0 h=[] heappush(h, (0,1)) while h: dist, ver = heappop(h) if st[ver]: continue st[ver]=True i=head[ver] while i!=-1: j=e[i] if not st[j] and dis[j]\u0026gt;dist+w[i]: dis[j]=dist+w[i] heappush(h, (dis[j], j)) i=ne[i] if dis[n]==INF: print(-1) else: print(dis[n]) n, m = map(int, input().split()) for _ in range(m): x, y, z = map(int, input().split()) add(x,y,z) dijkstra() 另一种写法 from heapq import * from collections import defaultdict import sys input=lambda:sys.stdin.readline().strip() N, INF = 150010, 0x3f3f3f3f dis, st = [INF]*N, [False]*N g=defaultdict(list) def dijkstra(): dis[1]=0 h=[] heappush(h, (0, 1)) while h: dist, ver = heappop(h) if st[ver]: continue st[ver]=True for y, z in g[ver]: if dis[y]\u0026gt;dis[ver]+z: dis[y]=dis[ver]+z heappush(h, (dis[y], y)) if dis[n]==INF: print(-1) else: print(dis[n]) n, m = map(int, input().split()) for _ in range(m): x,y,z = map(int, input().split()) g[x].append((y, z)) dijkstra() Bellman-Ford # n表示点数，m表示边数 dist = [float(\u0026#39;inf\u0026#39;)] * (n + 1) # dist[x]存储1到x的最短路距离 # 边，a表示出点，b表示入点，w表示边的权重 edges = [] # 求1到n的最短路距离，如果无法从1走到n，则返回-1。 def bellman_ford(): dist[1] = 0 # 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。 for i in range(n): for j in range(m): a, b, w = edges[j][\u0026#39;a\u0026#39;], edges[j][\u0026#39;b\u0026#39;], edges[j][\u0026#39;w\u0026#39;] if dist[b] \u0026gt; dist[a] + w: dist[b] = dist[a] + w if dist[n] \u0026gt; float(\u0026#39;inf\u0026#39;) / 2: return -1 return dist[n] SPFA from collections import defaultdict, deque import sys input = lambda:sys.stdin.readline().strip() N, INF = int(1e5+10), 0x3f3f3f3f dis, st = [INF]*N, [False]*N g=defaultdict(list) def spfa(): q=deque() q.append(1) st[1]=True dis[1]=0 while q: x=q.popleft() st[x]=False for y, z in g[x]: if dis[y]\u0026gt;dis[x]+z: dis[y]=dis[x]+z if not st[y]: st[y]=True q.append(y) if dis[n]==INF: print(\u0026#39;impossible\u0026#39;) else: print(dis[n]) n, m = map(int, input().split()) for _ in range(m): x, y, z = map(int, input().split()) g[x].append((y, z)) spfa() 判断负环 from collections import deque N = int(1e5+10) INF = 0x3f3f3f3f n = 0 # 总点数 h = [-1] * N # 邻接表存储所有边 e, ne, w = [0] * N, [0] * N, [0] * N idx = 0 dist, cnt = [INF] * N, [0] * N # dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数 st = [False] * N # 存储每个点是否在队列中 # 如果存在负环，则返回True，否则返回False。 def spfa(): # 不需要初始化dist数组 # 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环 q = deque() for i in range(1, n + 1): q.append(i) st[i] = True while q: t = q.popleft() st[t] = False i = h[t] while i != -1: j = e[i] if dist[j] \u0026gt; dist[t] + w[i]: dist[j] = dist[t] + w[i] cnt[j] = cnt[t] + 1 if cnt[j] \u0026gt;= n: return True # 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环 if not st[j]: q.append(j) st[j] = True i = ne[i] return False # Example usage: # n = 5 # h = [-1, 2, 1, 4, 3, -1] # e = [0, 2, 1, 4, 3, 0] # ne = [1, -1, 3, -1, -1, 2] # w = [0, 1, 2, 3, 4, 5] # if spfa(): # print(\u0026#34;Exist negative cycle\u0026#34;) # else: # print(\u0026#34;No negative cycle\u0026#34;) floyd INF = float(\u0026#39;inf\u0026#39;) # 初始化距离矩阵d，d[a][b]表示a到b的最短距离 def initialize(n): d = [[0 if i == j else INF for j in range(n)] for i in range(n)] return d # Floyd算法求解最短路径 def floyd(d, n): for k in range(n): for i in range(n): for j in range(n): d[i][j] = min(d[i][j], d[i][k] + d[k][j]) return d # Example usage: # n = 5 # d = initialize(n) # d = floyd(d, n) # print(d) Prim INF = float(\u0026#39;inf\u0026#39;) # Prim算法求解最小生成树的权重之和 def prim(n, g): dist = [INF] * (n + 1) st = [False] * (n + 1) res = 0 for i in range(n): t = -1 for j in range(1, n + 1): if not st[j] and (t == -1 or dist[t] \u0026gt; dist[j]): t = j if i and dist[t] == INF: return INF if i: res += dist[t] st[t] = True for j in range(1, n + 1): dist[j] = min(dist[j], g[t][j]) return res # Example usage: # n = 5 # g = [[0] * (n + 1) for _ in range(n + 1)] # dist = prim(n, g) # print(dist) Kruskal INF = float(\u0026#39;inf\u0026#39;) # 并查集的查找操作 def find(x, p): if p[x] != x: p[x] = find(p[x], p) return p[x] # Kruskal算法求解最小生成树的权重之和 def kruskal(n, m, edges): edges.sort(key=lambda x: x[2]) # 按照边权重对边进行排序 p = [i for i in range(n + 1)] # 初始化并查集的父节点数组 res = 0 cnt = 0 for edge in edges: a, b, w = edge a = find(a, p) b = find(b, p) if a != b: # 如果两个连通块不连通，则将这两个连通块合并 p[a] = b res += w cnt += 1 if cnt \u0026lt; n - 1: return INF return res # Example usage: # n, m = 5, 7 # edges = [(1, 2, 2), (1, 3, 5), (1, 4, 6), (2, 3, 1), (2, 4, 3), (3, 4, 4), (4, 5, 7)] # min_spanning_tree_weight = kruskal(n, m, edges) # print(min_spanning_tree_weight) 染色法 使用了深度优先搜索算法（DFS）来判断一个图是否是二分图\n二分图：顶点分为两个集合，边仅存在于两个不同的集合中，而集合内部都没有边。\nPython优先使用BFS，因为DFS会出现各种问题，爆战，段错误（还没搞清楚原因）等\n这段代码使用了染色法来判断一个无向图是否为二分图。下面我来解释一下：\n题目大意： 给定一个无向图，判断是否可以将其顶点集合划分为两个不相交的子集，使得每条边的两个端点分别属于这两个子集。如果可以，则输出\u0026quot;Yes\u0026quot;，否则输出\u0026quot;No\u0026quot;。\n实现思路：\n使用邻接表 g 来表示无向图，其中 g[u] 存储与顶点 u 相连的所有顶点。 定义一个数组 color 来标记每个顶点的染色情况，初始值设为 -1 表示未染色。 定义一个 BFS 函数 bfs(u, c)，其中 u 表示起始顶点，c 表示初始颜色。该函数使用 BFS 遍历图，并将顶点染色，保证相邻顶点颜色不同。 在主体部分，遍历所有顶点，对于每个未染色的顶点，调用 bfs 函数进行染色。如果染色过程中发现相邻顶点颜色相同，则返回 \u0026ldquo;No\u0026rdquo;，表示无法划分为二分图；否则返回 \u0026ldquo;Yes\u0026rdquo;。 import sys from collections import deque, defaultdict input = lambda:sys.stdin.readline().strip() N = int(1e5)+10 g = defaultdict(list) color = [-1]*N def bfs(u, c): color[u] = c q = deque() q.append((u, c)) while q: cur, col = q.popleft() for nx in g[cur]: if color[nx]==-1: color[nx] = 1-col q.append((nx, 1-col)) elif color[nx]==col: return False return True n, m = map(int, input().split()) for i in range(m): u, v = map(int, input().split()) # if u==v: #***自环不能去掉*** # continue if u not in g[v]: g[v].append(u) if v not in g[u]: g[u].append(v) for i in range(1, n+1): if color[i]==-1: if not bfs(i, 0): print(\u0026#34;No\u0026#34;) exit() print(\u0026#34;Yes\u0026#34;) 匈牙利算法 题目大意： 给定一个二分图，其中左侧顶点集合为 (N_1)，右侧顶点集合为 (N_2)，图中存在一些边。需要找到尽可能多的匹配，使得左侧的每个顶点最多与一个右侧的顶点相连，而右侧的每个顶点最多与一个左侧的顶点相连。\n实现思路：\n使用一个二维数组 g 存储图的邻接表表示。其中 g[u] 表示与左侧顶点 u 相连的所有右侧顶点的集合。 定义一个函数 find(x)，用于从左侧顶点 x 开始尝试寻找增广路径，如果找到了增广路径就返回 True，否则返回 False。 在主体部分，遍历左侧的每个顶点，对每个顶点调用 find 函数进行匹配，若成功匹配，则匹配数加一。 import sys from collections import defaultdict N = int(1e3)+10 mat, st = [0]*N, [False]*N g = defaultdict(list) def find(x): for v in g[x]: if not st[v]: st[v] = True if mat[v]==0 or find(mat[v]): mat[v] = x return True return False n1, n2, m = map(int, input().split()) for i in range(m): u, v = map(int, input().split()) g[u].append(v) # hungarian 主体部分 ans = 0 for i in range(1, n1+1): st = [False]*N if find(i): ans+=1 print(ans) ","permalink":"https://showguan.github.io/en/posts/tech/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E4%B8%89%E5%9B%BE%E8%AE%BApython%E5%AE%9E%E7%8E%B0/","summary":"算法笔记（三）——图论（Python实现） 图论 树的存储 邻接矩阵 # 创建一个二维列表表示邻接矩阵 n = 10 # 顶点数量 g = [[0] * n for _ in range(n)] # 添加一条边a","title":"算法笔记（三）——图论（Python实现）"},{"content":"算法笔记（二）——数据结构(Python实现) 数据结构 单链表 N = int(1e5+10) e=[0]*N ne=[0]*N head=-1 idx=1 def insert(x): global idx, head e[idx]=x ne[idx]=head head=idx idx+=1 def add(k, x): global idx e[idx]=x ne[idx]=ne[k] ne[k]=idx idx+=1 def remove(k): global idx, head if k==0: head = ne[head] else: ne[k]=ne[ne[k]] n = int(input()) for _ in range(n): s = input().split() op=s[0] if op==\u0026#39;H\u0026#39;: insert(int(s[1])) elif op==\u0026#39;I\u0026#39;: add(int(s[1]), int(s[2])) else: remove(int(s[1])) i=head while i!=-1: print(e[i], end=\u0026#39; \u0026#39;) i=ne[i] 双链表 N = int(1e5+10) e=[0]*N l=[0]*N r=[0]*N idx=0 def init(): global idx r[2]=1 l[1]=2 idx=3 def insert(k, x): global idx e[idx]=x l[idx]=k r[idx]=r[k] l[r[k]]=idx r[k]=idx idx+=1 def remove(k): l[r[k]]=l[k] r[l[k]]=r[k] init() m=int(input()) for _ in range(m): s=input().split() if s[0]==\u0026#39;L\u0026#39;: x=int(s[1]) insert(2,x) elif s[0]==\u0026#39;R\u0026#39;: x=int(s[1]) insert(l[1],x) elif s[0]==\u0026#39;D\u0026#39;: k=int(s[1])+2 remove(k) elif s[0]==\u0026#39;IL\u0026#39;: k=int(s[1])+2 x=int(s[2]) insert(l[k],x) elif s[0]==\u0026#39;IR\u0026#39;: k=int(s[1])+2 x=int(s[2]) insert(k,x) i=2 while i!=0: if i==2 or i==1: i=r[i] continue print(e[i],end=\u0026#34; \u0026#34;) i=r[i] 栈 N = int(1e5+10) # 假设N的值为100 stk = [0] * N tt = 0 # 向栈顶插入一个数 tt += 1 stk[tt] = x # 从栈顶弹出一个数 tt -= 1 # 栈顶的值 stk[tt] # 判断栈是否为空 if tt \u0026gt; 0: pass 队列 N = 100 # 假设N的值为100 q = [0] * N hh = 0 tt = -1 # 向队尾插入一个数 tt += 1 q[tt] = x # 从队头弹出一个数 hh += 1 # 队头的值 q[hh] # 判断队列是否为空 if hh \u0026lt;= tt: pass N = 100 # 假设N的值为100 q = [0] * N hh = 0 tt = 0 # 向队尾插入一个数 q[tt] = x tt += 1 if tt == N: tt = 0 # 从队头弹出一个数 hh += 1 if hh == N: hh = 0 # 队头的值 q[hh] # 判断队列是否为空 if hh != tt: pass 单调栈 tt = 0 stk = [0] * (n + 1) for i in range(1, n + 1): while tt and check(stk[tt], i): tt -= 1 stk[tt + 1] = i tt += 1 单调队列 n = 10 # 假设n的值为10 hh = 0 tt = -1 q = [0] * n for i in range(n): while hh \u0026lt;= tt and check_out(q[hh]): hh += 1 while hh \u0026lt;= tt and check(q[tt], i): tt -= 1 q[tt + 1] = i tt += 1 N = int(1e6+10) q=[0 for _ in range(N)] n,k=map(int, input().split()) a=[0]+[int(x) for x in input().split()] hh,tt=0,-1 for i in range(1,n+1): if hh\u0026lt;=tt and i-q[hh]+1\u0026gt;k: hh+=1 while hh\u0026lt;=tt and a[q[tt]] \u0026gt;= a[i]: tt-=1 tt+=1 q[tt]=i if i \u0026gt;= k: print(a[q[hh]], end=\u0026#34; \u0026#34;) print() hh,tt=0,-1 for i in range(1,n+1): if hh\u0026lt;=tt and i-q[hh]+1\u0026gt;k: hh+=1 while hh\u0026lt;=tt and a[q[tt]] \u0026lt;= a[i]: tt-=1 tt+=1 q[tt]=i if i\u0026gt;=k: print(a[q[hh]], end=\u0026#34; \u0026#34;) KMP m = len(p) # 假设p为模板串，长度为m n = len(s) # 假设s为模式串，长度为n ne = [0] * (m + 1) # 初始化ne数组 # 求Next数组 j = 0 for i in range(2, m + 1): while j and p[i] != p[j + 1]: j = ne[j] if p[i] == p[j + 1]: j += 1 ne[i] = j # 匹配 j = 0 for i in range(1, n + 1): while j and s[i] != p[j + 1]: j = ne[j] if s[i] == p[j + 1]: j += 1 if j == m: j = ne[j] # 匹配成功后的逻辑 Tire N = 100010 son = [[0] * 26 for _ in range(N)] cnt = [0] * N idx = 0 # 0号点既是根节点，又是空节点 # son[][]存储树中每个节点的子节点 # cnt[]存储以每个节点结尾的单词数量 # 插入一个字符串 def insert(s): global idx p = 0 for i in range(len(s)): u = ord(s[i]) - ord(\u0026#39;a\u0026#39;) if not son[p][u]: idx += 1 son[p][u] = idx p = son[p][u] cnt[p] += 1 # 查询字符串出现的次数 def query(s): p = 0 for i in range(len(s)): u = ord(s[i]) - ord(\u0026#39;a\u0026#39;) if not son[p][u]: return 0 p = son[p][u] return cnt[p] 马拉车（字符串回文串算法） class Solution: # 推荐教学视频 ：https://www.bilibili.com/video/BV1Sx4y1k7jG/?spm_id_from=333.337.search-card.all.click\u0026amp;vd_source=a4a2b56f746715b34521bfb853094cf4 def longestPalindrome(self, s: str) -\u0026gt; str: s = \u0026#39;#\u0026#39; + \u0026#39;#\u0026#39;.join(list(s)) + \u0026#39;#\u0026#39; n = len(s) p = [0]*n #每个点的 最长回文字串 能到的 右侧位置 c, r = 0, 0 # 右边能到达最远的蘑菇的位置 和 其最右边能达到的位置 for i in range(n): if i\u0026lt;=r: p[i] = min(r-i, p[c + c-i]) # 由已知条件得到当前位置能达到的最大右侧距离( 需要取min(镜像位置的值, 当前最大蘑菇能覆盖到的最大值) ) while i+p[i]+1 \u0026lt; n and s[i-p[i]-1] == s[i+p[i]+1]: p[i]+=1 if p[i]+i \u0026gt; r: r = p[i] + i c = i ma = max(p) idx = p.index(ma) return s[idx-ma+1:idx+ma+1:2] 并查集 N = 1000005 # 假设N的值为1000005 p = [0] * N # 初始化p数组 # 返回x的祖宗节点 def find(x): if p[x] != x: p[x] = find(p[x]) return p[x] # 初始化，假定节点编号是1~n for i in range(1, n + 1): p[i] = i # 合并a和b所在的两个集合 p[find(a)] = find(b) 维护size信息\n# Python中没有类似于C++的数组声明方式，我们直接使用列表来代替 p = [i for i in range(N)] size = [1] * N # 返回x的祖宗节点 def find(x): if p[x] != x: p[x] = find(p[x]) return p[x] # 初始化，假定节点编号是1~n n = N # 假设n是提前定义好的 for i in range(1, n + 1): p[i] = i size[i] = 1 # 合并a和b所在的两个集合 p[find(a)] = find(b) size[b] += size[a] 维护到祖宗节点距离的并查集\n# Python中没有类似于C++的数组声明方式，我们直接使用列表来代替 p = [i for i in range(N)] d = [0] * N # 返回x的祖宗节点 def find(x): if p[x] != x: u = find(p[x]) d[x] += d[p[x]] p[x] = u return p[x] # 初始化，假定节点编号是1~n n = N # 假设n是提前定义好的 for i in range(1, n + 1): p[i] = i d[i] = 0 # 合并a和b所在的两个集合 p[find(a)] = find(b) d[find(a)] = distance # 根据具体问题，初始化find(a)的偏移量 堆 # h[N] 存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1 # ph pos[k] 存储第k个插入的点在堆中的位置 # hp ord[k] 存储堆中下标是k的点是第几个插入的 N = 1000005 # 假设N的值为1000005 h = [0] * N # 初始化h数组 ph = [0] * N # 初始化ph数组 hp = [0] * N # 初始化hp数组 size = 0 # 初始化size为0 # 交换两个点，及其映射关系 def heap_swap(a, b): ph[hp[a]], ph[hp[b]] = ph[hp[b]], ph[hp[a]] hp[a], hp[b] = hp[b], hp[a] h[a], h[b] = h[b], h[a] def down(u): t = u if u * 2 \u0026lt;= size and h[u * 2] \u0026lt; h[t]: t = u * 2 if u * 2 + 1 \u0026lt;= size and h[u * 2 + 1] \u0026lt; h[t]: t = u * 2 + 1 if u != t: heap_swap(u, t) down(t) def up(u): while u // 2 and h[u] \u0026lt; h[u // 2]: heap_swap(u, u // 2) u \u0026gt;\u0026gt;= 1 # O(n)建堆 for i in range(n // 2, 0, -1): down(i) def add_element(x): global size size += 1 h[size] = x ph[size] = size hp[size] = size up(size) def get_heap_top(): return h[1] def delete_element(k): global size heap_swap(k, size) size -= 1 down(k) up(k) def update_element(k, x): h[k] = x down(k) up(k) # 添加元素 add_element(x) # 堆顶元素 heap_top = get_heap_top() # 删除第size个节点 delete_element(1) # 删除第k个节点 delete_element(k) # 将第k个元素赋值为x update_element(k, x) 哈希 (1)拉链法 N = 1000005 # 假设N的值为1000005 h = [-1] * N # 初始化h数组为-1 e = [0] * N # 初始化e数组 ne = [0] * N # 初始化ne数组 idx = 0 # 初始化idx为0 # 向哈希表中插入一个数 def insert(x): k = (x % N + N) % N e[idx] = x ne[idx] = h[k] h[k] = idx idx += 1 # 在哈希表中查询某个数是否存在 def find(x): k = (x % N + N) % N i = h[k] while i != -1: if e[i] == x: return True i = ne[i] return False N = 100003 e, ne, h = [0]*N, [0]*N, [-1]*N idx = 0 def insert(x): global idx k = (x%N + N)%N e[idx] = x ne[idx] = h[k] h[k] = idx idx+=1 def query(x): k = (x%N + N)%N i = h[k] while i!=-1: if e[i]==x: return True i = ne[i] return False n = int(input()) for i in range(n): s = input().split() op, k = s[0], int(s[1]) if op==\u0026#39;I\u0026#39;: insert(k) else: if query(k): print(\u0026#34;Yes\u0026#34;) else: print(\u0026#34;No\u0026#34;) (2) 开放寻址法 N = 1000005 # 假设N的值为1000005 h = [0] * N # 初始化h数组 # 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置 def find(x): t = (x % N + N) % N while h[t] != 0 and h[t] != x: t += 1 if t == N: t = 0 return t 字符串哈希 这段代码实现了字符串的哈希算法，用于快速计算子串的哈希值。下面我来解释一下：\n题目大意： 这段代码实现了字符串哈希算法，可以用于快速计算给定字符串中任意子串的哈希值。\n实现思路：\n首先定义了两个数组 h 和 p，分别用于存储字符串的哈希值和幂次值。 对于字符串的每个位置，计算其对应的哈希值并存储在数组 h 中。同时计算幂次值并存储在数组 p 中。 字符串的哈希值由以下公式计算得到：[h[i] = h[i - 1] \\times P + \\text{ord}(str[i])]其中，(P) 是一个预先定义的质数（例如 131 或 13331），(\\text{ord}(str[i])) 表示字符串中第 (i) 个字符的 ASCII 值。 计算子串 (str[l:r]) 的哈希值时，使用以下公式：$ \\text{get}(l, r) = h[r] - h[l - 1] \\times p[r - l + 1] $其中，(h[r]) 是子串起始位置到结束位置的哈希值，(h[l - 1]) 是子串起始位置前一个位置的哈希值，(p[r - l + 1]) 是子串长度对应的幂次值。 总体来说，这段代码实现了字符串哈希算法，用于快速计算给定字符串中任意子串的哈希值。\nh 数组存储了字符串的哈希值，即从字符串的起始位置到当前位置的子串的哈希值。 h[i] 表示字符串从第一个字符到第 i 个字符（包括第 i 个字符）的子串的哈希值。 p[i] 表示幂次值，即 $P^i$ 的值，其中 $P$ 是一个预先定义的质数。 p 数组存储了幂次值，用于计算子串的哈希值时使用。 N = 1000005 # 假设N的值为1000005 P = 131 # 或者可以设置为13331 h = [0] * N # 初始化h数组 p = [0] * N # 初始化p数组 # 初始化 p[0] = 1 for i in range(1, n + 1): h[i] = h[i - 1] * P + ord(str[i]) p[i] = p[i - 1] * P # 计算子串 str[l ~ r] 的哈希值 def get(l, r): return h[r] - h[l - 1] * p[r - l + 1] 树状数组 楼兰图腾\nimport sys input=lambda:sys.stdin.readline() M = 200010 suml, sumg = 0, 0 tr = [0]*M n = int(input()) a = [0]+[int(_) for _ in input().split()] def lowbit(x): return x\u0026amp;-x def add(x,v): while x\u0026lt;M: tr[x]+=v x+=lowbit(x) def query(x): res = 0 while x: res+=tr[x] x-=lowbit(x) return res for i in range(1,n+1): y=a[i] lw = query(y-1) lwr = y-1-lw # the lower element on the right side gr = query(n)-query(y) grr = (n-y) - gr suml += (lw*lwr) sumg += (gr*grr) add(y,1) print(sumg, suml) 线段树 # 定义树节点，l,r, val表示该节点记录的是区间[l, r]的最大值是val class Tree(): def __init__(self): self.l = 0 self.r = 0 self.lazy = 0 self.val = 0 # 二叉树是堆形式，可以用一维数组存储，注意数组长度要开4倍空间 tree = [Tree() for i in range(10*4)] # 建树，用cur\u0026lt;\u0026lt;1访问左子树，cur\u0026lt;\u0026lt;1|1访问右子树，位运算操作很方便 def build(cur, l, r): tree[cur].l, tree[cur].r, tree[cur].lazy, tree[cur].val = l, r, 0, 0 # 当l==r的时候结束递归 if l \u0026lt; r: mid = l + r \u0026gt;\u0026gt; 1 build(cur\u0026lt;\u0026lt;1, l, mid) build(cur\u0026lt;\u0026lt;1|1, mid+1, r) # 当子节点计算完成后，用子节点的值来更新自己的值 def pushup(cur): tree[cur].val = max(tree[cur\u0026lt;\u0026lt;1].val, tree[cur\u0026lt;\u0026lt;1|1].val) # 单点更新 def add(cur, x, v): if tree[cur].l == tree[cur].r: tree[cur].val += v else: mid = tree[cur].r + tree[cur].l \u0026gt;\u0026gt; 1 if x \u0026gt; mid: add(cur\u0026gt;\u0026gt;1|1, x, v) else: add(cur\u0026lt;\u0026lt;1, x, v) pushup(cur) # 将lazy标记向下传递一层 def pushdown(cur): if tree[cur].lazy: lazy = tree[cur].lazy tree[cur\u0026lt;\u0026lt;1].lazy += lazy tree[cur\u0026lt;\u0026lt;1|1].lazy += lazy tree[cur\u0026lt;\u0026lt;1].val += lazy tree[cur\u0026lt;\u0026lt;1|1].val += lazy tree[cur].lazy = 0 # 区间更新 def update(cur, l, r, v): if l \u0026lt;= tree[cur].l and tree[cur].r \u0026lt;= r: tree[cur].lazy += v tree[cur].val += v return if r \u0026lt; tree[cur].l or l \u0026gt; tree[cur].r: return if tree[cur].lazy: pushdown(cur) update(cur\u0026lt;\u0026lt;1, l, r, v) update(cur\u0026lt;\u0026lt;1|1, l, r, v) pushup(cur) # 区间查询 def query(cur, l, r): if l \u0026lt;= tree[cur].l and tree[cur].r \u0026lt;= r: return tree[cur].val if tree[cur].l \u0026gt; r or tree[cur].r \u0026lt; l: return 0 if tree[cur].lazy: pushdown(cur) return max(query(cur\u0026lt;\u0026lt;1, l, r), query(cur\u0026lt;\u0026lt;1|1)) # 测试 # ----- # --- # ------- # -- # -- build(1, 1, 10) update(1, 1, 5, 1) update(1, 7, 10, 1) update(1, 2, 8, 1) update(1, 3, 4, 1) update(1, 9, 10, 1) print(query(1, 1, 10)) def pushup(u): tr[u] = tr[u \u0026lt;\u0026lt; 1] + tr[u \u0026lt;\u0026lt; 1 | 1] def build(u, l, r): if l == r: tr[u] = 0 else: mid = (l + r) \u0026gt;\u0026gt; 1 build(u \u0026lt;\u0026lt; 1, l, mid) build(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r) pushup(u) def query(u, l, r, ql, qr): if l \u0026gt;= ql and r \u0026lt;= qr: return tr[u] mid = (l + r) \u0026gt;\u0026gt; 1 if mid==l and mid==r: return 0 res = 0 if ql \u0026lt;= mid: res = query(u \u0026lt;\u0026lt; 1, l, mid, ql, qr) if qr \u0026gt; mid: res += query(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, ql, qr) return res def modify(u, x, l, r, val): if l == r: tr[u] += val else: mid = (l + r) \u0026gt;\u0026gt; 1 if x \u0026lt;= mid: modify(u \u0026lt;\u0026lt; 1, x, l, mid, val) else: modify(u \u0026lt;\u0026lt; 1 | 1, x, mid + 1, r, val) pushup(u) 搜索深入 池塘计数 import sys from collections import deque input = lambda:sys.stdin.readline().strip() N = int(1e3+10) M = N*N g = [0]*N cnt=0 vis = [ [False]*N for _ in range(N) ] def bfs(x, y): q=deque() q.append( (x,y) ) while q: tx, ty = q[0] q.popleft() for i in range(-1, 2): for j in range(-1, 2): if i==0 and j==0: continue xx, yy = tx+i, ty+j if xx\u0026lt;0 or xx\u0026gt;=n or yy\u0026lt;0 or yy\u0026gt;=m or vis[xx][yy] or g[xx][yy]==\u0026#39;.\u0026#39;: continue vis[xx][yy]=True q.append( (xx,yy) ) n, m = map(int, input().split()) for i in range(n): g[i]=input() for i in range(n): for j in range(m): if g[i][j]!=\u0026#39;W\u0026#39; or vis[i][j]: continue bfs(i, j) cnt+=1 print(cnt) 城堡问题 import sys from collections import deque input = lambda:sys.stdin.readline().strip() N = 55 g = [] vis = [[False]*N for _ in range(N)] area = 0 cnt=0 def bfs(x, y): vis[x][y]=True q = deque() q.append((x, y)) dx, dy = [0, -1, 0, 1], [-1, 0, 1, 0] ans=1 while q: tx, ty = q.popleft() for i in range(4): xx = tx+dx[i] yy = ty+dy[i] if xx\u0026lt;0 or xx\u0026gt;=n or yy\u0026lt;0 or yy\u0026gt;=m or vis[xx][yy]: continue if (g[tx][ty]\u0026gt;\u0026gt;i)\u0026amp;1: continue ans+=1 vis[xx][yy]=True q.append((xx,yy)) return ans n, m = map(int, input().split()) for _ in range(n): g.append(list(map(int, input().split()))) for i in range(n): for j in range(m): if vis[i][j]: continue area = max(area, bfs(i, j)) cnt+=1 print(cnt) print(area) 山峰和山谷 import sys from collections import deque N = 1010 g = [] vis = [[0]*N for _ in range(N)] pek, val = 0, 0 def bfs(x, y): global higher, lower vis[x][y]=True q = deque() q.append((x,y)) while q: tx,ty = q.popleft() for i in range(-1, 2): for j in range(-1, 2): if i==0 and j==0: continue xx, yy = tx+i, ty+j if xx\u0026lt;0 or xx\u0026gt;=n or yy\u0026lt;0 or yy\u0026gt;=n: continue if g[xx][yy]!=g[tx][ty]: if g[xx][yy]\u0026gt;g[tx][ty]: higher=True elif g[xx][yy]\u0026lt;g[tx][ty]: lower=True elif not vis[xx][yy]: vis[xx][yy]=True q.append((xx,yy)) higher, lower = False, False n = int(input()) for _ in range(n): g.append(list(map(int, input().split()))) # print(g) for i in range(n): for j in range(n): if vis[i][j]: continue higher, lower = False, False bfs(i, j) if not higher:pek+=1 if not lower:val+=1 print(pek, val) BFS P1038 [NOIP2003 提高组] 神经网络 题目大意：兰兰提出了一个神经网络模型，该模型可以表示为一个有向图，图中的节点称为神经元，节点之间的连接代表神经元之间的联系。神经元按照一定的顺序排列，构成整个神经网络。每个神经元都有一个状态和阈值，当神经元处于兴奋状态时，会向其他神经元传送信号。\n实现思路：\n首先，根据输入的网络结构信息，构建神经元之间的连接关系。使用字典g来表示神经元之间的连接关系，以及字典wei来表示连接神经元之间的边的权值。 然后，根据输入的初始状态和阈值信息，初始化神经元的状态。同时，记录输入层神经元的初始状态，如果神经元的状态不为0，则将其加入队列q中。 利用广度优先搜索（BFS）算法，遍历神经元，根据模型公式更新每个神经元的状态。同时，更新神经元的状态时，考虑到边的权值以及神经元的阈值。 最后，输出输出层神经元的状态。如果输出层神经元的最后状态均小于等于0，则输出\u0026quot;NULL\u0026quot;，否则按照编号从小到大顺序输出输出层神经元的状态。 from collections import deque, defaultdict maxn = 1e3 + 10 c = [0] * int(maxn) u = [0] * int(maxn) wei = defaultdict(lambda: defaultdict(int)) vis = [False] * int(maxn) beginer = [False] * int(maxn) g = defaultdict(list) n, p = map(int, input().split()) en = [] q = deque() for i in range(1, n + 1): c[i], u[i] = map(int, input().split()) if c[i] != 0: q.append(i) beginer[i] = True else: en.append(i) if not en: for i in range(1, n + 1): print(i, c[i]) exit() for _ in range(p): s, e, w = map(int, input().split()) g[s].append(e) wei[s][e] = w while q: t = q.popleft() if not beginer[t]: c[t] -= u[t] base = c[t] if base \u0026gt; 0: for j in g[t]: c[j] += base * wei[t][j] if not vis[j]: q.append(j) vis[j] = True ans = 0 for i in en: if c[i] \u0026gt; 0 and not g[i]: print(i, c[i]) ans += 1 if not ans: print(\u0026#34;NULL\u0026#34;) ","permalink":"https://showguan.github.io/en/posts/tech/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E4%BA%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84python%E5%AE%9E%E7%8E%B0/","summary":"算法笔记（二）——数据结构(Python实现) 数据结构 单链表 N = int(1e5+10) e=[0]*N ne=[0]*N head=-1 idx=1 def insert(x): global idx, head e[idx]=x ne[idx]=head head=idx idx+=1 def add(k, x): global idx e[idx]=x ne[idx]=ne[k] ne[k]=idx idx+=1 def remove(k): global idx, head if k==0: head = ne[head] else: ne[k]=ne[ne[k]] n = int(input())","title":"算法笔记（二）——数据结构(Python实现)"},{"content":"算法笔记（五）——DP（Python实现） DP 数字三角形 f=[] n=int(input()) for _ in range(n): f.append([int(x) for x in input().split()]) for i in range(n-2,-1,-1): for j in range(i+1): f[i][j]=max(f[i+1][j], f[i+1][j+1])+f[i][j] print(f[0][0]) 背包 空间优化成1维之后，只有完全背包问题的体积是从小到大循环的\n01背包 N = int(1e3+10) f=[ 0 for _ in range(N) ] n,v=map(int,input().split()) for i in range(n): vi,wi=map(int,input().split()) for j in range(v, vi-1,-1): f[j]=max(f[j],f[j-vi]+wi) print(f[v]) 多重背包 单调队列 MN = int(2e4+10) f=[0 for _ in range(MN)] q=[0 for _ in range(MN)] g=[0 for _ in range(MN)] N,V = map(int, input().split()) for i in range(N): v,w,s=map(int, input().split()) g=f[:] for j in range(v): hh,tt=0,-1 for k in range(j,V+1,v): while hh\u0026lt;=tt and q[hh]\u0026lt;k-s*v: hh+=1 while hh\u0026lt;=tt and g[q[tt]]+(k-q[tt])//v*w \u0026lt;= g[k]: tt-=1 tt+=1 q[tt]=k f[k]=g[q[hh]]+(k-q[hh])//v*w print(f[V]) 二维费用背包 N = int(1e2+10) f=[[0]*N for _ in range(N)] n,V,M = map(int , input().split()) for i in range(n): v,m,w=map(int , input().split()) for j in range(V,v-1,-1): for k in range(M, m-1, -1): f[j][k]=max(f[j][k], f[j-v][k-m]+w) print(f[V][M]) 宠物小精灵 题目大意：小智在野外捕捉宠物小精灵，他带了一些精灵球和皮卡丘，精灵球可以捕捉小精灵，但每捕捉一个小精灵都会消耗精灵球和减少皮卡丘的体力。现在给定小智拥有的精灵球数量、皮卡丘的初始体力值以及每个小精灵需要的精灵球数量和对皮卡丘造成的伤害数目，问小智最多能捕捉多少个小精灵，并且在这种情况下，皮卡丘的剩余体力值最多是多少。\n实现思路：\n使用动态规划，定义状态 f[i][j] 表示使用 i 个精灵球时，对皮卡丘造成 j 伤害时能够捕捉到的小精灵数量。 遍历每个野生小精灵，更新状态数组 f。 最后输出 f[n][m-1] 表示捕捉到的小精灵数量，然后再计算皮卡丘的剩余体力值。 N = int(1e3+10) M = int(5e2+10) f=[[0]*M for _ in range(N)] n,m,kk = map(int, input().split()) for i in range(kk): v1,v2=map(int, input().split()) for j in range(n, v1-1, -1): for k in range(m-1,v2-1,-1): f[j][k]=max(f[j][k], f[j-v1][k-v2]+1) print(f[n][m-1], end=\u0026#34; \u0026#34;) t=m-1 while t\u0026gt;0 and f[n][m-1]==f[n][t-1]: t-=1 print(m-t) 潜水 最多\n恰好\n最少\n题目大意：潜水员需要使用特殊装备下潜，装备有两种气缸，一种氧气，一种氮气，每个气缸有一定的重量和气体容量。下潜的深度需要一定数量的氧气和氮气。现在给定潜水员需要的氧气和氮气的量，以及每个气缸的氧气、氮气容量和重量，求完成工作所需气缸的总重的最低值。\n实现思路：\n使用动态规划，定义状态 f[i][j] 表示满足氧气需求为 i，氮气需求为 j 时的最小气缸总重量。 遍历每个气缸，更新状态数组 f。 最后输出 f[m][n] 表示完成工作所需的气缸的总重的最低值。 N = int(1e2+10) INF = 0x3f3f3f3f f=[ [INF]*N for _ in range(N) ] f[0][0]=0 m,n=map(int, input().split()) k=int(input()) for i in range(k): a,b,c=map(int, input().split()) for j in range(m,-1,-1): for k in range(n,-1,-1): f[j][k]=min(f[j][k], f[max(j-a, 0)][max(k-b, 0)]+c) print(f[m][n]) 庆功会 题目大意：为了庆祝班级在学校运动会上取得第一名，班主任决定开一场庆功会，并拨款购买奖品犒劳运动员。需要选择购买的奖品，使得购买的奖品的总价值最大，且不超过拨款金额。\n实现思路：\n使用动态规划，定义状态 f[i] 表示拨款金额为 i 时可以购买的奖品的最大总价值。 遍历每个奖品，更新状态数组 f。 最后输出 f[m]，即拨款金额为 m 时可以购买的奖品的最大总价值。 N = int(6e3+10) f=[0 for _ in range(N)] n,m = map(int, input().split()) for i in range(n): v,w,s=map(int, input().split()) for j in range(1,s+1): for k in range(m, v-1, -1): f[k]=max(f[k], f[k-v]+w) print(f[m]) 分组背包 分组背包的顺序：\n物品组 体积 决策 N = int(1e2+10) f=[0 for _ in range(N)] v=[0 for _ in range(N)] w=[0 for _ in range(N)] N,V = map(int, input().split()) for i in range(N): # 物品组 s=int(input()) for j in range(s): v[j],w[j]=map(int, input().split()) for j in range(V,-1,-1): #体积 for k in range(s): #决策 if j\u0026gt;=v[k]: f[j]=max(f[j], f[j-v[k]]+w[k]) print(f[V]) 机器分配 多重背包变种\n题目大意：总公司有M台相同的高效设备，要分给N个分公司。每个分公司根据分配的设备数量能够为国家带来一定的盈利。问如何分配这M台设备才能使国家得到的盈利最大，输出最大盈利值和分配方案。\n实现思路：这是一个经典的背包问题，可以使用动态规划来解决。定义状态dp[i][j]表示前i个分公司中，分配j台设备所能获得的最大盈利。转移方程为dp[i][j] = max(dp[i-1][j-k] + w[i][k])，其中k表示第i个分公司分配的设备数量，0 \u0026lt;= k \u0026lt;= j。最后遍历求解得到最大盈利值，并记录分配方案。\nN = 100 f=[0 for _ in range(N)] w=[[0]*N for _ in range(N)] c=[[0]*N for _ in range(N)] n,m=map(int, input().split()) for i in range(n): w[i]=[0]+[int(x) for x in input().split()] for i in range(n): for j in range(m,-1,-1): for k in range(1,j+1): if f[j-k]+w[i][k] \u0026gt; f[j]: f[j]=f[j-k]+w[i][k] c[i][j]=k print(f[m]) t=m for i in range(n-1,-1,-1): print(i+1, c[i][t]) t-=c[i][t] 金明的预算方案 题目描述：金明想购买物品，其中有主件和附件。每个主件可以有0个、1个或2个附件，附件不能有从属于自己的附件。金明希望在不超过N元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。物品的价格都是10元的整数倍。\n实现思路：这个问题可以使用动态规划来解决。首先，需要将主件和附件分开处理。对于每一个物品，分别考虑不同附件数量的情况，计算可能的价格与重要度乘积的总和，然后更新动态规划数组f。最终，返回f[n]即可得到结果。\nN = 80 M = 32010 f=[0 for _ in range(M)] mas=[[0,0] for _ in range(N)] ser=[[] for _ in range(N)] n,m=map(int,input().split()) for i in range(1,m+1): v,p,q=map(int, input().split()) if q==0: mas[i]=[v,v*p] else: ser[q].append((v, v*p)) for i in range(1,m+1): for j in range(n, -1, -1): for k in range( (1 \u0026lt;\u0026lt; len(ser[i]) )): v,p=mas[i] for l in range(len(ser[i])): if k\u0026gt;\u0026gt;l \u0026amp; 1: v+=ser[i][l][0] p+=ser[i][l][1] if j\u0026gt;=v: f[j]=max(f[j], f[j-v]+p) print(f[n]) 摘花生 N = 105 f=[ [0]*N for _ in range(N)] t=int(input()) for _ in range(t): r,c=map(int, input().split()) for i in range(1,r+1): f[i] = [0] + [int(x) for x in input().split()] for j in range(1,c+1): f[i][j]+=max(f[i-1][j], f[i][j-1]) print(f[r][c]) 最小通行费 N = int(1e3+10) INF = 0x3f3f3f3f f = [[INF]*N for _ in range(N)] f[1][0]=f[0][1]=0 n=int(input()) for i in range(1,n+1): f[i]=[INF]+[int(x) for x in input().split()] for i in range(1,n+1): for j in range(1,n+1): f[i][j]+=min(f[i-1][j],f[i][j-1]) print(f[n][n]) 方格 N = 15 g = [[0]*N for _ in range(N)] f = [[[[0]*N for _ in range(N)] for _ in range(N)] for _ in range(N)] n=int(input()) while True: r,c,x=map(int,input().split()) if r==0 and c==0 and x==0: break g[r][c]=x for i in range(1,n+1): for j in range(1,n+1): for k in range(1,n+1): for l in range(1,n+1): if i==k and j==l: f[i][j][k][l] = max(f[i-1][j][k-1][l], f[i-1][j][k][l-1], f[i][j-1][k-1][l], f[i][j-1][k][l-1]) + g[i][j] else: f[i][j][k][l] = max(f[i-1][j][k-1][l], f[i-1][j][k][l-1], f[i][j-1][k-1][l], f[i][j-1][k][l-1]) + g[i][j] + g[k][l] print(f[n][n][n][n]) N = 55 g=[[0]*N for _ in range(N)] f=[[[[0]*N for _ in range(N)] for _ in range(N)] for _ in range(N)] m,n=map(int, input().split()) for i in range(1,m+1): g[i]=[0]+[int(x) for x in input().split()] for i in range(1,m+1): for j in range(1,n+1): for k in range(1,m+1): for l in range(1,n+1): if i==k and j==l: f[i][j][k][l]=max(f[i-1][j][k-1][l], f[i-1][j][k][l-1], f[i][j-1][k-1][l], f[i][j-1][k][l-1])+g[i][j] else: f[i][j][k][l]=max(f[i-1][j][k-1][l], f[i-1][j][k][l-1], f[i][j-1][k-1][l], f[i][j-1][k][l-1])+g[i][j]+g[k][l] print(f[m][n][m][n]) LIS \u0026amp; LCS LIS N=int(1e3+10) f=[1 for _ in range(N)] a=[] n=int(input()) a=[0]+[int(x) for x in input().split()] for i in range(1,n+1): for j in range(1,i): if a[i]\u0026gt;a[j]: f[i]=max(f[i],f[j]+1) ans = 0 for i in range(1,n+1): ans = max(ans, f[i]) print(ans) LCS N = int(1e3+10) f=[[0]*N for _ in range(N)] a=\u0026#34;\u0026#34; b=\u0026#34;\u0026#34; n,m=map(int, input().split()) a=input() b=input() for i in range(n): for j in range(m): f[i][j]=max(f[i-1][j], f[i][j-1]) if a[i]==b[j]: f[i][j]=f[i-1][j-1]+1 print(f[n-1][m-1]) 最大上升子序列和 import copy a=[] f=[] ans=0 n=int(input()) a=[int(x) for x in input().split()] f=copy.deepcopy(a) for i in range(n): for j in range(i): if a[i]\u0026gt;a[j]: f[i]=max(f[i], f[j]+a[i]) for i in range(n): ans = max(ans, f[i]) print(ans) N = int(1e3+10) f=[0 for _ in range(N)] ans = 0 n=int(input()) a=[0]+[int(x) for x in input().split()] for i in range(1,n+1): f[i]=a[i] for j in range(1,i): if a[i]\u0026gt;a[j]: f[i]=max(f[i], f[j]+a[i]) ans = max(ans, f[i]) print(ans) 最大上升子序列II N = int(1e5+10) INF = 0x3f3f3f3f q=[INF for _ in range(N)] ans=0 n=int(input()) a=[0]+[int(x) for x in input().split()] for i in range(1,n+1): l,r=0,i while l\u0026lt;r: mid = (l+r+1)\u0026gt;\u0026gt;1 if q[mid]\u0026lt;a[i]: l=mid else: r=mid-1 ans = max(ans, l+1) q[l+1]=min(q[l+1], a[i]) print(ans) N = int(1e5+10) q=[0 for _ in range(N)] len = 0 n=int(input()) a=[0]+[int(x) for x in input().split()] for i in range(1, n+1): l,r=0,len while l\u0026lt;r: mid = (l+r+1)\u0026gt;\u0026gt;1 if q[mid]\u0026lt;a[i]: l=mid else: r=mid-1 len=max(len, l+1) q[l+1]=a[i] print(len) N = int(1e5+10) q=[0 for _ in range(N)] len = 0 n=int(input()) a=[0]+[int(x) for x in input().split()] for i in range(1,n+1): l,r=0,len while l\u0026lt;r: mid = (l+r+1)\u0026gt;\u0026gt;1 if q[mid]\u0026gt;=a[i]: r=mid-1 else: l=mid len = max(len, l+1) q[l+1]=a[i] print(len) 二分原则：\n有单调性，并且二分之后能保持单调性\n怪盗基德的滑翔翼 **题意：**怪盗基德需要逃跑，城市中有N幢建筑排成一条线，每幢建筑的高度各不相同。他希望尽可能多地经过不同建筑的顶部，以减缓下降时的冲击力，减少受伤的可能性。他可以选择一个方向逃跑，但不能中途改变方向，且只能从较高的建筑滑翔到较低的建筑。怪盗基德最多可以经过多少幢不同建筑的顶部（包含初始时的建筑）。\n**实现思路：**可以使用动态规划来解决。首先，对于每一座建筑，分别计算以该建筑为终点的最长递增子序列长度，得到从左往右和从右往左的两个最长递增子序列数组。然后将这两个数组对应位置的最大值相加，再减去1（因为初始位置也算一座建筑），即为怪盗基德最多可以经过的不同建筑数量。\nN = int(1e3+10) f=[0 for _ in range(N)] t=int(input()) while t: t-=1 ans=0 n=int(input()) a=[0]+[int(x) for x in input().split()] for i in range(1,n+1): f[i]=1 for j in range(1,i): if a[i]\u0026gt;a[j]: f[i]=max(f[i], f[j]+1) ans = max(ans, f[i]) for i in range(n,0,-1): f[i]=1 for j in range(n,i,-1): if a[i]\u0026gt;a[j]: f[i]=max(f[i], f[j]+1) ans = max(ans, f[i]) print(ans) 登山 N = int(1e3+10) f=[1 for _ in range(N)] g=[1 for _ in range(N)] ans = 0 n=int(input()) a=[0]+[int(x) for x in input().split()] for i in range(1,n+1): for j in range(1,i): if a[i]\u0026gt;a[j]: f[i]=max(f[i], f[j]+1) for i in range(n,0,-1): for j in range(n,i,-1): if a[i]\u0026gt;a[j]: g[i]=max(g[i], g[j]+1) for i in range(1,n+1): ans = max(ans, f[i]+g[i]-1) print(ans) 合唱队形 N = int(1e3+10) f=[1 for _ in range(N)] g=[1 for _ in range(N)] ans = 0 n=int(input()) a=[0]+[int(x) for x in input().split()] for i in range(1,n+1): for j in range(1,i): if a[i]\u0026gt;a[j]: f[i]=max(f[i], f[j]+1) for i in range(n,0,-1): for j in range(n,i,-1): if a[i]\u0026gt;a[j]: g[i]=max(g[i], g[j]+1) for i in range(1,n+1): ans = max(ans, f[i]+g[i]-1) print(n-ans) 友好城市 N = int(5e3+10) a=[(-1,-1)] f=[1 for _ in range(N)] ans = 0 n=int(input()) for i in range(n): x,y=map(int, input().split()) a.append((x,y)) a.sort(key=lambda x:x[0]) for i in range(1,n+1): for j in range(1,i): if a[i][1]\u0026gt;a[j][1]: f[i]=max(f[i], f[j]+1) ans = max(f[i], ans) print(ans) 拦截导弹 贪心证明\n题意：某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统，但有缺陷：每一发炮弹都不能高于前一发的高度。给定导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，并且如果要拦截所有导弹，最少需要配备多少套这种导弹拦截系统。\n实现思路：首先使用动态规划求解最多能拦截的导弹数，然后再利用贪心算法求解最少需要配备的系统数。具体实现时，先从左往右依次计算每个位置能拦截的最大导弹数，然后再从右往左依次计算每个位置能拦截的最大导弹数。接着，利用贪心算法，遍历导弹高度，如果当前高度大于已有系统的高度，则增加系统数；否则，更新已有系统的高度。最终得到最多能拦截的导弹数和最少需要配备的系统数。\nN = int(1e3+10) f=[1 for _ in range(N)] g=[0 for _ in range(N)] ans = 0 cnt = 0 a=[0]+[int(x) for x in input().split()] n=len(a) for i in range(n-1,0,-1): for j in range(n-1,i,-1): if a[i]\u0026gt;=a[j]: f[i]=max(f[i], f[j]+1) ans = max(ans, f[i]) print(ans) for i in range(1, n): k=0 while k\u0026lt;cnt and g[k]\u0026lt;a[i]: k+=1 if k\u0026gt;=cnt: cnt+=1 g[k]=a[i] print(cnt) 导弹防御系统 **题意：**R国更新了导弹防御系统，一套系统的导弹拦截高度要么一直严格单调上升，要么一直严格单调下降。给定即将袭来的一系列导弹的高度，请你求出至少需要多少套防御系统，才能将它们全部击落。\n**实现思路：**可以利用深度优先搜索（DFS）来解决。首先定义两个数组up和down，分别表示上升序列和下降序列。然后使用DFS进行状态搜索，每次尝试将当前导弹加入上升序列或下降序列，并更新当前的防御系统数量。最终得到至少需要的防御系统数量。代码中的dfs函数用于进行状态搜索，尝试将当前导弹加入上升序列或下降序列，并递归调用下一个导弹的处理。最终输出最少需要的防御系统数量。\nN = int(1e2+10) up=[0 for _ in range(N)] down=[0 for _ in range(N)] ans=0 def dfs(u, su, sd): global ans if su + sd\u0026gt;=ans: return if u==n: ans=su+sd return k=0 while k\u0026lt;su and up[k]\u0026gt;=a[u]: k+=1 t=up[k] up[k]=a[u] if k\u0026gt;=su: dfs(u+1, su+1, sd) else: dfs(u+1, su, sd) up[k]=t k=0 while k\u0026lt;sd and down[k]\u0026lt;=a[u]: k+=1 t=down[k] down[k]=a[u] if k\u0026gt;=sd: dfs(u+1, su, sd+1) else: dfs(u+1, su, sd) down[k]=t while True: n=int(input()) ans = n if n==0: break a=[int(x) for x in input().split()] dfs(0,0,0) print(ans) 最长公共上升子序列 题意：熊大妈的奶牛们在小沐沐的指导下研究了最长公共上升子序列，即两个数列中都包含一段位置不一定连续的严格递增的数段，要求找出最长的这样的子序列。现在你需要告诉奶牛们最长公共上升子序列的长度。\n实现思路：可以使用动态规划来解决。定义一个二维数组f，其中f[i][j]表示数列A的前i个元素和数列B的前j个元素中，以数列A的第i个元素和数列B的第j个元素结尾的最长公共上升子序列的长度。然后使用动态规划的方式填表，最终找出最长的公共上升子序列的长度。\n代码中的f[i][j]的状态转移方程如下：\n如果a[i]等于b[j]，则f[i][j]等于f[i-1][j-1]+1（表示在a[i]和b[j]相等的情况下可以构成更长的公共上升子序列）。\n如果a[i]大于b[j]，则f[i][j]等于f[i-1][j]（表示a[i]不在公共上升子序列中）。\n否则，f[i][j]等于f[i][j-1]（表示b[j]不在公共上升子序列中）。\nN = int(3e3+10) f=[[0]*N for _ in range(N)] ans=0 n=int(input()) a=[0]+[int(x) for x in input().split()] b=[0]+[int(x) for x in input().split()] for i in range(1,n+1): maxv=1 for j in range(1,n+1): f[i][j]=f[i-1][j] if a[i]==b[j]: f[i][j]=max(f[i][j], maxv) if a[i]\u0026gt;b[j]: maxv=max(maxv, f[i][j]+1) for i in range(1,n+1): ans = max(ans, f[n][i]) print(ans) 状态机模型 闫氏DP分析法——状态机分析法\n大盗阿福 N = int(1e5+10) t=int(input()) while t: t-=1 f=[[0]*2 for _ in range(N)] n=int(input()) a=[0]+[int(x) for x in input().split()] f[1][0]=0 f[1][1]=a[1] for i in range(2,n+1): f[i][0]=max(f[i-1][1],f[i-1][0]) f[i][1]=max(f[i-1][0], f[i-2][1])+a[i] print(max(f[n][0], f[n][1])) 买卖股票 IV 题目大意：给定一个长度为n的数组，表示一个给定股票在n天内的价格。设计一个算法，计算可以获取的最大利润，最多可以完成k笔交易。每次买入卖出合为一笔交易，且不能同时参与多笔交易。\n实现思路：\n使用动态规划解决该问题，定义一个三维数组f，其中f[i][j][0]表示第i天，已完成j笔交易，并且手上没有股票时的最大利润；f[i][j][1]表示第i天，已完成j笔交易，并且手上有股票时的最大利润。 初始化数组f，将所有位置的利润初始化为负无穷-INF，表示不可达。 遍历股票价格数组，使用动态规划递推出f[i][j][0]和f[i][j][1]，即在第i天已完成j笔交易时的最大利润。 最终，取f[n][k][0]中的最大值作为最终结果，表示第n天已完成k笔交易，并且手上没有股票时的最大利润。 代码实现已给出，其中使用了两重循环来填充动态规划数组f，时间复杂度为O(nk)，因为n的最大值为10^5，k的最大值为100，所以算法的时间复杂度为可接受的范围内。\n这个算法的核心思想是利用动态规划逐步计算出在每一天已完成一定数量交易时的最大利润，然后根据问题要求取得最优解。\nK = 110 INF = 0x3f3f3f3f f=[[[-INF]*2 for _ in range(K)] for _ in range(2)] n,k = map(int ,input().split()) w=[0]+[int(x) for x in input().split()] f[1][0][0]=0 t=0 for i in range(1,n+1): for j in range(k+1): f[t][j][0]=max(f[t^1][j][0], f[t^1][j][1]+w[i]) f[t][j][1]=max(f[t^1][j][1], f[t^1][j-1][0]-w[i]) t^=1 res =max(f[t^1][i][0] for i in range(k+1)) print(res) 股票交易V 题目大意：给定一个整数数组prices，其中第i天的股票价格为prices[i]。设计一个算法计算出在满足约束条件下可以获取的最大利润。约束条件为：卖出股票后，你无法在第二天买入股票（即冷冻期为1天），且不能同时参与多笔交易（必须在再次购买前出售掉之前的股票）。\n实现思路：\n使用动态规划解决该问题，定义一个二维数组f，其中f[i][j]表示第i天的交易状态为j时的最大利润，j有三种状态：0表示持有股票，1表示不持有股票且处于冷冻期，2表示不持有股票且不处于冷冻期。 初始化数组f，将所有位置的利润初始化为负无穷-INF，表示不可达。并且将f[0][2]初始化为0，表示第0天结束时，不持有股票且不处于冷冻期时的最大利润为0。 遍历股票价格数组，使用动态规划递推出f[i][j]，即在第i天的交易状态为j时的最大利润。 最终，取f[n][1]和f[n][2]中的最大值作为最终结果，表示最后一天结束时的最大利润。 代码实现已给出，其中使用了一重循环来填充动态规划数组f，时间复杂度为$O(n)$，因为n的最大值为5000，所以算法的时间复杂度为可接受的范围内。\n这个算法的核心思想是利用动态规划逐步计算出在每一天不同交易状态下的最大利润，然后根据问题要求取得最优解。\nN = int(1e5+10) INF = 0x3f3f3f3f f=[[-INF]*3 for _ in range(N)] n=int(input()) w=[0]+[int(x) for x in input().split()] f[0][2]=0 for i in range(1,n+1): f[i][0]=max(f[i-1][0], f[i-1][2]-w[i]) f[i][1]=f[i-1][0]+w[i] f[i][2]=max(f[i-1][1], f[i-1][2]) print(max(f[n][1], f[n][2])) P1220 关路灯 题意：这个问题是关于优化老张关灯顺序以最小化总功耗的。老张每次在天亮时首先关掉自己所处位置的路灯，然后可以向左或向右关灯。为了最小化总功耗，需要找到一个最优的关灯顺序。\n实现思路：\n首先，我们可以使用动态规划来解决这个问题。我们定义一个三维数组f，其中f[i][j][k]表示从第i盏灯到第j盏灯，老张最后一个关灯位置在第k盏灯时的最小功耗。 然后，我们初始化数组f，将所有位置的功耗都初始化为无穷大INF，表示不可达。 对于每一对路灯i和j，我们通过动态规划递推出f[i][j][0]和f[i][j][1]，分别表示老张从左边或右边走到位置i到j的最小功耗。 最后，我们只需比较f[1][n][0]和f[1][n][1]，取其中较小的值作为最终答案。 使用了三重循环来填充动态规划数组f，时间复杂度为$O(n^3)$，因为n的最大值为50，所以算法的时间复杂度为可接受的范围内。这个算法的核心思想是利用动态规划逐步计算出老张从左或右关灯到达每个位置的最小功耗，然后比较两种情况下的最小功耗，找到最优解。\nmaxn = int(8e2) + 100 INF = 0x3f3f3f3f f = [[[INF] * 2 for _ in range(maxn)] for _ in range(maxn)] a = [0] * (maxn + 1) w = [0] * (maxn + 1) sum = [0] * (maxn + 1) n, r = map(int, input().split()) for i in range(1, n + 1): a[i], w[i] = map(int, input().split()) sum[i] = sum[i - 1] + w[i] f[r][r][0] = f[r][r][1] = 0 for i in range(2, n + 1): for j in range(1, n - i + 2): l = j + i - 1 f[j][l][0] = min(f[j + 1][l][0] + (a[j + 1] - a[j]) * (sum[j] + sum[n] - sum[l]), f[j + 1][l][1] + (a[l] - a[j]) * (sum[j] + sum[n] - sum[l])) f[j][l][1] = min(f[j][l - 1][0] + (a[l] - a[j]) * (sum[j - 1] + sum[n] - sum[l - 1]), f[j][l - 1][1] + (a[l] - a[l - 1]) * (sum[j - 1] + sum[n] - sum[l - 1])) ans = min(f[1][n][0], f[1][n][1]) print(ans) 状态压缩DP 小国王 N = 13 M = 1\u0026lt;\u0026lt;N K = 110 state=[] h=[[] for _ in range(M)] cnt = [0]*M f=[[[0]*M for _ in range(K)] for _ in range(N)] def check(x): global n for i in range(n): if (x\u0026gt;\u0026gt;i)\u0026amp;1 and (x\u0026gt;\u0026gt;i+1)\u0026amp;1: return False return True def count(x): global n cnt=0 for i in range(n): if (x\u0026gt;\u0026gt;i)\u0026amp;1: cnt+=1 return cnt n,m = map(int, input().split()) for i in range(1\u0026lt;\u0026lt;n): if check(i): state.append(i) cnt[i]=count(i) for i in range(len(state)): for j in range(len(state)): a = state[i] b = state[j] if (a\u0026amp;b)==0 and check(a|b): h[i].append(j) f[0][0][0]=1 for i in range(1,n+2): for j in range(m+1): for k in range(len(state)): for t in h[k]: c = cnt[state[k]] if j\u0026gt;=c: f[i][j][state[k]]+=f[i-1][j-c][state[t]] print(f[n+1][m][0]) 愤怒的小鸟 eps = 1e-6 N = 18 M = 1\u0026lt;\u0026lt;18 INF = 0x3f3f3f3f def cmp(a,b): if abs(a-b)\u0026lt;eps: return 0 if a\u0026gt;b: return 1 return -1 t = int(input()) for _ in range(t): f = [INF]*M path = [[0]*N for _ in range(N)] q = [0]*N n,m = map(int, input().split()) for i in range(n): x,y = map(float, input().split()) q[i]=(x,y) for i in range(n): path[i][i]=1\u0026lt;\u0026lt;i #关键点：与其他点的抛物线可能都不合法，所以需要独立出一条抛物线 for j in range(n): x1,y1 = q[i] x2,y2 = q[j] if cmp(x1,x2)==0: continue a = (y1/x1-y2/x2)/(x1-x2) if cmp(a,0)\u0026gt;=0: continue b = y1/x1-a*x1 state=0 for k in range(n): x3,y3 = q[k] if cmp(a*x3*x3+b*x3, y3) == 0: state+=(1\u0026lt;\u0026lt;k) path[i][j]=state f[0]=0 for i in range(1\u0026lt;\u0026lt;n): for j in range(n): if not (i\u0026gt;\u0026gt;j)\u0026amp;1: x=j break for j in range(n): f[i | path[x][j]] = min(f[i | path[x][j]], f[i]+1) print(f[(1\u0026lt;\u0026lt;n)-1]) 集合类状态压缩DP 最短Hamilton距离 N = 22 M = 1\u0026lt;\u0026lt;20 INF = 0x3f3f3f3f f=[[INF]*N for _ in range(M)] w=[[]*N for _ in range(N)] n=int(input()) for i in range(n): w[i]=[int(_) for _ in input().split()] f[1][0]=0 for i in range(1\u0026lt;\u0026lt;n): for j in range(n): if i\u0026gt;\u0026gt;j\u0026amp;1: for k in range(n): if i\u0026gt;\u0026gt;k\u0026amp;1: f[i][j]=min(f[i][j], f[i-(1\u0026lt;\u0026lt;j)][k]+w[k][j]) print(f[(1\u0026lt;\u0026lt;n)-1][n-1]) 区间DP 石子合并 N = 1010 INF = 0x3f3f3f3f f=[[INF]*N for _ in range(N)] s=[0]*N n = int(input()) a=[0]+[int(_) for _ in input().split()] for i in range(1,n+1): f[i][i]=0 s[i]=s[i-1]+a[i] for l in range(2,n+1): for i in range(1,n-l+2): j=i+l-1 for k in range(i,j): f[i][j] = min(f[i][j], f[i][k] + f[k+1][j] + s[j]-s[i-1]) print(f[1][n]) 环形石子合并 N = 410 w=[0]*N s=[0]*N INF = 0x3f3f3f3f f=[[-INF]*N for _ in range(N)] g=[[INF]*N for _ in range(N)] n=int(input()) a= [0]+[int(_) for _ in input().split()] for i in range(1,n+1): w[i] = w[i+n] = a[i] for i in range(1,n*2+1): s[i]=s[i-1]+w[i] for l in range(1,n+1): for i in range(1,n*2-l+2): j=i+l-1 if l==1: f[i][j]=g[i][j]=0 for k in range(i,j): f[i][j] = max(f[i][j], f[i][k]+f[k+1][j]+s[j]-s[i-1]) g[i][j] = min(g[i][j], g[i][k]+g[k+1][j]+s[j]-s[i-1]) minv, maxv = INF, -INF for i in range(1,n+1): minv = min(minv, g[i][i+n-1]) maxv = max(maxv, f[i][i+n-1]) print(minv, maxv, sep=\u0026#39;\\n\u0026#39;) 能量项链 N = 210 w=[0]*N f=[[0]*N for _ in range(N)] n = int(input()) a=[0]+[int(_) for _ in input().split()] for i in range(1,n+1): w[i]=w[i+n]=a[i] for l in range(3,n+2): for i in range(1,n*2-l+2): j=i+l-1 for k in range(i+1,j): f[i][j] = max(f[i][j], f[i][k]+f[k][j]+w[i]*w[k]*w[j]) maxv = -1 for i in range(1,n+1): maxv = max(maxv, f[i][i+n]) print(maxv) 凸多边形的划分 N = 55 INF = 1e30 f=[[INF]*N for _ in range(N)] n = int(input()) w=[0]+[int(_) for _ in input().split()] for i in range(1,n+1): f[i][i+1]=0 for l in range(3,n+1): for i in range(1, n-l+2): j=i+l-1 for k in range(i+1,j): f[i][j] = min(f[i][j], f[i][k]+f[k][j]+w[i]*w[k]*w[j]) print(f[1][n]) 加分二叉树 N = 50 def dfs(l, r): if l\u0026gt;r: return k=root[l][r] print(k,end=\u0026#39; \u0026#39;) dfs(l,k-1) dfs(k+1,r) n = int(input()) w = [0]+[int(_) for _ in input().split()] f=[[0]*N for _ in range(N)] root=[[0]*N for _ in range(N)] for l in range(1,n+1): for i in range(1,n-l+2): j=i+l-1 for k in range(i,j+1): left = 1 if k==i else f[i][k-1] right = 1 if k==j else f[k+1][j] s = left*right+w[k] if i==j: s=w[k] if f[i][j]\u0026lt;s: f[i][j]=s root[i][j]=k print(f[1][n]) dfs(1,n) 树形DP 树的最长路径 注意注意再注意，while循环链不符合要求是需要 i=ne[i]\nimport sys sys.setrecursionlimit(int(1e5+10)) N = 10010*2 e = [0]*N ne = [0]*N w = [0]*N h = [-1]*N idx = 1 ans = -1 def add(a, b, c): global idx e[idx]=b w[idx]=c ne[idx]=h[a] h[a]=idx idx+=1 def dfs(root, father): global ans dis, d1, d2 = 0,0,0 i=h[root] while i!=-1: j = e[i] if j==father: i=ne[i] # 重点 continue d = dfs(j, root)+w[i] dis = max(dis, d) if d\u0026gt;d1: d2=d1 d1=d else: d2 = max(d2, d) i=ne[i] ans = max(ans, d1+d2) return dis n = int(input()) for i in range(n-1): a,b,c = map(int, input().split()) add(a,b,c) add(b,a,c) dfs(1,-1) print(ans) 树的中心 题目大意：给定一棵包含 n 个节点的树，每条边都有一个权值。要求在树中找到一个点，使得该点到树中其他节点的最远距离最近。\n实现思路：\n构建无向图的邻接表，其中每个节点对应一个链表，存储其相邻的节点以及对应的边权值。 使用 DFS 遍历树，分别计算每个节点到其他节点的最长距离 d1 和次长距离 d2，并记录其相邻节点 s1。 再次使用 DFS 遍历树，计算每个节点到其相邻节点的最长距离 up。 最后，遍历所有节点，求出所有节点中最大的 max(up[i], d1[i])，即为所求的最近距离。 N = 10010*2 e = [0]*N ne=[0]*N h=[-1]*N w=[0]*N d1=[0]*N d2=[0]*N s1=[0]*N up=[0]*N idx = 1 def add(a,b,c): global idx e[idx]=b w[idx]=c ne[idx]=h[a] h[a]=idx idx+=1 def dfs1(u, father): i=h[u] while i!=-1: j=e[i] if j==father: i=ne[i] continue dfs1(j,u) dis = d1[j]+w[i] if dis\u0026gt;d1[u]: d2[u]=d1[u] d1[u], s1[u]=dis, j elif dis\u0026gt;d2[u]: d2[u]=dis i=ne[i] def dfs2(u, father): i=h[u] while i!=-1: j=e[i] if j==father: i=ne[i] continue if s1[u]==j: up[j]=max(up[u], d2[u])+w[i] else: up[j]=max(up[u], d1[u])+w[i] i=ne[i] dfs2(j, u) n = int(input()) for i in range(n-1): a,b,c = map(int ,input().split()) add(a,b,c) add(b,a,c) dfs1(1,-1) dfs2(1,-1) ans = 1e10 for i in range(1,n+1): ans = min(ans, max(up[i], d1[i])) print(ans) 数字转换 题目大意：给定一个正整数 n，如果一个数 x 的约数之和 y（不包括 x 本身）比它本身小，那么 x 可以变为 y，y 也可以变为 x。限定所有数字变换在不超过 n 的正整数范围内进行，求不断进行数字变换且不出现重复数字的最多变换步数。\n实现思路：\n首先，对于每个数 i，计算其所有约数之和，并存储在数组 s 中。 然后，遍历所有的数 i，如果约数之和 s[i] 小于 i，则将其作为一个节点添加到有向图中，表示可以从 s[i] 变换到 i。 构建有向图后，使用深度优先搜索（DFS）算法遍历图中的每个节点，并求出每个节点的最长路径长度。 在DFS过程中，使用变量 ans 记录图中最长路径的长度，即最多变换步数。 最后，输出 ans 即可。 N = int(5e4+10) s=[0]*N st=[False]*N e=[0]*N ne=[0]*N h=[-1]*N idx=1 ans = -1 def add(a,b): global idx e[idx]=b ne[idx]=h[a] h[a]=idx idx+=1 def dfs(u): global ans d1,d2=0,0 i=h[u] while i!=-1: j=e[i] dis = dfs(j)+1 if dis\u0026gt;d1: d2,d1=d1,dis elif dis\u0026gt;d2: d2=dis i=ne[i] ans = max(ans, d1+d2) return d1 n = int(input()) for i in range(1,n+1): for j in range(2,n+1): if i\u0026gt;n//j: break s[i*j]+=i for i in range(2,n+1): if s[i]\u0026lt;i: add(s[i], i) st[i]=True # for i in range(1,n+1): # if not st[i]: # dfs(i) dfs(1) print(ans) 没有上司的舞会 题目大意：Ural大学有N名职员，编号为1∼N。他们的关系像一棵以校长为根的树，父节点就是子节点的直接上司。每个职员有一个快乐指数，用整数Hi表示。现在要召开一场周年庆宴会，但没有职员愿意和直接上司一起参会。在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。\n实现思路：\n首先，建立一棵以校长为根的树，使用一个二维数组v来存储树的结构关系，其中v[i]表示第i个职员的直接下属。 使用一个二维数组f来记录每个职员参加和不参加宴会时的最大快乐指数，其中f[i][0]表示第i个职员不参加宴会时的最大快乐指数，f[i][1]表示第i个职员参加宴会时的最大快乐指数。 使用深度优先搜索（DFS）来遍历树的每个节点，计算每个节点不参加和参加宴会时的最大快乐指数。 在DFS过程中，对于每个节点i，首先更新该节点参加宴会时的最大快乐指数f[i][1]为当前节点的快乐指数h[i]，然后遍历当前节点的直接下属，更新当前节点参加和不参加宴会时的最大快乐指数。 最终，取根节点的参加和不参加宴会时的最大快乐指数的较大值作为最终结果。 代码实现已给出，其中使用了深度优先搜索来遍历树的每个节点，时间复杂度为O(N)，因为N的最大值为6000，所以算法的时间复杂度为可接受的范围内。\n这个算法的核心思想是利用深度优先搜索逐步计算出每个节点参加和不参加宴会时的最大快乐指数，然后根据问题要求找到最大的快乐指数。\nimport sys sys.setrecursionlimit(int(1e4)) N = int(7e3) v=[[] for _ in range(N)] f=[[0]*2 for _ in range(N)] st=[False]*N h=[0]*N root=0 def dfs(u): f[u][1]+=h[u] for i in v[u]: dfs(i) f[u][1]+=f[i][0] f[u][0]+=max(f[i][0], f[i][1]) n = int(input()) for i in range(1,n+1): h[i]=int(input()) for i in range(n-1): l,k = map(int, input().split()) v[k].append(l) st[l]=True for i in range(1,n+1): if not st[i]: root=i dfs(root) print(max(f[root][0], f[root][1])) 单调队列优化的DP 最大子序和 题目大意：给定一个长度为n的整数序列，从中找出一段长度不超过m的连续子序列，使得子序列中所有数的和最大。要求输出该序列的最大子序和。\n实现思路：\n首先，将输入的序列进行预处理，计算出前缀和数组s，其中s[i]表示序列的前i个数的和。 使用单调队列来解决该问题。单调队列维护的是前缀和数组s中的下标，队列中的元素按照前缀和的值单调递增。队列中的下标表示的是以该下标结尾的连续子序列的最大和。 遍历序列，对于每个位置i，更新单调队列中的元素，使得队列中的下标符合要求，即满足长度不超过m的连续子序列的条件。 在遍历的过程中，不断更新记录最大子序和的变量ans，最终得到的ans即为所求结果。 代码实现已给出，其中使用了单调队列来维护满足条件的下标，时间复杂度为O(n)，因为n的最大值为300000，所以算法的时间复杂度为可接受的范围内。\n这个算法的核心思想是利用单调队列维护以每个位置结尾的满足条件的子序列的最大和，然后根据问题要求找到最大子序和。\nN = 300010 q, s = [0]*N, [0]*N ans = -2**33 hh, tt = 0, 0 n,m = map(int, input().split()) s = [0]+list(map(int, input().split())) for i in range(1,n+1): s[i]+=s[i-1] for i in range(1,n+1): if q[hh]\u0026lt;i-m: hh+=1 ans = max(ans, s[i]-s[q[hh]]) while hh\u0026lt;=tt and s[q[tt]]\u0026gt;=s[i]: tt-=1 tt+=1 q[tt]=i print(ans) 数位DP 1081\nfrom typing import List N = 35 def init() -\u0026gt; List[List[int]]: f = [[0] * N for _ in range(N)] for i in range(N): for j in range(i + 1): if j == 0: f[i][j] = 1 else: f[i][j] = f[i - 1][j] + f[i - 1][j - 1] return f def dp(n: int, k: int, b: int, f: List[List[int]]) -\u0026gt; int: if n == 0: return 0 nums = [] while n: nums.append(n % b) n //= b res = 0 last = 0 for i in range(len(nums) - 1, -1, -1): x = nums[i] if x \u0026gt; 0: res += f[i][k - last] if x \u0026gt; 1: if k - last - 1 \u0026gt;= 0: res += f[i][k - last - 1] break else: last += 1 if last \u0026gt; k: break if i == 0 and last == k: res += 1 return res def solve(l: int, r: int, k: int, b: int) -\u0026gt; int: f = init() return dp(r, k, b, f) - dp(l - 1, k, b, f) if __name__ == \u0026#34;__main__\u0026#34;: l, r, k, b = map(int, input().split()) print(solve(l, r, k, b)) 记忆化 滑雪 题目大意：Michael喜欢滑雪，并希望知道在一个区域中最长的滑坡。给定一个二维数组表示区域，数组中的每个数字代表点的高度。一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度会减小。要求找到最长的滑坡，即从一个高点开始，一直滑到一个低点。\n实现思路：\n使用优先队列（堆）来实现广度优先搜索（BFS）。 首先，初始化一个二维数组f用于存储从每个点出发的最长滑坡距离，初始化优先队列pq用于存储待搜索的点。 将所有点按照高度从小到大加入优先队列pq。 对于优先队列中的每个点，依次向上下左右四个方向搜索，如果下一个点的高度小于当前点，则更新下一个点的最长滑坡距离为当前点的最长滑坡距离加1。 在搜索过程中，不断更新记录最长滑坡距离的变量ma，最终得到的ma即为最长滑坡的长度。 代码实现已给出，其中使用了优先队列pq来进行广度优先搜索，时间复杂度为O(nmlog(nm))，因为n和m的最大值为100，所以算法的时间复杂度为可接受的范围内。\n这个算法的核心思想是利用广度优先搜索逐步计算出从每个点出发的最长滑坡距离，然后根据问题要求找到最长的滑坡。\nfrom heapq import * n, m = map(int, input().split()) f = [[0] * (m + 5) for _ in range(n + 5)] # distance g = [[0] * (m + 5) for _ in range(n + 5)] # store heights pq = [] for i in range(1, n + 1): nums = [0] + list(map(int, input().split())) for j, num in enumerate(nums[1:]): f[i][j] = 1 g[i][j] = num heappush(pq, (num, i, j)) # Push (num, i, j) into the priority queue ma = -1 while pq: num, i, j = heappop(pq) if g[i - 1][j] \u0026lt; num: f[i][j] = max(f[i][j], f[i - 1][j] + 1) if g[i + 1][j] \u0026lt; num: f[i][j] = max(f[i][j], f[i + 1][j] + 1) if g[i][j - 1] \u0026lt; num: f[i][j] = max(f[i][j], f[i][j - 1] + 1) if g[i][j + 1] \u0026lt; num: f[i][j] = max(f[i][j], f[i][j + 1] + 1) ma = max(ma, f[i][j]) print(ma) ","permalink":"https://showguan.github.io/en/posts/tech/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E4%BA%94dppython%E5%AE%9E%E7%8E%B0/","summary":"算法笔记（五）——DP（Python实现） DP 数字三角形 f=[] n=int(input()) for _ in range(n): f.append([int(x) for x in input().split()]) for i in range(n-2,-1,-1): for j in range(i+1): f[i][j]=max(f[i+1][j], f[i+1][j+1])+f[i][j] print(f[0][0]) 背包 空间优化成1维之后，只有完全背包问题的","title":"算法笔记（五）——DP（Python实现）"},{"content":"算法笔记（四）——数学（Python实现） 数学 试除法判定质数 def check(x): # 判定 if x\u0026lt;2: return False for i in range(2, int(x**0.5)+1): if x%i==0: return False return True n = int(input()) for i in range(n): x = int(input()) if check(x): print(\u0026#34;Yes\u0026#34;) else: print(\u0026#34;No\u0026#34;) 试除法分解质因数 def get(x): #分解 for i in range(2, int(x**0.5)+1): if x%i==0: cnt=0 while x%i==0: x//=i cnt+=1 print(i, cnt, sep=\u0026#39; \u0026#39;) if x\u0026gt;1: print(x, 1, sep=\u0026#39; \u0026#39;) n = int(input()) for i in range(n): x = int(input()) get(x) print() 线性筛法求素数 N = int(1e6+10) primes = [] st = [False]*N def get(n): for i in range(2, n+1): if not st[i]: primes.append(i) for j in range(len(primes)): if i*primes[j]\u0026gt;n: break st[i*primes[j]]=True if i%primes[j]==0: break n = int(input()) get(n) print(len(primes)) 朴素筛法求素数 N = 1000005 # 根据需要修改 primes = [] # 存储所有素数 st = [False] * N # st[x]存储x是否被筛掉 # 筛素数函数 def get_primes(n): global primes global st for i in range(2, n + 1): if not st[i]: primes.append(i) for j in range(i, n + 1, i): st[j] = True # Example usage: # get_primes(100) # print(primes) 试除法求所有约数 def get(x): res = [1] for i in range(2, int(x**0.5)+1): if x%i==0: res.append(i) if i!=x//i: res.append(x//i) if x\u0026gt;1: res.append(x) return sorted(res) n = int(input()) for i in range(n): x = int(input()) res = get(x) print(*res) 约数个数和约数之和 如果 N = p1^c1 * p2^c2 * ... *pk^ck\r约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1)\r约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck) gcd def gcd(a, b): return gcd(b, a % b) if b else a 求欧拉函数 def get(x): res = x for i in range(2, int(x**0.5)+1): if x%i==0: res = res//i*(i-1) while x%i==0: x//=i if x\u0026gt;1: res = res//x*(x-1) return res n = int(input()) for i in range(n): x = int(input()) print(get(x)) 筛法求欧拉函数 N = int(1e6+10) primes = [] euler = [0]*N st = [False]*N cnt = 0 def get(n): euler[1] = 1 for i in range(2, n+1): if not st[i]: primes.append(i) euler[i] = i-1 for j in range(len(primes)): t = primes[j]*i if t\u0026gt;n: break st[t] = True if i%primes[j]==0: euler[t] = euler[i]*primes[j] break euler[t] = euler[i]*(primes[j]-1) n = int(input()) get(n) for i in range(1,n+1): cnt+=euler[i] print(cnt) 快速幂 # 快速幂函数 def qmi(m, k, p): res, t = 1 % p, m while k: if k \u0026amp; 1: res = res * t % p t = t * t % p k \u0026gt;\u0026gt;= 1 return res # Example usage: # result = qmi(2, 10, 1000000007) # print(result) 拓展欧几里得 # 求 x, y，使得 ax + by = gcd(a, b) def exgcd(a, b, x, y): if b == 0: x[0], y[0] = 1, 0 return a d = exgcd(b, a % b, y, x) y[0] -= (a // b) * x[0] return d # Example usage: # x = [0] # y = [0] # gcd = exgcd(30, 20, x, y) # print(\u0026#34;x:\u0026#34;, x[0], \u0026#34;y:\u0026#34;, y[0], \u0026#34;gcd:\u0026#34;, gcd) P1082 [NOIP2012 提高组] 同余方程 题目描述：求解关于x的同余方程$ax ≡ 1 (mod b)$的最小正整数解。\n实现思路：这个问题可以转化为求解$ax + by = gcd(a, b)$的解，其中x就是我们需要的结果。可以利用扩展欧几里得算法来求解这个方程。具体地，通过递归的方式求解出最大公约数，并且求解出使得$ax + by = gcd(a, b)$成立的整数x和y。然后通过对x取模b的操作得到最小正整数解x。最后输出x即可。\n# 求 x, y，使得 ax + by = gcd(a, b) def exgcd(a, b, x, y): if b == 0: x[0], y[0] = 1, 0 return a d = exgcd(b, a % b, y, x) y[0] -= (a // b) * x[0] return d a, b = map(int, input().split()) x, y = [0], [0] exgcd(a, b, x, y) x = x[0] x = (x%b+b)%b print(x) 递归法求组合数 N = int(2e3)+10 mod = int(1e9)+7 c = [[0]*N for _ in range(N)] def get(n): for i in range(n+1): for j in range(i+1): if j==0: c[i][j] = 1 else: c[i][j] = (c[i-1][j]+c[i-1][j-1])%mod MN = int(2e3) get(MN) n = int(input()) for i in range(n): a, b = map(int, input().split()) print(c[a][b]) 通过预处理逆元的方式求组合数 mod = int(1e9)+7 N = int(2e5)+10 fact, infact = [0]*N, [0]*N def qpow(a, k, p): res = 1 while k: if k\u0026amp;1: res = (res*a)%p a = (a*a)%p k\u0026gt;\u0026gt;=1 return res def init(): fact[0] = infact[0] = 1 for i in range(1, N): fact[i] = (fact[i-1]*i)%mod infact[i] = (infact[i-1]*qpow(i, mod-2, mod))%mod def C(n, m): if n\u0026lt;m: return 0 return (fact[n]*infact[m]%mod*infact[n-m]%mod) init() n = int(input()) for i in range(n): a, b = map(int, input().split()) print(C(a, b)) Lucas定理 p = 1000000007 # 根据需要调整 # 快速幂模板 def qmi(a, k): res = 1 while k: if k \u0026amp; 1: res = (res * a) % p a = (a * a) % p k \u0026gt;\u0026gt;= 1 return res # 通过定理求组合数C(a, b) def C(a, b): res = 1 for i in range(1, b + 1): res = (res * (a - i + 1)) % p res = (res * qmi(i, p - 2)) % p return res # Lucas定理计算组合数 def lucas(a, b): if a \u0026lt; p and b \u0026lt; p: return C(a, b) return (C(a % p, b % p) * lucas(a // p, b // p)) % p # Example usage: # result = lucas(10, 5) # 计算组合数 C(10, 5) # print(result) 分解质因数法求组合数 # 获取素数列表 def get_primes(n): primes = [] st = [False] * (n + 1) for i in range(2, n + 1): if not st[i]: primes.append(i) for j in range(len(primes)): if primes[j] * i \u0026gt; n: break st[primes[j] * i] = True if i % primes[j] == 0: break return primes # 获取n!中p的次数 def get(n, p): res = 0 while n: res += n // p n //= p return res # 高精度乘法 def mul(a, b): res = [0] * (len(a) + len(b)) for i in range(len(a)): t = 0 for j in range(len(b)): t += res[i + j] + a[i] * b[j] res[i + j] = t % 10 t //= 10 res[i + len(b)] += t while len(res) \u0026gt; 1 and res[-1] == 0: res.pop() return res # 计算组合数 def calc_combination(a, b): primes = get_primes(a) sum = [0] * len(primes) for i in range(len(primes)): p = primes[i] sum[i] = get(a, p) - get(b, p) - get(a - b, p) res = [1] for i in range(len(primes)): for j in range(sum[i]): res = mul(res, [primes[i]]) return res # Example usage: # result = calc_combination(10, 5) # 计算组合数 C(10, 5) # print(\u0026#39;\u0026#39;.join(map(str, result[::-1]))) 高斯消元 eps = 1e-8 # 根据需要调整 # a 是增广矩阵，n 是矩阵维度 def gauss(a, n): c, r = 0, 0 for c in range(n): t = r for i in range(r, n): if abs(a[i][c]) \u0026gt; abs(a[t][c]): t = i if abs(a[t][c]) \u0026lt; eps: continue for i in range(c, n + 1): a[r][i], a[t][i] = a[t][i], a[r][i] for i in range(n, c - 1, -1): a[r][i] //= a[r][c] for i in range(r + 1, n): if abs(a[i][c]) \u0026gt; eps: for j in range(n, c - 1, -1): a[i][j] -= a[r][j] * a[i][c] r += 1 if r \u0026lt; n: for i in range(r, n): if abs(a[i][n]) \u0026gt; eps: return 2 # 无解 return 1 # 有无穷多组解 for i in range(n - 1, -1, -1): for j in range(i + 1, n): a[i][n] -= a[i][j] * a[j][n] return 0 # 有唯一解 # Example usage: # a = [[2, 1, -1, 8], [-3, -1, 2, -11], [-2, 1, 2, -3]] # n = 3 # result = gauss(a, n) # print(result) ","permalink":"https://showguan.github.io/en/posts/tech/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E5%9B%9B%E6%95%B0%E5%AD%A6python%E5%AE%9E%E7%8E%B0/","summary":"算法笔记（四）——数学（Python实现） 数学 试除法判定质数 def check(x): # 判定 if x\u0026lt;2: return False for i in range(2, int(x**0.5)+1): if x%i==0: return False return True n = int(input()) for i in range(n): x = int(input()) if check(x): print(\u0026#34;Yes\u0026#34;) else: print(\u0026#34;No\u0026#34;) 试除法分解","title":"算法笔记（四）——数学（Python实现）"},{"content":"周赛240407 出师不利，第一题变量名能写错，慢就是快，少就是多，提交之前一定要有万全的检查。\n第二题100242. 满足距离约束且字典序最小的字符串 纯思维题，先花时间想清楚基础问题再想后面的问题。吸取教训，代码一定要写的清晰明了，自己才能更好的看懂并写下去。\nPython 取模运算中余数符号和除数符号一致，并满足：$被除数-除数*商(整除)=余数$\n思路：转换问题，问不超过k，那么用完$k$是最优的，因为用$k$总能使字典序变小(除非原序列全是$a$), 那么就依次枚举，知道不能转换为$a$的情况下将剩余的$k$转换称可以转换成的最小的字典序字母。\nclass Solution: def getSmallestString(self, s: str, k: int) -\u0026gt; str: s = list(s) n = len(s) for i in range(n): d = min(ord(s[i])-ord(\u0026#39;a\u0026#39;), ord(\u0026#39;a\u0026#39;)-ord(s[i])+26) if k\u0026gt;=d: k-=d s[i]=\u0026#39;a\u0026#39; else: num = ord(s[i])-ord(\u0026#39;a\u0026#39;) ch = min((num-k)%26, (num+k)%26) ch = chr(ch+ord(\u0026#39;a\u0026#39;)) s[i] = ch break return \u0026#39;\u0026#39;.join(s) 第三题 3107. 使数组中位数等于 K 的最少操作数 这题比较简答，最后一刻用二分交的，结果右端点取值保守错了一发。\n实际不需要二分，在排好序的序列里，用中位数去靠近中位数更优，所以直接排序计算将前面比k大的和后面比$k$小的计算差值就可以了。\nclass Solution: def minOperationsToMakeMedianK(self, nums: List[int], k: int) -\u0026gt; int: nums.sort() n = len(nums) mid = n // 2 op=abs(nums[mid]-k) for i in range(mid): if nums[i]\u0026gt;k: op += nums[i] - k for i in range(mid+1, n): if nums[i]\u0026lt;k: op += k - nums[i] return op 第四题100244. 带权图里旅途的最小代价 并查集+思维题。如果一些数字相与$(and)$， 如果存在较小的数字二进制位中是$0$，那么就算有再多的数字在这一位上是$1$也没有用了。所以在一个连通块内最小代价就是所有边都走一遍，而连通块可以用并查集来判断。\nclass Solution: def minimumCost(self, n: int, edges: List[List[int]], query: List[List[int]]) -\u0026gt; List[int]: def find(x): if p[x]!=x: p[x]=find(p[x]) return p[x] p={i:i for i in range(n)} dis={} ret=[] for u,v,_ in edges: p[find(u)]=find(v) for u,v,w in edges: pu = find(u) if pu not in dis: dis[pu]=w else: dis[pu]\u0026amp;=w for x,y in query: if x==y: ret.append(0) continue #如果相等一定要continue px, py = find(x), find(y) if px==py: ret.append(dis[px]) else: ret.append(-1) return ret ","permalink":"https://showguan.github.io/en/posts/tech/%E5%91%A8%E8%B5%9B240407/","summary":"周赛240407 出师不利，第一题变量名能写错，慢就是快，少就是多，提交之前一定要有万全的检查。 第二题100242. 满足距离约束且字典序最小的","title":"LeetCode周赛392(240407)"},{"content":"hugo new content posts/my-first-post.md\n","permalink":"https://showguan.github.io/en/posts/life/my-first-post/","summary":"hugo new content posts/my-first-post.md","title":"My First Post"},{"content":"VP 周赛 第 389 场周赛 第三题3085. 成为 K 特殊字符串需要删除的最少字符数 双指针优化$O(n)$\n第三题做出来了但做法不优并且错的次数太多了。\n题目大意：给定一个字符串word和一个整数k，定义特殊字符串为满足|freq(word[i]) - freq(word[j])| \u0026lt;= k对于字符串中所有下标i和j都成立的字符串。其中，freq(x)表示字符x在word中的出现频率，|y|表示y的绝对值。要求计算使word成为k特殊字符串所需删除的字符的最小数量。\n实现思路：首先统计word中每个字符的出现频率，然后对频率进行排序。接着遍历频率列表，从最大的频率开始，逐步减少频率，直到满足特殊字符串的条件。在减少频率的过程中，利用一个指针指向频率列表中的当前位置，不断向前移动，更新需要删除的字符数量。最终得到使word成为k特殊字符串所需删除的最小字符数量。\nclass Solution: def minimumDeletions(self, word: str, k: int) -\u0026gt; int: ans = 2e9 cnt = sorted(Counter(word).values()) numFre = len(cnt)-1 delCnt = len(word) right = numFre for cur in range(numFre, -1, -1): delCnt-=cnt[cur] maxFre = cnt[cur]+k while right\u0026gt;cur and cnt[right]\u0026gt;maxFre: delCnt+=cnt[right] right-=1 ans = min(ans, delCnt-(numFre-right)*maxFre) return ans 第四题3086. 拾起 K 个 1 需要的最少行动次数 题目大意：给定一个二进制数组nums，长度为n，以及一个正整数k和非负整数maxChanges。Alice在一个游戏中需要从nums中拾起k个1，游戏开始时，Alice可以选择任意位置站立。Alice可以执行两种行动：一是将一个0改为1，次数不超过maxChanges；二是交换相邻位置的1和0。返回Alice拾取k个1所需的最少行动次数。\n实现思路：首先，统计nums中1的位置，同时记录每个1的前缀和。然后确定最多可以拾取的1的个数，即为maxChanges和当前1的个数的最小值。如果最大变化次数maxChanges足够多，那么不需要交换1的位置，直接计算需要变化的次数即可；否则，利用二分搜索确定需要交换的1的位置，计算交换和变化的次数。最终返回行动次数。\nclass Solution: def minimumMoves(self, nums: List[int], k: int, maxChanges: int) -\u0026gt; int: pos = [] n=len(nums) c=0 for i, v in enumerate(nums): if not v: continue pos.append(i) if c==3: continue c=max(c, 1) if i\u0026gt;0 and nums[i]==nums[i-1]: c = max(2, c) if i\u0026gt;1 and nums[i]==nums[i-1] and nums[i]==nums[i-2]: c = max(3, c) c = min(c, k) if maxChanges\u0026gt;=k-c: return max(0, (k-c)*2)+max(0, c-1) n = len(pos) preSum = list(accumulate(pos, initial = 0)) ret = inf rest = k-maxChanges for right in range(rest, n+1): left = right-rest i=left+right\u0026gt;\u0026gt;1 s1 = pos[i]*(i-left) - (preSum[i]-preSum[left]) s2 = preSum[right]-preSum[i]-pos[i]*(right-i) ret = min(ret, s1+s2) return ret+maxChanges*2 ","permalink":"https://showguan.github.io/en/posts/tech/vp-%E5%91%A8%E8%B5%9B389/","summary":"VP 周赛 第 389 场周赛 第三题3085. 成为 K 特殊字符串需要删除的最少字符数 双指针优化$O(n)$ 第三题做出来了但做法不优并且错的次数太多了。 题目大","title":"LeetCode周赛VP389"},{"content":"周赛240331 第四题 100240 最小化曼哈顿距离\n题目大意：给定一个二维平面上的点集，求移除其中一个点后，剩余点集中任意两点之间的最大曼哈顿距离的最小值。\n实现思路：首先，对于曼哈顿距离而言，它的定义是两点在各个坐标轴上的差的绝对值之和。所以移除一个点后，影响到最大曼哈顿距离的主要是距离移除点最近的点。我们可以将点的坐标进行转换，将其转换为(x+y)和(x-y)的形式，这样在平面上的曼哈顿距离就可以等效为在转换后的坐标系下的欧几里得距离。然后我们用两个有序集合分别维护x+y和x-y的坐标轴上的值，分别为xset和yset。然后遍历每个点，从点集中移除一个点，更新最大距离，找到最小值。\nfrom sortedcontainers import SortedList class Solution: def minimumDistance(self, points: List[List[int]]) -\u0026gt; int: xset, yset = SortedList(), SortedList() for x, y in points: xset.add(x+y) yset.add(x-y) ans = inf for x, y in points: xx = x+y yy = x-y xset.remove(xx) yset.remove(yy) ans = min( ans, max(xset[-1]-xset[0], yset[-1]-yset[0]) ) xset.add(xx) yset.add(yy) return ans ","permalink":"https://showguan.github.io/en/posts/tech/%E5%91%A8%E8%B5%9B240331/","summary":"周赛240331 第四题 100240 最小化曼哈顿距离 题目大意：给定一个二维平面上的点集，求移除其中一个点后，剩余点集中任意两点之间的最大曼哈顿距离的最小","title":"LeetCode周赛240331"},{"content":"周赛 24/3/24 第三题 100258 3092. 最高频率的 ID 题目大意：给定两个长度为n的整数数组nums和freq，nums中的每个元素表示一个ID，对应的freq中的元素表示这个ID在集合中此次操作后需要增加或者减少的数目。现要求在每一步操作后，返回出现频率最高的ID数目，若集合为空则为0。 SortedList实现\nfrom sortedcontainers import SortedList class Solution: def mostFrequentIDs(self, nums: List[int], freq: List[int]) -\u0026gt; List[int]: sl = SortedList(key = lambda x : -x) d = defaultdict(int) ret = [] for x,y in zip(nums, freq): if d[x]!=0: sl.remove(d[x]) d[x]+=y sl.add(d[x]) else: d[x]=y sl.add(d[x]) if sl: ret.append(sl[0]) else: ret.append(0) return ret heap 实现\n实现思路： 使用一个字典d来动态记录ID的出现频率，初始化一个空堆heap和结果列表ret。\n遍历nums和freq数组，对于每对nums[i]和freq[i]，更新字典d中对应ID的频率。\n将(-d[x], x)元组加入堆heap，其中-d[x]表示ID x的出现频率的相反数，x表示ID本身。堆按照频率从高到低排序。\n进入循环，检查堆顶元素是否满足当前频率，若不满足则弹出直至满足。\n将当前堆顶元素的频率加入结果列表ret。\n返回结果列表ret。\nclass Solution: def mostFrequentIDs(self, nums: List[int], freq: List[int]) -\u0026gt; List[int]: d = defaultdict(int) heap = [] ret = [] for x,y in zip(nums, freq): d[x]+=y heapq.heappush(heap, (-d[x], x)) while True: tx, ty = heap[0] if -tx != d[ty]: heapq.heappop(heap) continue ret.append(-tx) break return ret 第四题 1002683093. 最长公共后缀查询 Trie树\n题目大意： 给定两个字符串数组wordsContainer和wordsQuery，对于每个wordsQuery[i]，需要从wordsContainer中找到一个与wordsQuery[i]有最长公共后缀的字符串。若有多个满足条件的字符串，选择长度最短的一个，若长度相同则选择在wordsContainer中出现较早的一个。返回一个整数数组ans，其中ans[i]表示wordsContainer中与wordsQuery[i]有最长公共后缀的字符串的下标。\n实现思路：\n初始化一个变量mi记录wordsContainer中最短字符串的长度，并记录其下标为idx。 构建字典trie，用于存储wordsContainer中每个字符串的逆序形式，并记录最短字符串的下标和长度。 遍历wordsQuery，对于每个查询字符串，将其逆序，然后在trie中搜索与之匹配的最长公共后缀，并返回其对应的下标。 将所有查询结果存入结果列表ret，并返回。 class Solution: def stringIndices(self, c: List[str], q: List[str]) -\u0026gt; List[int]: mi = inf idx = -1 ret = [] for i, w in enumerate(c): if len(w)\u0026lt;mi: mi = len(w) idx = i trie = {} #dict for i, w in enumerate(c): w=w[::-1] cur=trie for wi in w: if wi not in cur: cur[wi] = {} cur = cur[wi] if \u0026#39;#\u0026#39; not in cur: cur[\u0026#39;#\u0026#39;] = (i, len(w)) elif len(w)\u0026lt;cur[\u0026#39;#\u0026#39;][1]: cur[\u0026#39;#\u0026#39;] = (i,len(w)) for i, w in enumerate(q): w=w[::-1] cur = trie ans = idx for wi in w: if wi not in cur: break else: cur = cur[wi] ans = cur[\u0026#39;#\u0026#39;][0] ret.append(ans) return ret ","permalink":"https://showguan.github.io/en/posts/tech/%E5%91%A8%E8%B5%9B240324/","summary":"周赛 24/3/24 第三题 100258 3092. 最高频率的 ID 题目大意：给定两个长度为n的整数数组nums和freq，nums中的每个元素表示一个ID，对应的freq中的元素","title":"LeetCode周赛240324"},{"content":"机器学习简介 Different types of Functions\nRegression : The function outputs a scalar(标量）.\npredict the PM2.5 Classification ： Given options (classes), the function outputs the correct one.\nSpam filtering Structured Learning ： create something with structure(image, document)\nExample : YouTube Channel\n1.Function with Unknown Parameters. $$ y=b+wx_1 $$\n2.Define Loss from Training Data Loss is a function of parameters $$ L(b,w) $$\nLoss : how good a set of values is. L is mean absolute error (MAE) $$ e=\\left | y-\\hat{y} \\right | $$\nL is mean square error (MSE) $$ e=(y-\\hat{y})^2 $$\n$$ L=\\frac{1}{N} \\sum_{n}^{}e_n $$\n3.Optimization $$ w^,b^=arg,\\min_{w,b} ,L $$\nGradient Descent\n(Randomly) Pick an initial value ： $$ w^0 $$\nCompute : $$ \\frac {\\partial L} {\\partial w} |_{w=w_0} $$\nNegative : Increase w\nPositive : Decrease w\n$$ \\eta\\frac {\\partial L} {\\partial w} |_{w=w_0} $$\nη：learning rate (hyperparameters)\nUpdate w iteratively Local minima global minima 类似一个参数，推广到多个参数。\nLinear Models Linear models have severe limitation. Model Bias.\nWe need a more flexible model!\ncurve = constant + sum of a set of Hard Sigmoid Function\n$$ y=c\\frac {1} {1+exp(-(b+wx_1))} \\ =csigmoid(b+wx_1) $$\n$$ y=b+\\sum_{i}sigmoid(b_i+w_ix_i) $$\n$$ y=b+\\sum_{i}sigmoid(b_i+\\sum_{j}w_{ij}x_j) $$\n线性代数角度：\n$$ r=b+Wx $$\n$$ a=\\sigma(r) $$\n$$ y=b+c^Ta $$\nLoss\nLoss is a function of parameters L(θ) Loss means how good a set of values is. Optimization of New Model $$ \\theta= \\begin{bmatrix}\n\\theta_1 \\ \\theta_2 \\ \\theta_3 \\ \\dots \\end{bmatrix} $$\n$$ \\theta=arg \\min_\\theta L $$\n(Randomly) Pick initial values θ^0 1 epoch = see all the batched once\nupdate : update θ for each batch\nSigmoid -\u0026gt; ReLU (Rectified Linear Unit) 统称为 Activation function\nNeural Network\n","permalink":"https://showguan.github.io/en/posts/tech/1.%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B/","summary":"机器学习简介 Different types of Functions Regression : The function outputs a scalar(标量）. predict the PM2.5 Classification ： Given options (classes), the function outputs the correct one. Spam filtering Structured Learning ： create something with structure(image, document) Example : YouTube Channel 1.Function with Unknown Parameters. $$ y=b+wx_1 $$ 2.Define Loss from Training Data Loss is a","title":"1. 机器学习简介"},{"content":"PyTorch PyTorch Tutorial\nPython3中机器学习框架\ndataset = MyDataset(file) dataloader = DataLoader(dataset, batch_size = size , shuffle = True) Training : True Testing : False from torch.utils.data import Dataset, DateLoader class MyDataset(Dataset): def __init__(self, file): # read data \u0026amp; preprocess self.data = ... def __getitem__(self,index): #return one sample at a time return self.data[index] def __len__(self): #return the size of the dataset return len(self.data) dataset = MyDataset(file) dataloader = Dataloader(dataset, batch_size, shuffle = True) shuffle : Training -\u0026gt; true Testing -\u0026gt; false Tersors High-dimensional matrices(arrays)\n.shape() # show the dimension #Directly from data (list or numpy.ndarray) x = torch.tensor([1, -1], [-1, 1]) x = torch.from_numpy(np.array([[1, -1], [-1, 1]])) #Tensor of constant zeros \u0026amp; ones x = torch.zeros([2, 2]) x = torch.ones([1, 2, 5]) x+y x-y y=x.pow(2) y=x.sum() y=x.mean() #Transpose : transpose two specified dimensions x = x.transpose(dim0,dim1) # change the dimension dim0 and dim1 #Squeeze : remove the specified dimension with length 1 x = x.squeeze(1) #unsqueeze expand a new dimension x = x.unsqueeze(1) dim in PyTorch == axis in NumPy\ndimensional\nCheck with.shape()\tCreating Tensors Directly from data (list or numpy.ndarray)\nx = torch.tensor([1, -1], [-1, 1]) x = torch.from_numpy(np.array([[1, -1], [-1, 1]])) Tensor of constant zeros \u0026amp; ones\nx = torch.zeros([2,2]) x = torch.ones([1, 2, 5]) Common Operations addition subtraction power summation mean\ntranspose x.shape x.transpose(0,1) Unsqueeze : expand a new dimension\nx = x.unsqueeze(1) **Cat **: conncatenate multiple tensors 合并多个矩阵\ntorch.cat([x, y, z], dim = 1) Data Type: Using different data types for model and data will case errors.\n32-bit -torch.float\n64-bit -torch.long\nDevice\nTensors \u0026amp; modules will be computed with CPU by default Use .to() to move tensors to appropriate devices CPU x = x.to('cpu')\t- ```py x = x.to('cuda') GPU check if your computer has NVIDIA GPU torch.cuda.is_available() - Multiple GPUs : specify- ``` 'cuda:0', 'cuda:1', 'cuda:2',... Cradient Calculation import torch # 定义一个需要求导的张量 x，并将 requires_grad 参数设置为 True x = torch.tensor([[1., 0.], [-1., 1.]], requires_grad=True) # 计算 x 的平方并对其进行求和，得到张量 z z = x.pow(2).sum() # 对张量 z 进行反向传播，自动计算出 x 的梯度 z.backward() # 输出 x 的梯度 print(x.grad) torch.nn Network Layers Linear Layer (Fully-connected Layer) nn.linear(in_features, out_features) #### Non-linear Activation Functions```pynn.Sigmoid()nn.ReLU() Build your own neural network import torch.nn as nn class MyModel(nn.Module): #initialize your model \u0026amp; define layers def __init__(self): super(MyModel, self).__init__() self.net = nn.Sequential( nn.Linear(10, 32), nn.Sigmoid(), nn.Linear(32,1) ) #compute output of your nn def forward(self, x): return self.next() Loss Functions Mean squared Error (for regression tasks) criterion = nn.MSELoss() Cross Entropy (for classification tasks) 交叉熵 criterion = nn.CrossEntropyLoss() loss = criterion(model_output, expected_value) ### torch.optim- Stochastic Gradient Descent (SGD) - ```py torch.optim.SGD(model.parameters(), lr, momentum = 0) For every batch of data Call optimizer.zero_grad() to reset gradients of model parameters. Call loss.backward() to backpropagate gradients of prediction loss Call optimizer.step() to adjust model parameters Neural Network Training Setup dataset = MyDataSet(file) tr_set = DataLoader(dataset, 16, shuffle = True) model = MyModel().to(device) criterion = nn.MSELoss() optimizer = torch.optim.SGD(model.parameters(), 0.1) Training Loop for epoch in range(n_epochs): # Iterate over n_epochs model.train() # Set the model to training mode for x, y in tr_set: # Iterate over the training set optimizer.zero_grad() # Clear the gradients x, y = x.to(device), y.to(device) # Move data to the device (e.g., GPU) pred = model(x) # Forward pass, compute predictions loss = criterion(pred, y) # Compute the loss loss.backward() # Backward pass, compute gradients optimizer.step() # Update the model\u0026#39;s parameters using the gradients Validation Loop model.eval() # Set the model to evaluation mode total_loss = 0 for x, y in dv_set: # Iterate over the validation set x, y = x.to(device), y.to(device) # Move data to the device with torch.no_grad(): # Disable gradient computation pred = model(x) # Forward pass, compute predictions loss = criterion(pred, y) # Compute the loss total_loss += loss.cpu().item() * len(x) # Accumulate the loss avg_loss = total_loss / len(dv_set) # Calculate the average loss per sample Testing Loop model.eval() # Set the model to evaluation mode preds = [] for x in tt_set: # Iterate over the test set x = x.to(device) # Move data to the device with torch.no_grad(): # Disable gradient computation pred = model(x) # Forward pass, compute predictions preds.append(pred.cpu()) # Append the predictions to the list Data, demo1 Load data : use pandas to load a csv file\ntrain_data = pd.read_cav(\u0026#39;./name.csv\u0026#39;).drop(columns=[\u0026#39;date\u0026#39;]).values x_train, y_train = train_data[:,:-1], train_data[:,:-1] Dataset init : Read data and preproces\ngetitem : Return one sample at a time, In this case, one sample includes a 117 dimensional feature and a label\nlen : Return the size of the dataset. In this case, it is 2699\nclass COVID19Dataset(Dataset): \u0026#39;\u0026#39;\u0026#39; x: np.ndarray 特征矩阵. y: np.ndarray 目标标签, 如果为None,则是预测的数据集 \u0026#39;\u0026#39;\u0026#39; def __init__(self, x, y=None): if y is None: self.y = y else: self.y = torch.FloatTensor(y) self.x = torch.FloatTensor(x) def __getitem__(self, idx): if self.y is None: return self.x[idx] return self.x[idx], self.y[idx] def __len__(self): return len(self.x) Dataloader train_loader = DataLoader(train_dataset, batch_size = 32, shuffle = True, pin_memory = True) Model class My_Model(nn.Module): def __init__(self, input_dim): super(My_Model, self).__init__() # TODO: 修改模型结构, 注意矩阵的维度（dimensions） self.layers = nn.Sequential( nn.Linear(input_dim, 16), nn.ReLU(), nn.Linear(16, 8), nn.ReLU(), nn.Linear(8, 1) ) def forward(self, x): x = self.layers(x) x = x.squeeze(1) # (B, 1) -\u0026gt; (B) return x Criterion criterion = torch.nn.MSELoss(reduction = \u0026#39;mean\u0026#39;) Optimizer optimizer = torch.optim.SGD(model.parameters(), lr = 1e-5, momentum = 0.9) Training Loop Documentation and Common Errors read pytorch tutorial\nColab（highly recommended） ","permalink":"https://showguan.github.io/en/posts/tech/2.pytorch/","summary":"PyTorch PyTorch Tutorial Python3中机器学习框架 dataset = MyDataset(file) dataloader = DataLoader(dataset, batch_size = size , shuffle = True) Training : True Testing : False from torch.utils.data import Dataset, DateLoader class MyDataset(Dataset): def __init__(self, file): # read data \u0026amp; preprocess self.data = ... def __getitem__(self,index): #return one sample at a time return self.data[index] def __len__(self): #return the size of","title":"2. PyTorch"},{"content":"Officially begin Deep = Many hidden layers\nNeurall Network Find a function in function set.\nGoodness of function Pick the best function\nBackpropagation - Backward Pass(反向传播) 反向的neural network\nRegression Stock Market Forecast Self-driving Car Recommendation Step 1 : Model A set of function\nStep 2 : Goodness of Function $$ \\hat{y}^1代表x^1对应的确切值 $$\nLoss function L： $$ L(f)=L(w,b) ~ Estimated ~ y ~ basedoninputfunction $$\n$$ L(w,b)=\\sum_{n=1}^{10}(\\hat{y}^n-(b+w\\cdot x_{cp}^n))^2 $$\nStep 3 ：Best Function In linear regression, the loss function L is convex.\nOverfitting\nRegularization $$ L(w,b)=\\sum_{n=1}^{10}(\\hat{y}^n-(b+w\\cdot x_{cp}^n))^2+\\lambda\\cdot \\sum(w_i)^2 $$\n不需要考虑bias，调整平滑程度，smooth\nGradient descent Overfitting and Regularization Classification independently and identically distributed(i.i.d) $$ L(h^{train},D_{all})-L(h^{all}, d_{all}) \\leq \\delta\\ we\\ need \\ \\forall h \\in \\H, |L(h,D_{train}) -L(h,D_{all}) | \\leq \\delta/2\\ L(h^{train},D_{all})\\leq L(h^{train},D_{all}) + \\delta/2 $$ 重温数码宝贝：\n模型出现bad的概率： $$ P(D_{train}\\ is\\ bad)\\leq |H| \\cdot 2exp(-2N\\epsilon^2 ) \\ N \\ge \\frac{log(2|H|/\\delta)}{2\\epsilon^2} $$ Tradeoff of Model Complexity\nTraining data for Classification pair\nIdeal Alternatives Function(Model): $$ f(x)\\ x -\u0026gt; g(x)\u0026gt;0~Output=class1\\ else\\ Output=class2 $$\nlossfunction: The number of times of get incotrrect results on training data. $$ L(f) = \\sum_{n}\\delta(f(x^n)\\neq\\hat{y}^n) $$\nFind the best function; Example : Perceptron, SVM Prior $$ P(C_1|x)=\\frac{P(x|C_1)P(C_1)}{P(x|C_1)P(C_1)+P(x|C_2)P(C_2)} $$\nGaussian Maximum Likelihood\n2D array or 3D array mean the array with 2 or 3 axes respectively, but the n-dimensional vector mean the vector of length n.\nLearn something that can really differ you from others.\nLogistics Regression Function Set $$ f_{w,b}=\\sigma(\\sum_{i}w_ix_i)+b $$\nOutput : Between 0 and 1 $$ f_{w,b}(x)=P_{w,b}(C_1|x) $$\n$$ w^,b^=arg\\ \\underset{w,b}{max}L(w,b)\\ 等同于 w^,b^ = arg\\ \\underset{w,b}{min}-lnL(w,b) $$\nCross Entropy: $$ Distribution \\ p: p(x=1)=\\hat{y}^n\\ p(x=0)=1-\\hat{y}^n\\ Distribution \\ q: q(x=1)=f(x^n)\\ q(x=0)=1-f(x^n)\\ H(p,q)=-\\sum_xp(x)ln(q(x)) $$\nLoss Function $$ L(f)=\\sum_nC(f(x^n),\\hat{y}^n)\\ C(f(x^n),\\hat{y}^n)=-[\\hat{y}^nlnf(x^n)+(1-\\hat{y}^n)ln(1-f(x^n))] $$\nUpdate logistic regression 和 linear regression 形式完全相同 $$ w_i\\gets w_i-\\eta \\sum_{n}-(\\hat{y}^n-f_{w,b}(x^n))x_i^n $$\nDiscriminative (logistic) \u0026amp; Generative (Gaussian描述) Generative做了某些假设。\nBenefit of generative model With the assumption of probability distribution, less training data is needed With the assumption of probability distribution, more robust to the noise Priors and class-dependent probabilities can be estimated from different sources. Multi-class Classification SoftMax $$ Softmax(z_i)=\\frac{e^{z_i}}{\\sum_{c=1}^{C} e^{z_c}}\\ 1 \u0026gt; y_i\u0026rsquo; \u0026gt; 0\\ \\sum_iy_i\u0026rsquo;=1 $$\nLimitation of Logistic Regression 只能画一条直线\nFeature Transformation Cascading logistic regression models Optimization Issue 层数较多表现的反而没有层数较少的好\nOver fitting 增加训练资料\nData augmentation\nconstrained model\nLess parameters, sharing parameters Less features Early stopping CNN-\u0026gt;比较没有弹性的model\n分Training Set\nN-fold Cross Validation Optimization Fail H : Hessian\nTayler Series Approximation $$ L(\\theta) \\approx L(\\theta^\\prime)+\\frac{1}{2}(\\theta-\\theta^\\prime)^TH(\\theta-\\theta^\\prime) $$\nH is positive definte = All eigen values are positive -\u0026gt; local minima H is negative definte = All eigen values are negative -\u0026gt; **local ** Some eigen values are positive , and some are negative -\u0026gt; Saddle point 在高维下local minima可能会变成saddle poing\nTips for training : Batch and Momentum Batch 1 epoch = see all the batches once -\u0026gt; shuffle after each epoch\nMomentum Movement not just based on gradient, but previous movement.\nDifferent parameters needs different learning rate $$ \\theta_i^{t+1} \\gets \\theta_i^t-\\frac{\\eta}{\\sigma_i^t}g_i^t\\ \\sigma_i^t=\\sqrt{\\frac{1}{t+1}\\sum_{i=0}^t(g_i^t)^2} $$\nAdagred\nRMSProp $$ \\theta_i^{t+1} \\gets \\theta_i^t-\\frac{\\eta}{\\sigma_i^t}g_i^t\\ \\sigma_i^t = \\sqrt{\\alpha(\\sigma_i^{t-1})^2+(1-\\alpha)(g_i^t)^2} $$\nAdam : RMSProp + Momentum\nLearning Rate Sceduling $$ \\theta_i^{t+1} \\gets \\theta_i^t-\\frac{\\eta^t}{\\sigma_i^t}g_i^t\\ $$\nWarm Up New Optimization ","permalink":"https://showguan.github.io/en/posts/tech/3.regression-and-classification/","summary":"Officially begin Deep = Many hidden layers Neurall Network Find a function in function set. Goodness of function Pick the best function Backpropagation - Backward Pass(反向传播) 反向的neural network Regression Stock Market Forecast Self-driving Car Recommendation Step 1 : Model A set of function Step 2 : Goodness of Function $$ \\ha","title":"3. Regression and Classification"},{"content":"Convolutional network (CNN) Network的架构调整\n1、All the images to be classified have the same size.\nReceptive filed\nSimplification 1 - Typical Setting all channels : 会看所有的channels\nkernel size : 长和宽 （e.g., 3*3)\nStride : 移动的步长,希望有高度的重叠\npadding : 补值，补充超出范围的值\nEach receptive field has a set of neurons.\nEach receptive field has the neurons with the same set of parameters, which called filter.\nPooling Flatten ","permalink":"https://showguan.github.io/en/posts/tech/4.cnn/","summary":"Convolutional network (CNN) Network的架构调整 1、All the images to be classified have the same size. Receptive filed Simplification 1 - Typical Setting all channels : 会看所有的channels kernel size : 长和宽 （e.g., 3*3) Stride : 移动的","title":"4.CNN"},{"content":"Spatial Transformer（STN） 处理旋转和放大图形的CNN分类\ninterpolation 插值法 Self-attention Sequence Labeling consider the context -\u0026gt; 参数很大并且容易Over fitting\nSelf-attention会持有整个sequence的信息\ninput : vector\noutput : vector $$ q_i=W^qa^i\\ k_i=W^ka^i\\ v^i=W^va^i $$ Multi-head Self-attention 其中 $$ q_i, k_i, v_i均可以有多个 $$\nSelf-attention for Speech Truncated(截短的) Self-attention\nSelf-attention is the complex version of CNN\nCNN is simplified self-attention\nRecurrent Neural Network(RNN) RNN所做的事情都可以用Self-attention来替代\nSelf-attention更有效率\nRNN\nTransformer Sequence to sequence (Seq2seq) Encoder -\u0026gt; Decoder\nEncoder input some vectors and output some vectors\nDecoder Autoregressive Non-autoregressive Decoder 同时输出BEGIN并且同时输出结果和END\nAdvantage ： parallel, controllable output length\nNAT is usually worse than AT\nEncoder-Decoder Cross Attention\nTeacher Forcing : using the ground truth as input\nCopy Mechanism\nPointer Network Copying Mechanism Guided Attention Beam Search Scheduled Sampling\n","permalink":"https://showguan.github.io/en/posts/tech/5.transformer/","summary":"Spatial Transformer（STN） 处理旋转和放大图形的CNN分类 interpolation 插值法 Self-attention Sequence Labeling consider the context -\u0026gt; 参数很大并且容易Over fitting Self-attention","title":"5.Transformer"},{"content":" 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 ","permalink":"https://showguan.github.io/en/links/","summary":"名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客","title":"🤝友链"},{"content":" 英文名: Kennem 职业: Still a Stuent 运动: Gaming ","permalink":"https://showguan.github.io/en/about/","summary":"英文名: Kennem 职业: Still a Stuent 运动: Gaming","title":"🙋🏻‍♂️关于"},{"content":"acwing算法学习 [TOC]\n第一章 课上：学思想\n课下：背代码\n题目，一道题写好几遍\n理解没有任何意义，体力活+脑力活\n记忆力 毅力/自制力\n沉下心背东西\n快速排序算法模板 —— 模板题 AcWing 785. 快速排序 分治\n1、确定分界点，l、r、（l+r)/2 随机\n2、调整区间，分为两边，左边小于等于x,右边大于等于x\n3、递归处理左右两段\nvoid quick_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r \u0026gt;\u0026gt; 1]; while (i \u0026lt; j) { do i ++ ; while (q[i] \u0026lt; x); do j -- ; while (q[j] \u0026gt; x); if (i \u0026lt; j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1, r); } -std=c++11 归并排序算法模板 —— 模板题 AcWing 787. 归并排序 排序稳定：序列中相同的值排序后的相对位置是否发生改变\n时间复杂度有 （nlogn)\n1）确定分界点mid\n2）递归排序两边\n2）归并，合并为一个有序数组\nvoid merge_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int mid = l + r \u0026gt;\u0026gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) if (q[i] \u0026lt; q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; while (i \u0026lt;= mid) tmp[k ++ ] = q[i ++ ]; while (j \u0026lt;= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0; i \u0026lt;= r; i ++, j ++ ) q[i] = tmp[j]; } 整数二分算法模板 —— 模板题 AcWing 789. 数的范围 边界问题\n本质：区间内一半满足一半不满足\nl=mid时加一\nbool check(int x) {/* ... */} // 检查x是否满足某种性质 // 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用： int bsearch_1(int l, int r) { while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) r = mid; // check()判断mid是否满足性质 else l = mid + 1; } return l; } // 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用： int bsearch_2(int l, int r) { while (l \u0026lt; r) { int mid = l + r + 1 \u0026gt;\u0026gt; 1; if (check(mid)) l = mid; else r = mid - 1; } return l; } 浮点数二分算法模板 —— 模板题 AcWing 790. 数的三次方根 浮点数二分，比较对应整数二分\nbool check(double x) {/* ... */} // 检查x是否满足某种性质 double bsearch_3(double l, double r) { const double eps = 1e-6; // eps 表示精度，取决于题目对精度的要求 while (r - l \u0026gt; eps) { double mid = (l + r) / 2; if (check(mid)) r = mid; else l = mid; } return l; } 高精度加法 —— 模板题 AcWing 791. 高精度加法 // C = A + B, A \u0026gt;= 0, B \u0026gt;= 0 vector\u0026lt;int\u0026gt; add(vector\u0026lt;int\u0026gt; \u0026amp;A, vector\u0026lt;int\u0026gt; \u0026amp;B) { if (A.size() \u0026lt; B.size()) return add(B, A); vector\u0026lt;int\u0026gt; C; int t = 0; for (int i = 0; i \u0026lt; A.size(); i ++ ) { t += A[i]; if (i \u0026lt; B.size()) t += B[i]; C.push_back(t % 10); t /= 10; } if (t) C.push_back(t); return C; } 高精度减法 —— 模板题 AcWing 792. 高精度减法 // C = A - B, 满足A \u0026gt;= B, A \u0026gt;= 0, B \u0026gt;= 0 vector\u0026lt;int\u0026gt; sub(vector\u0026lt;int\u0026gt; \u0026amp;A, vector\u0026lt;int\u0026gt; \u0026amp;B) { vector\u0026lt;int\u0026gt; C; for (int i = 0, t = 0; i \u0026lt; A.size(); i ++ ) { t = A[i] - t; if (i \u0026lt; B.size()) t -= B[i]; C.push_back((t + 10) % 10); if (t \u0026lt; 0) t = 1; else t = 0; } while (C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) C.pop_back(); return C; } 高精度乘低精度 —— 模板题 AcWing 793. 高精度乘法 // C = A * b, A \u0026gt;= 0, b \u0026gt; 0 vector\u0026lt;int\u0026gt; mul(vector\u0026lt;int\u0026gt; \u0026amp;A, int b) { vector\u0026lt;int\u0026gt; C; int t = 0; for (int i = 0; i \u0026lt; A.size() || t; i ++ ) { if (i \u0026lt; A.size()) t += A[i] * b; C.push_back(t % 10); t /= 10; } return C; } 高精度除以低精度 —— 模板题 AcWing 794. 高精度除法 // A / b = C ... r, A \u0026gt;= 0, b \u0026gt; 0 vector\u0026lt;int\u0026gt; div(vector\u0026lt;int\u0026gt; \u0026amp;A, int b, int \u0026amp;r) { vector\u0026lt;int\u0026gt; C; r = 0; for (int i = A.size() - 1; i \u0026gt;= 0; i -- ) { r = r * 10 + A[i]; C.push_back(r / b); r %= b; } reverse(C.begin(), C.end()); while (C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) C.pop_back(); return C; } 一维前缀和 —— 模板题 AcWing 795. 前缀和 快速求区间和\nS[i] = a[1] + a[2] + ... a[i] a[l] + ... + a[r] = S[r] - S[l - 1] 从1开始，便于处理边界 二维前缀和 —— 模板题 AcWing 796. 子矩阵的和 S[i, j] = 第i行j列格子左上部分所有元素的和 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为： S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1] 一维差分 —— 模板题 AcWing 797. 差分 给区间[l, r]中的每个数加上c： B[l] += c, B[r + 1] -= c 二维差分 —— 模板题 AcWing 798. 差分矩阵/二维差分 给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c： S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c 双指针算法 —— 模板题 AcWIng 799. 最长连续不重复子序列, AcWing 800. 数组元素的目标和 __滑动窗口？ 核心：把O(n^2)算法优化为O(n)\nfor (int i = 0, j = 0; i \u0026lt; n; i ++ ) { while (j \u0026lt; i \u0026amp;\u0026amp; check(j, i)) j ++ ; // 具体问题的逻辑 } 常见问题分类： (1) 对于一个序列，用两个指针维护一段区间 (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作 位运算 —— 模板题 AcWing 801. 二进制中1的个数 原码，反码，补码 求n二进制表示中第k位数字: n \u0026gt;\u0026gt; k \u0026amp; 1 返回n的最后一位1：lowbit(n) = n \u0026amp; -n 树状数组基本操作 整数离散化 —— 模板题 AcWing 802. 区间和 vector\u0026lt;int\u0026gt; alls; // 存储所有待离散化的值 sort(alls.begin(), alls.end()); // 将所有值排序 alls.erase(unique(alls.begin(), alls.end())返回去重后数组末尾端点, alls.end()); // 去掉重复元素 // 二分求出x对应的离散化的值 int find(int x) // 找到第一个大于等于x的位置 { int l = 0, r = alls.size() - 1; while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (alls[mid] \u0026gt;= x) r = mid; else l = mid + 1; } return r + 1; // 映射到1, 2, ...n } 区间合并 —— 模板题 AcWing 803. 区间合并 // 将所有存在交集的区间合并 贪心 void merge(vector\u0026lt;PII\u0026gt; \u0026amp;segs) { vector\u0026lt;PII\u0026gt; res; sort(segs.begin(), segs.end()); //区间左端点排序 int st = -2e9, ed = -2e9; for (auto seg : segs) if (ed \u0026lt; seg.first) { if (st != -2e9) res.push_back({st, ed}); st = seg.first, ed = seg.second; } else ed = max(ed, seg.second); if (st != -2e9) res.push_back({st, ed}); segs = res; } 作者：yxc 链接：https://www.acwing.com/blog/content/277/ 来源：AcWing 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n第二章 数据结构，以数组模拟的形式\n指针+结构体 ： 面试题\n单链表 —— 模板题 AcWing 826. 单链表 邻接表-存储树和图 静态链表\n下标从0开始\n// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点 int head, e[N], ne[N], idx; // 初始化 void init() { head = -1; idx = 0; } // 在链表头插入一个数a void insert(int a) { e[idx] = a, ne[idx] = head, head = idx ++ ; } // 插入下标k后面 void add(int k,int x) { e[idx]= x, ne[idx] = ne[k], ne[k] = idx++ ; } // 将头结点删除，需要保证头结点存在 void remove() { head = ne[head]; } // 将k后面的点删掉 void remove(int k) { ne[k] = ne[ne[k]]; } 双链表 —— 模板题 AcWing 827. 双链表 优化某些问题\n// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点 int e[N], l[N], r[N], idx; // 初始化 void init() { //0是左端点，1是右端点 r[0] = 1, l[1] = 0; idx = 2; } // 在节点a的右边插入一个数x void insert(int a, int x) { e[idx] = x; l[idx] = a, r[idx] = r[a]; l[r[a]] = idx, r[a] = idx ++ ; } // 删除节点a void remove(int a) { l[r[a]] = l[a]; r[l[a]] = r[a]; } 栈 —— 模板题 AcWing 828. 模拟栈 // tt表示栈顶 int stk[N], tt = 0; // 向栈顶插入一个数 stk[ ++ tt] = x; // 从栈顶弹出一个数 tt -- ; // 栈顶的值 stk[tt]; // 判断栈是否为空 if (tt \u0026gt; 0) { } 队列 —— 模板题 AcWing 829. 模拟队列 普通队列\n// hh 表示队头，tt表示队尾 int q[N], hh = 0, tt = -1; // 向队尾插入一个数 q[ ++ tt] = x; // 从队头弹出一个数 hh ++ ; // 队头的值 q[hh]; // 判断队列是否为空 if (hh \u0026lt;= tt) { //不空 } 循环队列\n// hh 表示队头，tt表示队尾的后一个位置 int q[N], hh = 0, tt = 0; // 向队尾插入一个数 q[tt ++ ] = x; if (tt == N) tt = 0; // 从队头弹出一个数 hh ++ ; if (hh == N) hh = 0; // 队头的值 q[hh]; // 判断队列是否为空 if (hh != tt) { } 单调栈 —— 模板题 AcWing 830. 单调栈 常见模型：找出每个数左边离它最近的比它大/小的数 int tt = 0; for (int i = 1; i \u0026lt;= n; i ++ ) { while (tt \u0026amp;\u0026amp; check(stk[tt], i)) tt -- ; stk[ ++ tt] = i; } 单调队列 —— 模板题 AcWing 154. 滑动窗口 常见模型：找出滑动窗口中的最大值/最小值 int hh = 0, tt = -1; for (int i = 0; i \u0026lt; n; i ++ ) { while (hh \u0026lt;= tt \u0026amp;\u0026amp; check_out(q[hh])) hh ++ ; // 判断队头是否滑出窗口 while (hh \u0026lt;= tt \u0026amp;\u0026amp; check(q[tt], i)) tt -- ; q[ ++ tt] = i; } KMP —— 模板题 AcWing 831. KMP字符串 用模板串来匹配模式串，找到模式串\ns的真前缀以及真后缀是指不等于s的前缀以及后缀，即至少是s[1~n-2]或s[0~n-1]\nne[i] : 以i结尾的串中 最长真前缀与真后缀相等的串 的长度，如果没有则为0。\n//前缀h vector\u0026lt;int\u0026gt; prefix_function(string s) { int n = (int)s.length(); vector\u0026lt;int\u0026gt; pi(n); for (int i = 1; i \u0026lt; n; i++) { int j = pi[i - 1]; while (j \u0026gt; 0 \u0026amp;\u0026amp; s[i] != s[j]) j = pi[j - 1]; if (s[i] == s[j]) j++; pi[i] = j; } return pi; } 实际使用范例（下面这个例子字符串从1开始）\n// 求Next数组： // ne[i] 存储真前缀和真后缀相等的长度，所以至少从2开始： //abcab,从b开始才有真前缀 // s[]是模式串，p[]是模板串, n是s的长度，m是p的长度 for (int i = 2, j = 0; i \u0026lt;= m; i ++ ) { while (j \u0026amp;\u0026amp; p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j ++ ; ne[i] = j; } // 匹配 for (int i = 1, j = 0; i \u0026lt;= n; i ++ ) { while (j \u0026amp;\u0026amp; s[i] != p[j + 1]) j = ne[j]; if (s[i] == p[j + 1]) j ++ ; if (j == m) { j = ne[j]; // 匹配成功后的逻辑 } } Trie树 —— 模板题 AcWing 835. Trie字符串统计 int son[N][26], cnt[N], idx; // 0号点既是根节点，又是空节点 // son[][]存储树中每个节点的子节点 // cnt[]存储以每个节点结尾的单词数量 // 插入一个字符串 void insert(char *str) { int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - \u0026#39;a\u0026#39;; if (!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; } cnt[p] ++ ; } // 查询字符串出现的次数 int query(char *str) { int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - \u0026#39;a\u0026#39;; if (!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; } 并查集 —— 模板题 AcWing 836. 合并集合, AcWing 837. 连通块中点的数量 按秩合并\n字符按字符串读入\n(1)朴素并查集：\nint p[N]; //存储每个点的祖宗节点 // 返回x的祖宗节点 int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } // 初始化，假定节点编号是1~n for (int i = 1; i \u0026lt;= n; i ++ ) p[i] = i; // 合并a和b所在的两个集合： p[find(a)] = find(b); (2)维护size的并查集：\nint p[N], size[N]; //p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量 // 返回x的祖宗节点 int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } // 初始化，假定节点编号是1~n for (int i = 1; i \u0026lt;= n; i ++ ) { p[i] = i; size[i] = 1; } // 合并a和b所在的两个集合： p[find(a)] = find(b); size[b] += size[a]; (3)维护到祖宗节点距离的并查集：\nint p[N], d[N]; //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离 // 返回x的祖宗节点 int find(int x) { if (p[x] != x) { int u = find(p[x]); d[x] += d[p[x]]; p[x] = u; } return p[x]; } // 初始化，假定节点编号是1~n for (int i = 1; i \u0026lt;= n; i ++ ) { p[i] = i; d[i] = 0; } // 合并a和b所在的两个集合： p[find(a)] = find(b); d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量 堆 —— 模板题 AcWing 838. 堆排序, AcWing 839. 模拟堆 维护集合的数据结构 （大根堆，父节点值不小于子节点值）\n// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1 // pos[k]存储第k个插入的点在堆中的位置 // ord[k]存储堆中下标是k的点是第几个插入的 int h[N], ph[N], hp[N], size; // 交换两个点，及其映射关系 void heap_swap(int a, int b) { //swap(ph[hp[a]],ph[hp[b]]); 根据题意 //swap(hp[a], hp[b]); swap(h[a], h[b]); } void down(int u) { int t = u; if (u * 2 \u0026lt;= size \u0026amp;\u0026amp; h[u * 2] \u0026lt; h[t]) t = u * 2; if (u * 2 + 1 \u0026lt;= size \u0026amp;\u0026amp; h[u * 2 + 1] \u0026lt; h[t]) t = u * 2 + 1; if (u != t) { heap_swap(u, t); down(t); } } void up(int u) { while (u / 2 \u0026amp;\u0026amp; h[u] \u0026lt; h[u / 2]) { heap_swap(u, u / 2); u \u0026gt;\u0026gt;= 1; } } // O(n)建堆 for (int i = n / 2; i; i -- ) down(i); heap[++size] = x; up(size); //添加元素 heap[1]; //堆顶元素 heap[1]=heap[size]; size--; down(1);//删除第size个结点 heap[k]=heap[size]; size---; down(k);up(k);//删除第k个结点 heap[k]=x; down(k); up(k); //将第k个元素赋值为x 一般哈希 —— 模板题 AcWing 840. 模拟散列表 (1) 拉链法 int h[N], e[N], ne[N], idx; // 向哈希表中插入一个数 void insert(int x) { int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx ++ ; } // 在哈希表中查询某个数是否存在 bool find(int x) { int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) if (e[i] == x) return true; return false; } (2) 开放寻址法 int h[N]; // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置 int find(int x) { int t = (x % N + N) % N; while (h[t] != null \u0026amp;\u0026amp; h[t] != x) { t ++ ; if (t == N) t = 0; } return t; } 字符串哈希 —— 模板题 AcWing 841. 字符串哈希 核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低 小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果。\ntypedef unsigned long long ULL; const int P = 131 or 13331 ; ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64 // 初始化 p[0] = 1; for (int i = 1; i \u0026lt;= n; i ++ ) { h[i] = h[i - 1] * P + str[i]; p[i] = p[i - 1] * P; } // 计算子串 str[l ~ r] 的哈希值 ULL get(int l, int r) { return h[r] - h[l - 1] * p[r - l + 1]; } C++ STL简介 所有容器都有size() empty() vector, 变长数组，倍增的思想 size() 返回元素个数 empty() 返回是否为空 clear() 清空 front()/back() push_back()/pop_back() begin()/end() [] 支持比较运算，按字典序 vector\u0026lt;int\u0026gt; a(10,2); a.empty(); pair\u0026lt;int, int\u0026gt; first, 第一个元素 second, 第二个元素 支持比较运算，以first为第一关键字，以second为第二关键字（字典序） pair\u0026lt;int,int\u0026gt; p; p=make_pair(1,1); p={1,1}; string，字符串 size()/length() 返回字符串长度 empty() clear() substr(起始下标，(子串长度)) 返回子串 c_str() 返回字符串所在字符数组的起始地址 strcpy(c,s.c_str());//c_str()的使用方法 queue, 队列 没有clear函数 清空用新建queue size() empty() push() 向队尾插入一个元素 front() 返回队头元素 back() 返回队尾元素 pop() 弹出队头元素 priority_queue, 优先队列，默认是大根堆 push() 插入一个元素 top() 返回堆顶元素 pop() 弹出堆顶元素 定义成小根堆的方式：priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; q; stack, 栈 size() empty() push() 向栈顶插入一个元素 top() 返回栈顶元素 pop() 弹出栈顶元素 deque, 双端队列 size() empty() clear() front()/back() push_back()/pop_back() push_front()/pop_front() begin()/end() [] set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列 size() empty() clear() begin()/end() ++, -- 返回前驱和后继，时间复杂度 O(logn) set/multiset insert() 插入一个数 find() 查找一个数 count() 返回某一个数的个数 erase() (1) 输入是一个数x，删除所有x O(k + logn) (2) 输入一个迭代器，删除这个迭代器 lower_bound()/upper_bound() lower_bound(x) 返回大于等于x的最小的数的迭代器 upper_bound(x) 返回大于x的最小的数的迭代器 map/multimap insert() 插入的数是一个pair erase() 输入的参数是pair或者迭代器 find() [] 注意multimap不支持此操作。 时间复杂度是 O(logn) lower_bound()/upper_bound() unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表 和上面类似，增删改查的时间复杂度是 O(1) 不支持 lower_bound()/upper_bound()， 迭代器的++，-- bitset, 圧位 bitset\u0026lt;10000\u0026gt; s; ~, \u0026amp;, |, ^ \u0026gt;\u0026gt;, \u0026lt;\u0026lt; ==, != [] count() 返回有多少个1 none() 判断是否全为0 any() 判断是否至少有一个1 set() 把所有位置成1 set(k, v) 将第k位变成v reset() 把所有位变成0 flip() 等价于~ flip(k) 把第k位取反 作者：yxc 链接：https://www.acwing.com/blog/content/404/ 来源：AcWing 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n第三章 树与图的存储 树是一种特殊的图: 无环连通图，与图的存储方式相同。 对于无向图中的边ab，存储两条有向边a-\u0026gt;b, b-\u0026gt;a。 因此我们可以只考虑有向图的存储。\n(1) 邻接矩阵：g[a][b] 存储边a-\u0026gt;b (2) 邻接表： // 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点 int h[N], e[N], ne[N], idx; // 添加一条边a-\u0026gt;b void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } // 初始化 idx = 0; memset(h, -1, sizeof h); 树与图的遍历 时间复杂度 O(n+m)O(n+m), nn 表示点数，mm 表示边数\n(1) 深度优先遍历 —— 模板题 AcWing 846. 树的重心 int dfs(int u) { st[u] = true; // st[u] 表示点u已经被遍历过 for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) dfs(j); } } (2) 宽度优先遍历 —— 模板题 AcWing 847. 图中点的层次 queue\u0026lt;int\u0026gt; q; st[1] = true; // 表示1号点已经被遍历过 q.push(1); while (q.size()) { int t = q.front(); q.pop(); for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) { st[j] = true; // 表示点j已经被遍历过 q.push(j); } } } 拓扑排序 —— 模板题 AcWing 848. 有向图的拓扑序列 时间复杂度 O(n+m)O(n+m), nn 表示点数，mm 表示边数\nbool topsort() { int hh = 0, tt = -1; // d[i] 存储点i的入度 for (int i = 1; i \u0026lt;= n; i ++ ) if (!d[i]) q[ ++ tt] = i; while (hh \u0026lt;= tt) { int t = q[hh ++ ]; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (-- d[j] == 0) q[ ++ tt] = j; } } // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。 return tt == n - 1; } 最短路 单源最短路\n所有边权均为正：朴素Dijkstra O(n^2)；堆优化版的Dijkstra(mlogn)\n存在负权变：Bellman-Ford O(nm) ； SPFA（队列优化Bellman-Ford) 一般：O(m) 最坏 O(nm)\n多元汇最短路：Floyed算法 O(n^3)\n朴素dijkstra算法 —— 模板题 AcWing 849. Dijkstra求最短路 I 基于贪心 时间复杂是 O(n^2+m), n 表示点数，m 表示边数\nint g[N][N]; // 存储每条边， int dist[N]; // 存储1号点到每个点的最短距离 bool st[N]; // 存储每个点的最短路是否已经确定 // 求1号点到n号点的最短路，如果不存在则返回-1 int dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i \u0026lt; n - 1; i ++ ) { int t = -1; // 在还未确定最短路的点中，寻找距离最小的点 for (int j = 1; j \u0026lt;= n; j ++ ) if (!st[j] \u0026amp;\u0026amp; (t == -1 || dist[t] \u0026gt; dist[j])) t = j; // 用t更新其他点的距离 for (int j = 1; j \u0026lt;= n; j ++ ) dist[j] = min(dist[j], dist[t] + g[t][j]); st[t] = true; } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } 堆优化版dijkstra —— 模板题 AcWing 850. Dijkstra求最短路 II 时间复杂度 O(mlogn), n 表示点数，m 表示边数\ntypedef pair\u0026lt;int, int\u0026gt; PII; int n; // 点的数量 int h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边 int dist[N]; // 存储所有点到1号点的距离 bool st[N]; // 存储每个点的最短距离是否已确定 // 求1号点到n号点的最短距离，如果不存在，则返回-1 int dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; priority_queue\u0026lt;PII, vector\u0026lt;PII\u0026gt;, greater\u0026lt;PII\u0026gt;\u0026gt; heap; heap.push({0, 1}); // first存储距离，second存储节点编号 while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] \u0026gt; distance + w[i]) { dist[j] = distance + w[i]; heap.push({dist[j], j}); } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } Bellman-Ford算法 —— 模板题 AcWing 853. 有边数限制的最短路 时间复杂度 O(nm), n 表示点数，m表示边数 注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题。\nint n, m; // n表示点数，m表示边数 int dist[N]; // dist[x]存储1到x的最短路距离 struct Edge // 边，a表示出点，b表示入点，w表示边的权重 { int a, b, w; }edges[M]; // 求1到n的最短路距离，如果无法从1走到n，则返回-1。 int bellman_ford() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。 for (int i = 0; i \u0026lt; n; i ++ ) { for (int j = 0; j \u0026lt; m; j ++ ) { int a = edges[j].a, b = edges[j].b, w = edges[j].w; if (dist[b] \u0026gt; dist[a] + w) dist[b] = dist[a] + w; } } if (dist[n] \u0026gt; 0x3f3f3f3f / 2) return -1; return dist[n]; } spfa 算法（队列优化的Bellman-Ford算法） —— 模板题 AcWing 851. spfa求最短路 时间复杂度 平均情况下 O(m)，最坏情况下 O(nm), n 表示点数，m 表示边数\nint n; // 总点数 int h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边 int dist[N]; // 存储每个点到1号点的最短距离 bool st[N]; // 存储每个点是否在队列中 // 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1 int spfa() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; queue\u0026lt;int\u0026gt; q; q.push(1); st[1] = true; while (q.size()) { auto t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] \u0026gt; dist[t] + w[i]) { dist[j] = dist[t] + w[i]; if (!st[j]) // 如果队列中已存在j，则不需要将j重复插入 { q.push(j); st[j] = true; } } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } spfa判断图中是否存在负环 —— 模板题 AcWing 852. spfa判断负环 时间复杂度是 O(nm), n 表示点数，m 表示边数\nint n; // 总点数 int h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边 int dist[N], cnt[N]; // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数 bool st[N]; // 存储每个点是否在队列中 // 如果存在负环，则返回true，否则返回false。 bool spfa() { // 不需要初始化dist数组 // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。 queue\u0026lt;int\u0026gt; q; for (int i = 1; i \u0026lt;= n; i ++ ) { q.push(i); st[i] = true; } while (q.size()) { auto t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] \u0026gt; dist[t] + w[i]) { dist[j] = dist[t] + w[i]; cnt[j] = cnt[t] + 1; if (cnt[j] \u0026gt;= n) return true; // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环 if (!st[j]) { q.push(j); st[j] = true; } } } } return false; } floyd算法 —— 模板题 AcWing 854. Floyd求最短路 时间复杂度是 O(n3)O(n3), nn 表示点数 初始化： for (int i = 1; i \u0026lt;= n; i ++ ) for (int j = 1; j \u0026lt;= n; j ++ ) if (i == j) d[i][j] = 0; else d[i][j] = INF; // 算法结束后，d[a][b]表示a到b的最短距离 void floyd() { for (int k = 1; k \u0026lt;= n; k ++ ) for (int i = 1; i \u0026lt;= n; i ++ ) for (int j = 1; j \u0026lt;= n; j ++ ) d[i][j] = min(d[i][j], d[i][k] + d[k][j]); } 最小生成树（无向图） Prim : 朴素版Prim O(n^2)(稠密图) ; 堆优化版Prim O(mlogn)(一般不会用)\nKruskal : O(mlogm)(稀疏图)\n朴素版prim算法 —— 模板题 AcWing 858. Prim算法求最小生成树 时间复杂度是 O(n^2+m), n 表示点数，m 表示边数\n初始化距离为正无穷，迭代所有点，找到集合中最近的点，更新它到集合的距离，把t加到集合中。\nint n; // n表示点数 int g[N][N]; // 邻接矩阵，存储所有边 int dist[N]; // 存储其他点到当前最小生成树的距离 bool st[N]; // 存储每个点是否已经在生成树中 // 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和 int prim() { memset(dist, 0x3f, sizeof dist); int res = 0; for (int i = 0; i \u0026lt; n; i ++ ) { int t = -1; for (int j = 1; j \u0026lt;= n; j ++ ) if (!st[j] \u0026amp;\u0026amp; (t == -1 || dist[t] \u0026gt; dist[j])) t = j; if (i \u0026amp;\u0026amp; dist[t] == INF) return INF; if (i) res += dist[t]; st[t] = true; for (int j = 1; j \u0026lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]); } return res; } Kruskal算法 —— 模板题 AcWing 859. Kruskal算法求最小生成树 时间复杂度是 O(mlogm), n 表示点数，m 表示边数\nint n, m; // n是点数，m是边数 int p[N]; // 并查集的父节点数组 struct Edge // 存储边 { int a, b, w; // 重载小于号运算符 // 用于比较两个Edge对象的大小关系 bool operator \u0026lt; (const Edge \u0026amp;W) const { return w \u0026lt; W.w; // 如果当前对象的边权小于W对象的边权，返回true，否则返回false } }edges[M]; int find(int x) // 并查集核心操作 { if (p[x] != x) p[x] = find(p[x]); return p[x]; } int kruskal() { sort(edges, edges + m); for (int i = 1; i \u0026lt;= n; i ++ ) p[i] = i; // 初始化并查集 int res = 0, cnt = 0; for (int i = 0; i \u0026lt; m; i ++ ) { int a = edges[i].a, b = edges[i].b, w = edges[i].w; a = find(a), b = find(b); if (a != b) // 如果两个连通块不连通，则将这两个连通块合并 { p[a] = b; res += w; cnt ++ ; } } if (cnt \u0026lt; n - 1) return INF; return res; } 染色法（本质dfs)判别二分图 —— 模板题 AcWing 860. 染色法判定二分图 给定一个 n 个点m条边的无向图，图中可能存在重边和自环。请你判断这个图是否是二分图。\n时间复杂度是 O(n+m), n 表示点数，m 表示边数\nint n; // n表示点数 int h[N], e[M], ne[M], idx; // 邻接表存储图 int color[N]; // 表示每个点的颜色，-1表示为染色，0表示白色，1表示黑色 // 参数：u表示当前节点，c表示当前点的颜色 bool dfs(int u, int c) { color[u] = c; for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (color[j] == -1) { if (!dfs(j, !c)) return false; } else if (color[j] == c) return false; } return true; } bool check() { memset(color, -1, sizeof color); bool flag = true; for (int i = 1; i \u0026lt;= n; i ++ ) if (color[i] == -1) if (!dfs(i, 0)) { flag = false; break; } return flag; } 匈牙利算法 —— 模板题 AcWing 861. 二分图的最大匹配 时间复杂度最坏是 O(nm)，实际运行时间一般远小于O(nm)， n 表示点数，m 表示边数\n做错一件事，错过一件事\nint n1, n2; // n1表示第一个集合中的点数，n2表示第二个集合中的点数 int h[N], e[M], ne[M], idx; // 邻接表存储所有边，匈牙利算法中只会用到从第二个集合指向第一个集合的边，所以这里只用存一个方向的边 int match[N]; // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个 bool st[N]; // 表示第二个集合中的每个点是否已经被遍历过 bool find(int x) { for (int i = h[x]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) { st[j] = true; if (match[j] == 0 || find(match[j])) { match[j] = x; return true; } } } return false; } // 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点 int res = 0; for (int i = 1; i \u0026lt;= n1; i ++ ) { memset(st, false, sizeof st); if (find(i)) res ++ ; } 作者：yxc 链接：https://www.acwing.com/blog/content/405/ 来源：AcWing 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n第四章 试除法判定质数 —— 模板题 AcWing 866. 试除法判定质数 质数：大于1的整数中，如果只包含1和本身两个约束，称为质数（素数）\n（1）判定，试除法\n（2）分解质因数\nbool is_prime(int x) { if (x \u0026lt; 2) return false; for (int i = 2; i \u0026lt;= x / i; i ++ ) if (x % i == 0) return false; return true; } 试除法分解质因数 —— 模板题 AcWing 867. 分解质因数 void divide(int x) { for (int i = 2; i \u0026lt;= x / i; i ++ ) if (x % i == 0) { int s = 0; while (x % i == 0) x /= i, s ++ ; cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; } if (x \u0026gt; 1) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; endl; } 朴素筛法求素数 —— 模板题 AcWing 868. 筛质数 int primes[N], cnt; // primes[]存储所有素数 bool st[N]; // st[x]存储x是否被筛掉 void get_primes(int n) { for (int i = 2; i \u0026lt;= n; i ++ ) { if (st[i]) continue; primes[cnt ++ ] = i; for (int j = i; j \u0026lt;= n; j += i) st[j] = true; } } 线性筛法求素数 —— 模板题 AcWing 868. 筛质数 被最小质因子筛掉\nint primes[N], cnt; // primes[]存储所有素数 bool st[N]; // st[x]存储x是否被筛掉 void get_primes(int n) { for (int i = 2; i \u0026lt;= n; i ++ ) { if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] \u0026lt;= n / i; j ++ ) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } 试除法求所有约数 —— 模板题 AcWing 869. 试除法求约数 int范围内约数个数最多为1500个左右\nvector\u0026lt;int\u0026gt; get_divisors(int x) { vector\u0026lt;int\u0026gt; res; for (int i = 1; i \u0026lt;= x / i; i ++ ) if (x % i == 0) { res.push_back(i); if (i != x / i) res.push_back(x / i); } sort(res.begin(), res.end()); return res; } 约数个数和约数之和 —— 模板题 AcWing 870. 约数个数, AcWing 871. 约数之和 如果 N = p1^c1 * p2^c2 * ... *pk^ck 约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1) 约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck) 欧几里得算法 —— 模板题 AcWing 872. 最大公约数 int gcd(int a, int b) { return b ? gcd(b, a % b) : a; } 求欧拉函数 —— 模板题 AcWing 873. 欧拉函数 欧拉函数公式（容斥原理) : n*(1-p1)*(1-p2)\u0026hellip;(1-pk)\nint phi(int x) { int res = x; for (int i = 2; i \u0026lt;= x / i; i ++ ) if (x % i == 0) { res = res / i * (i - 1); while (x % i == 0) x /= i; } if (x \u0026gt; 1) res = res / x * (x - 1); return res; } 筛法求欧拉函数 —— 模板题 AcWing 874. 筛法求欧拉函数 O(n) 线性求所有数的欧拉函数\n应用：欧拉定理：a与n互质 a^φ(n)=1(mod n)\nint primes[N], cnt; // primes[]存储所有素数 int euler[N]; // 存储每个数的欧拉函数 bool st[N]; // st[x]存储x是否被筛掉 void get_eulers(int n) { euler[1] = 1; for (int i = 2; i \u0026lt;= n; i ++ ) { if (!st[i]) { primes[cnt ++ ] = i; euler[i] = i - 1; } for (int j = 0; primes[j] \u0026lt;= n / i; j ++ ) { int t = primes[j] * i; st[t] = true; if (i % primes[j] == 0) { euler[t] = euler[i] * primes[j]; break; } euler[t] = euler[i] * (primes[j] - 1); } } } 快速幂 —— 模板题 AcWing 875. 快速幂 求 m^k mod p，时间复杂度 O(logk)。\nint qmi(int m, int k, int p) { int res = 1 % p, t = m; while (k) { if (k\u0026amp;1) res = res * t % p; t = t * t % p; k \u0026gt;\u0026gt;= 1; } return res; } 扩展欧几里得算法 —— 模板题 AcWing 877. 扩展欧几里得算法 // 求x, y，使得ax + by = gcd(a, b) int exgcd(int a, int b, int \u0026amp;x, int \u0026amp;y) { if (!b) { x = 1; y = 0; return a; } int d = exgcd(b, a % b, y, x); y -= (a/b) * x; return d; } 高斯消元 —— 模板题 AcWing 883. 高斯消元解线性方程组 O(n^3)时间内解n个方程n个未知数的解。\n解：无解 ； 无穷多组解 ； 唯一解 ；\n完美阶梯型：唯一解 *0=*非零 ： *无解 0=0 ： 无穷多组解 高斯消元：\n枚举每一列c：\n找到绝对值最大的一行 将该行换到最上面 将该行第一个数变成1 将下面所有行的第c列消成0 // a[N][N]是增广矩阵 int gauss() { int c, r; for (c = 0, r = 0; c \u0026lt; n; c ++ ) { int t = r; for (int i = r; i \u0026lt; n; i ++ ) // 找到绝对值最大的行 if (fabs(a[i][c]) \u0026gt; fabs(a[t][c])) t = i; if (fabs(a[t][c]) \u0026lt; eps) continue; for (int i = c; i \u0026lt;= n; i ++ ) swap(a[t][i], a[r][i]); // 将绝对值最大的行换到最顶端 for (int i = n; i \u0026gt;= c; i -- ) a[r][i] /= a[r][c]; // 将当前上的首位变成1 for (int i = r + 1; i \u0026lt; n; i ++ ) // 用当前行将下面所有的列消成0 if (fabs(a[i][c]) \u0026gt; eps) for (int j = n; j \u0026gt;= c; j -- ) a[i][j] -= a[r][j] * a[i][c]; r ++ ; } if (r \u0026lt; n) { for (int i = r; i \u0026lt; n; i ++ ) if (fabs(a[i][n]) \u0026gt; eps) return 2; // 无解 return 1; // 有无穷多组解 } for (int i = n - 1; i \u0026gt;= 0; i -- ) for (int j = i + 1; j \u0026lt; n; j ++ ) a[i][n] -= a[i][j] * a[j][n]; return 0; // 有唯一解 } 递归法求组合数 —— 模板题 AcWing 885. 求组合数 I 十万 1\u0026lt;b\u0026lt;a\u0026lt;2000 O(n^2)\n// c[a][b] 表示从a个苹果中选b个的方案数 for (int i = 0; i \u0026lt; N; i ++ ) for (int j = 0; j \u0026lt;= i; j ++ ) if (!j) c[i][j] = 1; else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod; 通过预处理逆元的方式求组合数 —— 模板题 AcWing 886. 求组合数 II 一万 1\u0026lt;b\u0026lt;a\u0026lt;10^5 O(logn)\n首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N] 如果取模的数是质数，可以用费马小定理求逆元 int qmi(int a, int k, int p) // 快速幂模板 { int res = 1; while (k) { if (k \u0026amp; 1) res = (LL)res * a % p; a = (LL)a * a % p; k \u0026gt;\u0026gt;= 1; } return res; } // 预处理阶乘的余数和阶乘逆元的余数 fact[0] = infact[0] = 1; for (int i = 1; i \u0026lt; N; i ++ ) { fact[i] = (LL)fact[i - 1] * i % mod; infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod; } ll C(ll n,ll m){ if(m\u0026gt;n) return 0ll; return fact[n]*infact[m]%mod*infact[n-m]%mod; } Lucas定理 —— 模板题 AcWing 887. 求组合数 III 组合数，1\u0026lt;b\u0026lt;a\n若p是质数，则对于任意整数 1 \u0026lt;= m \u0026lt;= n，有： C(n, m) = C(n % p, m % p) * C(n / p, m / p) (mod p) int qmi(int a, int k) // 快速幂模板 { int res = 1; while (k) { if (k \u0026amp; 1) res = (LL)res * a % p; a = (LL)a * a % p; k \u0026gt;\u0026gt;= 1; } return res; } int C(int a, int b) // 通过定理求组合数C(a, b) { int res = 1; for (int i = 1, j = a; i \u0026lt;= b; i ++, j -- ) { res = (LL)res * j % p; res = (LL)res * qmi(i, p - 2) % p; } return res; } int lucas(LL a, LL b) { if (a \u0026lt; p \u0026amp;\u0026amp; b \u0026lt; p) return C(a, b); return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p; } 分解质因数法求组合数 —— 模板题 AcWing 888. 求组合数 IV 当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：\n1. 筛法求出范围内的所有质数 2. 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^2 + n / p^3 + ... 3. 用高精度乘法将所有质因子相乘 int primes[N], cnt; // 存储所有质数 int sum[N]; // 存储每个质数的次数 bool st[N]; // 存储每个数是否已被筛掉 void get_primes(int n) // 线性筛法求素数 { for (int i = 2; i \u0026lt;= n; i ++ ) { if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] \u0026lt;= n / i; j ++ ) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } int get(int n, int p) // 求n！中的次数 { int res = 0; while (n) { res += n / p; n /= p; } return res; } vector\u0026lt;int\u0026gt; mul(vector\u0026lt;int\u0026gt; a, int b) // 高精度乘低精度模板 { vector\u0026lt;int\u0026gt; c; int t = 0; for (int i = 0; i \u0026lt; a.size(); i ++ ) { t += a[i] * b; c.push_back(t % 10); t /= 10; } while (t) { c.push_back(t % 10); t /= 10; } return c; } get_primes(a); // 预处理范围内的所有质数 for (int i = 0; i \u0026lt; cnt; i ++ ) // 求每个质因数的次数 { int p = primes[i]; sum[i] = get(a, p) - get(b, p) - get(a - b, p); } vector\u0026lt;int\u0026gt; res; res.push_back(1); for (int i = 0; i \u0026lt; cnt; i ++ ) // 用高精度乘法将所有质因子相乘 for (int j = 0; j \u0026lt; sum[i]; j ++ ) res = mul(res, primes[i]); 卡特兰数 —— 模板题 AcWing 889. 满足条件的01序列 给定n个0和n个1，它们按照某种顺序排成长度为2n的序列，满足任意前缀中0的个数都不少于1的个数的序列的数量为： $$ Cat(n) = C(2n, n) / (n + 1) $$\n容斥原理 找1~n中能至少被素数p1,p2,\u0026hellip;,pn一个整除的整数有多少个。\n位运算对应容斥原理集合，1~n中能被x整除的个数为n/x，奇数加上，偶数减去\nNIM(尼姆)游戏 —— 模板题 AcWing 891. Nim游戏 给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。\n我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。 所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。 NIM博弈不存在平局，只有先手必胜和先手必败两种情况。\n定理： NIM博弈先手必胜，当且仅当 A1 ^ A2 ^ … ^ An != 0\n公平组合游戏ICG 若一个游戏满足：\n由两名玩家交替行动； 在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关； 不能行动的玩家判负； 则称该游戏为一个公平组合游戏。 NIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件2和条件3。\n有向图游戏 给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。 任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。\nMex运算 设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即： mex(S) = min{x}, x属于自然数，且x不属于S\nSG函数 在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达节点y1, y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk 的SG函数值构成的集合再执行**mex(S)**运算的结果，即： SG(x) = mex({SG(y1), SG(y2), …, SG(yk)}) 特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G) = SG(s)。\nint sg(int x){ if (f[x] != -1) return f[x]; unordered_set\u0026lt;int\u0026gt; S; for(int i = 0; i \u0026lt; m; i++ ) { int sum = s[i]; if (x \u0026gt;= sum) S.insert(sg(x - sum)); } for (int i=0; ; i++ ) if (!S.count(i)) return f[x] = i; } 有向图游戏的和 —— 模板题 AcWing 893. 集合-Nim游戏 设G1, G2, …, Gm 是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。 有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即： SG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm)\n定理 有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。 有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。\n作者：yxc 链接：https://www.acwing.com/blog/content/406/ 来源：AcWing 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n时空复杂度分析 当处理ACM或笔试题时，通常时间限制为1秒或2秒。在这种情况下，C++代码中的操作次数应控制在10^7 到 10^8之间，这是最佳范围。\n以下是在不同数据规模下，代码的时间复杂度和算法选择的指导：\nn ≤ 30：指数级别，使用DFS+剪枝，状态压缩DP。 n ≤ 100：O(n^3)，适用于Floyd、DP、高斯消元。 n ≤ 1000：O(n^2)或O(n^2*logn)，适用于DP、分治、高斯消元、朴素版Dijkstra、朴素版Prim、Bellman-Ford。 n ≤ 10000：O(n * √n)，适用于块状链表、分块、莫队。 n ≤ 100000：O(nlogn)，适用于各种排序、线段树、树状数组、集合/映射、堆、拓扑排序、Dijkstra+堆、Prim、Kruskal、SPFA、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树。 n \u0026lt; 1000000：O(n)或常数较小的O(nlogn)，适用于单调队列、哈希映射、双指针扫描、BFS、并查集、KMP、AC自动机、常数较小的O(nlogn)的做法（如排序、树状数组、堆、Dijkstra、SPFA）。 n \u0026lt; 10000000：O(n)，适用于双指针扫描、KMP、AC自动机、线性筛素数。 n ≤ 10^9：O(n√n)，适用于判断质数。 n ≤ 10^18：O(logn)，适用于最大公约数、快速幂、数位DP。 n ≤ 10^1000：O((logn)^2)，适用于高精度加减乘除。 n ≤ 10^100000：O(logk × loglogk)，其中k表示位数，适用于高精度加减、FFT/NTT。 动态规划计算量 ： 状态数 * 状态转移数量\n1 Byte = 8 bit\n1KB = 1024 Byte\n1MB = 102410241024 Byte\n1GB = 1024 * 1024 * 1024 Byte\nint 4 Byte\nchar 1 Byte\ndouble, long long 8 Byte\n动态规划 常见模型\n背包 九讲 01背包 每件物品最多可以用一次\n体积从大到小的原因 ： 如果从小到大，则f[j-w[i]]+v[i]实际是f[i-1][j-w[i]]+v[i]，需要的是上一维度f[i-1]维度，所以从大到小可以使用上一维度的，因为这一维度的还没有被计算到。\nfor(int i=1;i\u0026lt;=N;i++){ for(int j=V;j\u0026gt;=w[i];j--){ f[j]=max(f[j],f[j-w[i]]+v[i]); } } 完全背包 每件物品可以用无限次\nfor(int i=1;i\u0026lt;=N;i++){ for(int j=w[i];j\u0026lt;=V;j++){ f[j]=max(f[j],f[j-w[i]]+v[i]); } } 多重背包 每件物品特定数量\n二进制优化 for(int i=1;i\u0026lt;=N;i++){ cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c; //权重a,价值b，数量c int k=1; while(k\u0026lt;=c){ cnt++; c-=k; w[cnt]=k*a; v[cnt]=k*b; k*=2; } if(c){ cnt++; w[cnt]=c*a; v[cnt]=c*b; } } //之后用01背包 单调队列优化 for(int i=1;i\u0026lt;=N;i++){ // 遍历每件物品 memcpy(g, f, sizeof g); // 将上一轮的最优解拷贝给g数组 for(int r=0;r\u0026lt;v[i];r++){ // 遍历余数r（用于优化循环） int h=0,t=-1; // 滑动窗口的起始索引和结束索引 for(int l=r;l\u0026lt;=V;l+=v[i]){ // 遍历背包容量，间隔为当前物品体积 while(h\u0026lt;=t \u0026amp;\u0026amp; l-q[h]\u0026gt;s[i]*v[i]) h++; // 如果窗口左边界超出限制，则左边界右移 while(h\u0026lt;=t \u0026amp;\u0026amp; g[q[t]] + (l-q[t])/v[i]*w[i]\u0026lt;=g[l]) t--; // 保持窗口单调性，将窗口内不符合条件的解移除 q[++t] = l; // 将当前状态的背包容量加入窗口 f[l] = g[q[h]] + (l-q[h])/v[i]*w[i]; // 更新当前状态的最优解 } } } 分组背包 若干组，一组只能选一个\nfor(int i=1;i\u0026lt;=N;i++){ for(int j=V;j\u0026gt;=0;j--){ for(int k=1;k\u0026lt;=s[i];k++){ if(w[i][k]\u0026lt;=j){ f[j]=max(f[j],f[j- w[i][k] ]+v[i][k]); } } } } 混合背包 转换成01背包问题\nfor(int i=1;i\u0026lt;=N;i++){ cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;s; if(s==-1) s=1; else if(s==0) s=V/a; k=1; while(k\u0026lt;=s){ s-=k; cnt++; v[cnt] = k*a; w[cnt] = k*b; k*=2; } if(s){ cnt++; v[cnt] = s*a; w[cnt] = s*b; } } for(int i=1;i\u0026lt;=cnt;i++){ for(int j=V;j\u0026gt;=v[i];j--){ f[j] = max(f[j], f[j-v[i]]+w[i]); } } 二维费用的背包问题 采用两层循环\ncin\u0026gt;\u0026gt;N\u0026gt;\u0026gt;V\u0026gt;\u0026gt;W; for(int i=1;i\u0026lt;=N;i++){ cin\u0026gt;\u0026gt;v\u0026gt;\u0026gt;m\u0026gt;\u0026gt;w; for(int j=V;j\u0026gt;=v;j--){ for(int k=W;k\u0026gt;=m;k--){ f[j][k] = max(f[j][k], f[j-v][k-m] + w); } } } cout\u0026lt;\u0026lt;f[V][W]\u0026lt;\u0026lt;endl; 线性dp 数字三角形 for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=i;j++){ a[i][j]+=max(a[i-1][j],a[i-1][j-1]); } } LIS for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;i;j++){ if(a[j]\u0026lt;a[i]) f[i]=max(f[j]+1,f[i]); } } for(int i=1;i\u0026lt;=n;i++){ ma=max(f[i],ma); } LCS for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=m;j++){ f[i][j]=max(f[i-1][j],f[i][j-1]); if(a[i]==b[j]) f[i][j]=f[i-1][j-1]+1; } } 区间dp 石子合并 memset(f, 0x3f, sizeof f); for(int len=2;len\u0026lt;=n;len++){ for(int i=1;i+len-1\u0026lt;=n;i++){ int j=i+len-1; if (len == 1) { f[i][j] = 0; // 边界初始化 continue; } for(int k=i;k\u0026lt;j;k++){ f[l][r]=min(f[l][r],f[l][k]+f[k+1][r]+s[r]-s[l-1]); } } } cout\u0026lt;\u0026lt;f[1][n]; 数位统计dp 状态表示\n分情况讨论\n状态压缩 dp 蒙德里安的梦想\n最短Hamilton距离\n树形dp 没有上司的舞会\n记忆化 滑雪\n#include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long const int maxn=1e4; ll f[maxn][maxn],g[maxn][maxn]; //distance struct node{ ll i,j,num; }a[maxn]; struct cmp { bool operator () (node x,node y){ return x.num\u0026gt;y.num; } }; int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); ll n,m,ma=-1; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; priority_queue\u0026lt;node, vector\u0026lt;node\u0026gt;,cmp\u0026gt;pq; for(ll i=1;i\u0026lt;=n;i++){ for(ll j=1;j\u0026lt;=m;j++){ f[i][j]=1; node a; a.i=i; a.j=j; cin\u0026gt;\u0026gt;a.num; g[i][j]=a.num; pq.push(a); } } while(!pq.empty()){ node t=pq.top(); pq.pop(); ll i=t.i; ll j=t.j; ll nu=t.num; if(g[i-1][j]\u0026lt;nu) f[i][j]=max(f[i][j],f[i-1][j]+1); if(g[i+1][j]\u0026lt;nu) f[i][j]=max(f[i][j],f[i+1][j]+1); if(g[i][j-1]\u0026lt;nu) f[i][j]=max(f[i][j],f[i][j-1]+1); if(g[i][j+1]\u0026lt;nu) f[i][j]=max(f[i][j],f[i][j+1]+1); ma=max(ma,f[i][j]); } cout\u0026lt;\u0026lt;ma\u0026lt;\u0026lt;endl; return 0; } 习题课 ","permalink":"https://showguan.github.io/en/posts/tech/acwing/","summary":"acwing算法学习 [TOC] 第一章 课上：学思想 课下：背代码 题目，一道题写好几遍 理解没有任何意义，体力活+脑力活 记忆力 毅力/自制力 沉下心背东西 快速排","title":""},{"content":"title = \u0026lsquo;后端八股学习笔记\u0026rsquo; date = 2024-04-06T17:47:22+08:00 draft = false\n+++\n后端八股学习笔记 想要生活能进步，就不能走退步路。\n计算机网络 网络是把主机连接起来，而互联网(Internet)是把多种不同的网络连接起来，因此互联网是网络的网络，而互联网(Internet)是全球范围的互联网。 ISP 互联网服务提供商ISP可以从互联网管理机构获得许多IP地址，同时拥有通信线路以及路由器等联网设备，个人或机构向ISP缴纳一定的费用就可以接入互联网。\n目前的互联网是一种多层次ISP结构，ISP根据覆盖面积的大小分为第一层ISP，区域ISP和接入ISP。**互联网交换点IXP（Internet Exchange Point)**允许两个ISP直接相连而不用经过第三个ISP。\n主机之间的通信方式 客户-服务器（C/S）：客户是服务的请求方，服务器 是服务的提供方。\n对等（P2P）：不区分客户和服务器\n电路交换与分组交换 1.电路交换 电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到10%。\n2.分组交换 每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。\n在同一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发的过程，分组交换也使用了存储转发过程。\n时延 总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延\n1.排队时延 分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。\n2.处理时延 主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。\n3.传输时延 主机或路由器传输数据帧所需要的时间。 $$ delay = \\frac{l(bit)}{v(bit/s)} $$ $l$:数据帧的长度, $v$:传输速率\n4.传播时延 电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。 $$ delay = \\frac{l(m)}{v(m/s)} $$ $l$:表示信道长度， $v$:表示电磁波在信道上的传播速度\n计算机网络体系结构 1.五层协议 应用层：为特定应用程序提供数据传输服务，例如HTTP，DNS等协议。数据单位为报文。\n传输层：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议UDP，提供无连接的、尽最大努力的数据传输服务，数据单位为用户数据报。TCP主要提供完整性服务，UDP主要提供及时性服务。\n网络层：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。\n数据链路层：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。\n物理层：考虑的是怎样在传输媒体上传输比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。\n2.OSI (Open Systems Interconnection，开放式系统互联)\n其中表示层和会话层用途如下：\n表示层：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。 会话层：建立及管理会话。 五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。\n3.TCP/IP 只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。\nTCP/IP体系结构不严格遵循OSI分层概念，应用层可能会直接使用IP层或者网络接口层。\n4.数据在各层之间的传递过程 在向下的过程中，需要添加下层协议所需要的首部和尾部，而在向上的过程中不断拆开首部和尾部。\n路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。\n物理层 通信方式 根据信息在传输线上的传送方向，分为一下三种通信方式：\n单工通信：单向传输 半双工通信：双向交替传输 全双工通信：双向同时传输 带通调制 模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号。\n链路层 基本问题 1.封装成帧 把网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。\n2.透明传输 透明表示一个实际存在的事物看起来好像不存在一样。\n帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。\n3.差错检测 目前数据链路层广泛使用了**循环冗余检验（CRC，Cyclic Redundancy Check）**来检查比特差错。\n信道分类 1.广播信号 一对多通信，一个节点发送的数据能够被广播信道上所有的节点接受到。\n所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。\n主要有两种控制方法进行协调，一个是使用信道复用技术；另一个是使用CSMA/CD协议。\n2.点对点信道 一对一通信。\n因为不会发生碰撞，因此也比较简单，使用PPP（Point-to-Point Protocol）协议进行控制。\n信道复用技术 1.频分复用 频分复用的所有主机在相同的时间占用不同的频率带宽资源。\n2.时分复用 时分复用的所有主机在不同的事件占用相同的频率带宽资源。\n使用频分复用和时分复用进行通信，在通信的过程中主机会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其他用户使用，因此这两种方式对信道的利用率都不高。\n3.统计时分复用 是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。\n4.波分复用 光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。\n5.码分复用 为每个用户分配$m\\ bit$ 的码片，并且所有的码片正交，对于任意两个码片$\\vec{S}$和$\\vec{T}$有 $$ \\frac{1}{m}\\vec{S}\\ \\cdot \\vec{T} = 0 $$ 为了讨论方便，取$m=8$, 设码片$\\vec{S}$为$00011011$。在拥有该码片额用户发送比特1时就发送该码片，发送比特0时就发送该码片的反码$11100100$\n在计算时将$00011011$记作（$-1-1-1+1+1-1+1+1$）,可以得到： $$ \\frac{1}{m}\\vec{S} \\cdot \\vec{S}=1 $$\n$$ \\frac{1}{m}\\vec{S} \\cdot \\vec{S}\u0026rsquo;=-1 $$\n其中$\\vec{S}\u0026rsquo;$是$\\vec{S}$的反码\n利用上面的式子可知，当接收端使用码片$\\vec{S}\u0026rsquo;$对接受到的数据进行内积运算时， 结果为0的是其它用户发送的数据，结果为1的是用户发送的比特1,结果为-1的是用户发送的比特0。\n码分复用需要发送的数据量为原先的m倍。\nCSMA/CD协议 CSMA/CD表示载波监听多点接入/碰撞检测。\n多点接入：说明这是总线型网络，许多主机以多点的方式连接到总线上 载波监听：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。 碰撞检测：在发送中，如果监听到信道已有其他主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。 记端到端的传播时延为$\\tau$, 最先发送的站点最多经过$2\\tau$就可以知道是否发生了碰撞，称$2\\tau$为争用期。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。\n当发生碰撞时， 站点要停止发送，等待一段时间再发送。这个时间采用截断二进制指数退避算法来确定。从离散的整数集合${0, 1, \u0026hellip;, (2^k-1)}$中随机取出一个数，记作$r$， 然后取$r$倍的争用期作为重传等待时间。\nPPP协议 互联网用户通常需要连接到某个ISP之后才能接入互联网，PPP协议时用户计算机和ISP进行通信时所使用的数据链路层协议。\nPPP的帧格式：\nF字段为帧的定界符 A和C字段暂时没有意义 FCS字段是使用CRC的检验序列 信息部分的长度不超过1500 MAC地址 MAC地址是链路层地址，长度为6字节（48位）， 用于唯一表示网络适配器（网卡）。\n一台主机拥有多少个网络适配器就有多少个MAC地址。例如笔记本电脑普遍存在无限网络适配器和有线网络适配器，因此就有两个MAC地址。\n局域网 局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有， 且地理范围和站点数目均有限。\n主要有以太网、令牌环网络、FDDI和ATM等局域网技术，目前以太网占领着有线局域网市场。\n可以按照网络拓扑结构对局域网进行分类。\n以太网 以太网是一种星型拓扑结构局域网。\n早起使用集线器进行连接，集线器是一种物理层设备。作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其他所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。\n目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据MAC地址进行存储转发。\n以太网格式：\n类型：标记上层使用的协议 数据：长度为46~1500之间，如果太小则需要填充 FCS：真检验序列，使用的时CRC检验方法 交换机 ","permalink":"https://showguan.github.io/en/posts/tech/%E5%90%8E%E7%AB%AF%E5%85%AB%E8%82%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","summary":"title = \u0026lsquo;后端八股学习笔记\u0026rsquo; date = 2024-04-06T17:47:22+08:00 draft = false +++ 后端八股学习笔记 想要生活能进步，就不能走退步路。 计算机网络 网络是把主机连接起来","title":""}]