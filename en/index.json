[{"content":"hugo new content posts/my-first-post.md\n","permalink":"https://showguan.github.io/en/posts/life/my-first-post/","summary":"hugo new content posts/my-first-post.md","title":"My First Post"},{"content":" 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 ","permalink":"https://showguan.github.io/en/links/","summary":"名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客","title":"🤝友链"},{"content":" 英文名: Kennem 职业: Still a Stuent 运动: Gaming ","permalink":"https://showguan.github.io/en/about/","summary":"英文名: Kennem 职业: Still a Stuent 运动: Gaming","title":"🙋🏻‍♂️关于"},{"content":"机器学习简介 Different types of Functions\nRegression : The function outputs a scalar(标量）.\npredict the PM2.5 Classification ： Given options (classes), the function outputs the correct one.\nSpam filtering Structured Learning ： create something with structure(image, document)\nExample : YouTube Channel\n1.Function with Unknown Parameters. $$ y=b+wx_1 $$\n2.Define Loss from Training Data Loss is a function of parameters $$ L(b,w) $$\nLoss : how good a set of values is. L is mean absolute error (MAE) $$ e=\\left | y-\\hat{y} \\right | $$\nL is mean square error (MSE) $$ e=(y-\\hat{y})^2 $$\n$$ L=\\frac{1}{N} \\sum_{n}^{}e_n $$\n3.Optimization $$ w^,b^=arg,\\min_{w,b} ,L $$\nGradient Descent\n(Randomly) Pick an initial value ： $$ w^0 $$\nCompute : $$ \\frac {\\partial L} {\\partial w} |_{w=w_0} $$\nNegative : Increase w\nPositive : Decrease w $$ \\eta\\frac {\\partial L} {\\partial w} |_{w=w_0} $$ η：learning rate (hyperparameters)\nUpdate w iteratively Local minima global minima 类似一个参数，推广到多个参数。\nLinear Models Linear models have severe limitation. Model Bias.\nWe need a more flexible model!\ncurve = constant + sum of a set of Hard Sigmoid Function $$ y=c\\frac {1} {1+exp(-(b+wx_1))} \\ =csigmoid(b+wx_1) $$\n$$ y=b+\\sum_{i}sigmoid(b_i+w_ix_i) $$\n$$ y=b+\\sum_{i}sigmoid(b_i+\\sum_{j}w_{ij}x_j) $$\n线性代数角度： $$ r=b+Wx $$\n$$ a=\\sigma(r) $$\n$$ y=b+c^Ta $$\nLoss\nLoss is a function of parameters L(θ) Loss means how good a set of values is. Optimization of New Model $$ \\theta= \\begin{bmatrix}\n\\theta_1 \\ \\theta_2 \\ \\theta_3 \\ \\dots \\end{bmatrix} $$\n$$ \\theta=arg \\min_\\theta L $$\n(Randomly) Pick initial values θ^0 1 epoch = see all the batched once\nupdate : update θ for each batch\nSigmoid -\u0026gt; ReLU (Rectified Linear Unit) 统称为 Activation function\nNeural Network\n","permalink":"https://showguan.github.io/en/posts/tech/1.%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B/","summary":"机器学习简介 Different types of Functions Regression : The function outputs a scalar(标量）. predict the PM2.5 Classification ： Given options (classes), the function outputs the correct one. Spam filtering Structured Learning ： create something with structure(image, document) Example : YouTube Channel 1.Function with Unknown Parameters. $$ y=b+wx_1 $$ 2.Define Loss from Training Data Loss is a","title":""},{"content":"PyTorch PyTorch Tutorial\nPython3中机器学习框架\ndataset = MyDataset(file) dataloader = DataLoader(dataset, batch_size = size , shuffle = True) Training : True Testing : False from torch.utils.data import Dataset, DateLoader class MyDataset(Dataset): def __init__(self, file): # read data \u0026amp; preprocess self.data = ... def __getitem__(self,index): #return one sample at a time return self.data[index] def __len__(self): #return the size of the dataset return len(self.data) dataset = MyDataset(file) dataloader = Dataloader(dataset, batch_size, shuffle = True) shuffle : Training -\u0026gt; true Testing -\u0026gt; false Tersors High-dimensional matrices(arrays)\n.shape() # show the dimension #Directly from data (list or numpy.ndarray) x = torch.tensor([1, -1], [-1, 1]) x = torch.from_numpy(np.array([[1, -1], [-1, 1]])) #Tensor of constant zeros \u0026amp; ones x = torch.zeros([2, 2]) x = torch.ones([1, 2, 5]) x+y x-y y=x.pow(2) y=x.sum() y=x.mean() #Transpose : transpose two specified dimensions x = x.transpose(dim0,dim1) # change the dimension dim0 and dim1 #Squeeze : remove the specified dimension with length 1 x = x.squeeze(1) #unsqueeze expand a new dimension x = x.unsqueeze(1) dim in PyTorch == axis in NumPy\ndimensional\nCheck with.shape()\tCreating Tensors Directly from data (list or numpy.ndarray)\nx = torch.tensor([1, -1], [-1, 1]) x = torch.from_numpy(np.array([[1, -1], [-1, 1]])) Tensor of constant zeros \u0026amp; ones\nx = torch.zeros([2,2]) x = torch.ones([1, 2, 5]) Common Operations addition subtraction power summation mean\ntranspose x.shape x.transpose(0,1) Unsqueeze : expand a new dimension\nx = x.unsqueeze(1) **Cat **: conncatenate multiple tensors 合并多个矩阵\ntorch.cat([x, y, z], dim = 1) Data Type: Using different data types for model and data will case errors.\n32-bit -torch.float\n64-bit -torch.long\nDevice\nTensors \u0026amp; modules will be computed with CPU by default Use .to() to move tensors to appropriate devices CPU x = x.to('cpu')\t- ```py x = x.to('cuda') GPU check if your computer has NVIDIA GPU torch.cuda.is_available() - Multiple GPUs : specify- ``` 'cuda:0', 'cuda:1', 'cuda:2',... Cradient Calculation import torch # 定义一个需要求导的张量 x，并将 requires_grad 参数设置为 True x = torch.tensor([[1., 0.], [-1., 1.]], requires_grad=True) # 计算 x 的平方并对其进行求和，得到张量 z z = x.pow(2).sum() # 对张量 z 进行反向传播，自动计算出 x 的梯度 z.backward() # 输出 x 的梯度 print(x.grad) torch.nn Network Layers Linear Layer (Fully-connected Layer) nn.linear(in_features, out_features) #### Non-linear Activation Functions```pynn.Sigmoid()nn.ReLU() Build your own neural network import torch.nn as nn class MyModel(nn.Module): #initialize your model \u0026amp; define layers def __init__(self): super(MyModel, self).__init__() self.net = nn.Sequential( nn.Linear(10, 32), nn.Sigmoid(), nn.Linear(32,1) ) #compute output of your nn def forward(self, x): return self.next() Loss Functions Mean squared Error (for regression tasks) criterion = nn.MSELoss() Cross Entropy (for classification tasks) 交叉熵 criterion = nn.CrossEntropyLoss() loss = criterion(model_output, expected_value) ### torch.optim- Stochastic Gradient Descent (SGD) - ```py torch.optim.SGD(model.parameters(), lr, momentum = 0) For every batch of data Call optimizer.zero_grad() to reset gradients of model parameters. Call loss.backward() to backpropagate gradients of prediction loss Call optimizer.step() to adjust model parameters Neural Network Training Setup dataset = MyDataSet(file) tr_set = DataLoader(dataset, 16, shuffle = True) model = MyModel().to(device) criterion = nn.MSELoss() optimizer = torch.optim.SGD(model.parameters(), 0.1) Training Loop for epoch in range(n_epochs): # Iterate over n_epochs model.train() # Set the model to training mode for x, y in tr_set: # Iterate over the training set optimizer.zero_grad() # Clear the gradients x, y = x.to(device), y.to(device) # Move data to the device (e.g., GPU) pred = model(x) # Forward pass, compute predictions loss = criterion(pred, y) # Compute the loss loss.backward() # Backward pass, compute gradients optimizer.step() # Update the model\u0026#39;s parameters using the gradients Validation Loop model.eval() # Set the model to evaluation mode total_loss = 0 for x, y in dv_set: # Iterate over the validation set x, y = x.to(device), y.to(device) # Move data to the device with torch.no_grad(): # Disable gradient computation pred = model(x) # Forward pass, compute predictions loss = criterion(pred, y) # Compute the loss total_loss += loss.cpu().item() * len(x) # Accumulate the loss avg_loss = total_loss / len(dv_set) # Calculate the average loss per sample Testing Loop model.eval() # Set the model to evaluation mode preds = [] for x in tt_set: # Iterate over the test set x = x.to(device) # Move data to the device with torch.no_grad(): # Disable gradient computation pred = model(x) # Forward pass, compute predictions preds.append(pred.cpu()) # Append the predictions to the list Data, demo1 Load data : use pandas to load a csv file\ntrain_data = pd.read_cav(\u0026#39;./name.csv\u0026#39;).drop(columns=[\u0026#39;date\u0026#39;]).values x_train, y_train = train_data[:,:-1], train_data[:,:-1] Dataset init : Read data and preproces\ngetitem : Return one sample at a time, In this case, one sample includes a 117 dimensional feature and a label\nlen : Return the size of the dataset. In this case, it is 2699\nclass COVID19Dataset(Dataset): \u0026#39;\u0026#39;\u0026#39; x: np.ndarray 特征矩阵. y: np.ndarray 目标标签, 如果为None,则是预测的数据集 \u0026#39;\u0026#39;\u0026#39; def __init__(self, x, y=None): if y is None: self.y = y else: self.y = torch.FloatTensor(y) self.x = torch.FloatTensor(x) def __getitem__(self, idx): if self.y is None: return self.x[idx] return self.x[idx], self.y[idx] def __len__(self): return len(self.x) Dataloader train_loader = DataLoader(train_dataset, batch_size = 32, shuffle = True, pin_memory = True) Model class My_Model(nn.Module): def __init__(self, input_dim): super(My_Model, self).__init__() # TODO: 修改模型结构, 注意矩阵的维度（dimensions） self.layers = nn.Sequential( nn.Linear(input_dim, 16), nn.ReLU(), nn.Linear(16, 8), nn.ReLU(), nn.Linear(8, 1) ) def forward(self, x): x = self.layers(x) x = x.squeeze(1) # (B, 1) -\u0026gt; (B) return x Criterion criterion = torch.nn.MSELoss(reduction = \u0026#39;mean\u0026#39;) Optimizer optimizer = torch.optim.SGD(model.parameters(), lr = 1e-5, momentum = 0.9) Training Loop Documentation and Common Errors read pytorch tutorial\nColab（highly recommended） ","permalink":"https://showguan.github.io/en/posts/tech/2.pytorch/","summary":"PyTorch PyTorch Tutorial Python3中机器学习框架 dataset = MyDataset(file) dataloader = DataLoader(dataset, batch_size = size , shuffle = True) Training : True Testing : False from torch.utils.data import Dataset, DateLoader class MyDataset(Dataset): def __init__(self, file): # read data \u0026amp; preprocess self.data = ... def __getitem__(self,index): #return one sample at a time return self.data[index] def __len__(self): #return the size of","title":""},{"content":"Officially begin Deep = Many hidden layers\nNeurall Network Find a function in function set.\nGoodness of function Pick the best function\nBackpropagation - Backward Pass(反向传播) 反向的neural network\nRegression Stock Market Forecast Self-driving Car Recommendation Step 1 : Model A set of function\nStep 2 : Goodness of Function $$ \\hat{y}^1代表x^1对应的确切值 $$\nLoss function L： $$ L(f)=L(w,b) ~ Estimated ~ y ~ basedoninputfunction $$\n$$ L(w,b)=\\sum_{n=1}^{10}(\\hat{y}^n-(b+w\\cdot x_{cp}^n))^2 $$\nStep 3 ：Best Function In linear regression, the loss function L is convex.\nOverfitting\nRegularization $$ L(w,b)=\\sum_{n=1}^{10}(\\hat{y}^n-(b+w\\cdot x_{cp}^n))^2+\\lambda\\cdot \\sum(w_i)^2 $$\n不需要考虑bias，调整平滑程度，smooth\nGradient descent Overfitting and Regularization Classification independently and identically distributed(i.i.d) $$ L(h^{train},D_{all})-L(h^{all}, d_{all}) \\leq \\delta\\ we\\ need \\ \\forall h \\in \\H, |L(h,D_{train}) -L(h,D_{all}) | \\leq \\delta/2\\ L(h^{train},D_{all})\\leq L(h^{train},D_{all}) + \\delta/2 $$ 重温数码宝贝：\n模型出现bad的概率： $$ P(D_{train}\\ is\\ bad)\\leq |H| \\cdot 2exp(-2N\\epsilon^2 ) \\ N \\ge \\frac{log(2|H|/\\delta)}{2\\epsilon^2} $$ Tradeoff of Model Complexity\nTraining data for Classification pair\nIdeal Alternatives Function(Model): $$ f(x)\\ x -\u0026gt; g(x)\u0026gt;0~Output=class1\\ else\\ Output=class2 $$\nlossfunction: The number of times of get incotrrect results on training data. $$ L(f) = \\sum_{n}\\delta(f(x^n)\\neq\\hat{y}^n) $$\nFind the best function; Example : Perceptron, SVM Prior $$ P(C_1|x)=\\frac{P(x|C_1)P(C_1)}{P(x|C_1)P(C_1)+P(x|C_2)P(C_2)} $$\nGaussian Maximum Likelihood\n2D array or 3D array mean the array with 2 or 3 axes respectively, but the n-dimensional vector mean the vector of length n.\nLearn something that can really differ you from others.\nLogistics Regression Function Set $$ f_{w,b}=\\sigma(\\sum_{i}w_ix_i)+b $$\nOutput : Between 0 and 1 $$ f_{w,b}(x)=P_{w,b}(C_1|x) $$\n$$ w^,b^=arg\\ \\underset{w,b}{max}L(w,b)\\ 等同于 w^,b^ = arg\\ \\underset{w,b}{min}-lnL(w,b) $$\nCross Entropy: $$ Distribution \\ p: p(x=1)=\\hat{y}^n\\ p(x=0)=1-\\hat{y}^n\\ Distribution \\ q: q(x=1)=f(x^n)\\ q(x=0)=1-f(x^n)\\ H(p,q)=-\\sum_xp(x)ln(q(x)) $$\nLoss Function $$ L(f)=\\sum_nC(f(x^n),\\hat{y}^n)\\ C(f(x^n),\\hat{y}^n)=-[\\hat{y}^nlnf(x^n)+(1-\\hat{y}^n)ln(1-f(x^n))] $$\nUpdate logistic regression 和 linear regression 形式完全相同 $$ w_i\\gets w_i-\\eta \\sum_{n}-(\\hat{y}^n-f_{w,b}(x^n))x_i^n $$\nDiscriminative (logistic) \u0026amp; Generative (Gaussian描述) Generative做了某些假设。\nBenefit of generative model With the assumption of probability distribution, less training data is needed With the assumption of probability distribution, more robust to the noise Priors and class-dependent probabilities can be estimated from different sources. Multi-class Classification SoftMax $$ Softmax(z_i)=\\frac{e^{z_i}}{\\sum_{c=1}^{C} e^{z_c}}\\ 1 \u0026gt; y_i\u0026rsquo; \u0026gt; 0\\ \\sum_iy_i\u0026rsquo;=1 $$\nLimitation of Logistic Regression 只能画一条直线\nFeature Transformation Cascading logistic regression models Optimization Issue 层数较多表现的反而没有层数较少的好\nOver fitting 增加训练资料\nData augmentation\nconstrained model\nLess parameters, sharing parameters Less features Early stopping CNN-\u0026gt;比较没有弹性的model\n分Training Set\nN-fold Cross Validation Optimization Fail H : Hessian\nTayler Series Approximation $$ L(\\theta) \\approx L(\\theta^\\prime)+\\frac{1}{2}(\\theta-\\theta^\\prime)^TH(\\theta-\\theta^\\prime) $$\nH is positive definte = All eigen values are positive -\u0026gt; local minima H is negative definte = All eigen values are negative -\u0026gt; **local ** Some eigen values are positive , and some are negative -\u0026gt; Saddle point 在高维下local minima可能会变成saddle poing\nTips for training : Batch and Momentum Batch 1 epoch = see all the batches once -\u0026gt; shuffle after each epoch\nMomentum Movement not just based on gradient, but previous movement.\nDifferent parameters needs different learning rate $$ \\theta_i^{t+1} \\gets \\theta_i^t-\\frac{\\eta}{\\sigma_i^t}g_i^t\\ \\sigma_i^t=\\sqrt{\\frac{1}{t+1}\\sum_{i=0}^t(g_i^t)^2} $$\nAdagred\nRMSProp $$ \\theta_i^{t+1} \\gets \\theta_i^t-\\frac{\\eta}{\\sigma_i^t}g_i^t\\ \\sigma_i^t = \\sqrt{\\alpha(\\sigma_i^{t-1})^2+(1-\\alpha)(g_i^t)^2} $$\nAdam : RMSProp + Momentum\nLearning Rate Sceduling $$ \\theta_i^{t+1} \\gets \\theta_i^t-\\frac{\\eta^t}{\\sigma_i^t}g_i^t\\ $$\nWarm Up New Optimization ","permalink":"https://showguan.github.io/en/posts/tech/3.regression-and-classification/","summary":"Officially begin Deep = Many hidden layers Neurall Network Find a function in function set. Goodness of function Pick the best function Backpropagation - Backward Pass(反向传播) 反向的neural network Regression Stock Market Forecast Self-driving Car Recommendation Step 1 : Model A set of function Step 2 : Goodness of Function $$ \\ha","title":""},{"content":"Convolutional network (CNN) Network的架构调整\n1、All the images to be classified have the same size.\nReceptive filed\nSimplification 1 - Typical Setting all channels : 会看所有的channels\nkernel size : 长和宽 （e.g., 3*3)\nStride : 移动的步长,希望有高度的重叠\npadding : 补值，补充超出范围的值\nEach receptive field has a set of neurons.\nEach receptive field has the neurons with the same set of parameters, which called filter.\nPooling Flatten ","permalink":"https://showguan.github.io/en/posts/tech/4.cnn/","summary":"Convolutional network (CNN) Network的架构调整 1、All the images to be classified have the same size. Receptive filed Simplification 1 - Typical Setting all channels : 会看所有的channels kernel size : 长和宽 （e.g., 3*3) Stride : 移动的","title":""},{"content":"Spatial Transformer（STN） 处理旋转和放大图形的CNN分类\ninterpolation 插值法 Self-attention Sequence Labeling consider the context -\u0026gt; 参数很大并且容易Over fitting\nSelf-attention会持有整个sequence的信息\ninput : vector\noutput : vector $$ q_i=W^qa^i\\ k_i=W^ka^i\\ v^i=W^va^i $$ Multi-head Self-attention 其中 $$ q_i, k_i, v_i均可以有多个 $$\nSelf-attention for Speech Truncated(截短的) Self-attention\nSelf-attention is the complex version of CNN\nCNN is simplified self-attention\nRecurrent Neural Network(RNN) RNN所做的事情都可以用Self-attention来替代\nSelf-attention更有效率\nRNN\nTransformer Sequence to sequence (Seq2seq) Encoder -\u0026gt; Decoder\nEncoder input some vectors and output some vectors\nDecoder Autoregressive Non-autoregressive Decoder 同时输出BEGIN并且同时输出结果和END\nAdvantage ： parallel, controllable output length\nNAT is usually worse than AT\nEncoder-Decoder Cross Attention\nTeacher Forcing : using the ground truth as input\nCopy Mechanism\nPointer Network Copying Mechanism Guided Attention Beam Search Scheduled Sampling\n","permalink":"https://showguan.github.io/en/posts/tech/5.transformer/","summary":"Spatial Transformer（STN） 处理旋转和放大图形的CNN分类 interpolation 插值法 Self-attention Sequence Labeling consider the context -\u0026gt; 参数很大并且容易Over fitting Self-attention","title":""},{"content":"acwing算法学习 [TOC]\n第一章 课上：学思想\n课下：背代码\n题目，一道题写好几遍\n理解没有任何意义，体力活+脑力活\n记忆力 毅力/自制力\n沉下心背东西\n快速排序算法模板 —— 模板题 AcWing 785. 快速排序 分治\n1、确定分界点，l、r、（l+r)/2 随机\n2、调整区间，分为两边，左边小于等于x,右边大于等于x\n3、递归处理左右两段\nvoid quick_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r \u0026gt;\u0026gt; 1]; while (i \u0026lt; j) { do i ++ ; while (q[i] \u0026lt; x); do j -- ; while (q[j] \u0026gt; x); if (i \u0026lt; j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1, r); } -std=c++11 归并排序算法模板 —— 模板题 AcWing 787. 归并排序 排序稳定：序列中相同的值排序后的相对位置是否发生改变\n时间复杂度有 （nlogn)\n1）确定分界点mid\n2）递归排序两边\n2）归并，合并为一个有序数组\nvoid merge_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int mid = l + r \u0026gt;\u0026gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) if (q[i] \u0026lt; q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; while (i \u0026lt;= mid) tmp[k ++ ] = q[i ++ ]; while (j \u0026lt;= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0; i \u0026lt;= r; i ++, j ++ ) q[i] = tmp[j]; } 整数二分算法模板 —— 模板题 AcWing 789. 数的范围 边界问题\n本质：区间内一半满足一半不满足\nl=mid时加一\nbool check(int x) {/* ... */} // 检查x是否满足某种性质 // 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用： int bsearch_1(int l, int r) { while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) r = mid; // check()判断mid是否满足性质 else l = mid + 1; } return l; } // 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用： int bsearch_2(int l, int r) { while (l \u0026lt; r) { int mid = l + r + 1 \u0026gt;\u0026gt; 1; if (check(mid)) l = mid; else r = mid - 1; } return l; } 浮点数二分算法模板 —— 模板题 AcWing 790. 数的三次方根 浮点数二分，比较对应整数二分\nbool check(double x) {/* ... */} // 检查x是否满足某种性质 double bsearch_3(double l, double r) { const double eps = 1e-6; // eps 表示精度，取决于题目对精度的要求 while (r - l \u0026gt; eps) { double mid = (l + r) / 2; if (check(mid)) r = mid; else l = mid; } return l; } 高精度加法 —— 模板题 AcWing 791. 高精度加法 // C = A + B, A \u0026gt;= 0, B \u0026gt;= 0 vector\u0026lt;int\u0026gt; add(vector\u0026lt;int\u0026gt; \u0026amp;A, vector\u0026lt;int\u0026gt; \u0026amp;B) { if (A.size() \u0026lt; B.size()) return add(B, A); vector\u0026lt;int\u0026gt; C; int t = 0; for (int i = 0; i \u0026lt; A.size(); i ++ ) { t += A[i]; if (i \u0026lt; B.size()) t += B[i]; C.push_back(t % 10); t /= 10; } if (t) C.push_back(t); return C; } 高精度减法 —— 模板题 AcWing 792. 高精度减法 // C = A - B, 满足A \u0026gt;= B, A \u0026gt;= 0, B \u0026gt;= 0 vector\u0026lt;int\u0026gt; sub(vector\u0026lt;int\u0026gt; \u0026amp;A, vector\u0026lt;int\u0026gt; \u0026amp;B) { vector\u0026lt;int\u0026gt; C; for (int i = 0, t = 0; i \u0026lt; A.size(); i ++ ) { t = A[i] - t; if (i \u0026lt; B.size()) t -= B[i]; C.push_back((t + 10) % 10); if (t \u0026lt; 0) t = 1; else t = 0; } while (C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) C.pop_back(); return C; } 高精度乘低精度 —— 模板题 AcWing 793. 高精度乘法 // C = A * b, A \u0026gt;= 0, b \u0026gt; 0 vector\u0026lt;int\u0026gt; mul(vector\u0026lt;int\u0026gt; \u0026amp;A, int b) { vector\u0026lt;int\u0026gt; C; int t = 0; for (int i = 0; i \u0026lt; A.size() || t; i ++ ) { if (i \u0026lt; A.size()) t += A[i] * b; C.push_back(t % 10); t /= 10; } return C; } 高精度除以低精度 —— 模板题 AcWing 794. 高精度除法 // A / b = C ... r, A \u0026gt;= 0, b \u0026gt; 0 vector\u0026lt;int\u0026gt; div(vector\u0026lt;int\u0026gt; \u0026amp;A, int b, int \u0026amp;r) { vector\u0026lt;int\u0026gt; C; r = 0; for (int i = A.size() - 1; i \u0026gt;= 0; i -- ) { r = r * 10 + A[i]; C.push_back(r / b); r %= b; } reverse(C.begin(), C.end()); while (C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) C.pop_back(); return C; } 一维前缀和 —— 模板题 AcWing 795. 前缀和 快速求区间和\nS[i] = a[1] + a[2] + ... a[i] a[l] + ... + a[r] = S[r] - S[l - 1] 从1开始，便于处理边界 二维前缀和 —— 模板题 AcWing 796. 子矩阵的和 S[i, j] = 第i行j列格子左上部分所有元素的和 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为： S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1] 一维差分 —— 模板题 AcWing 797. 差分 给区间[l, r]中的每个数加上c： B[l] += c, B[r + 1] -= c 二维差分 —— 模板题 AcWing 798. 差分矩阵/二维差分 给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c： S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c 双指针算法 —— 模板题 AcWIng 799. 最长连续不重复子序列, AcWing 800. 数组元素的目标和 __滑动窗口？ 核心：把O(n^2)算法优化为O(n)\nfor (int i = 0, j = 0; i \u0026lt; n; i ++ ) { while (j \u0026lt; i \u0026amp;\u0026amp; check(j, i)) j ++ ; // 具体问题的逻辑 } 常见问题分类： (1) 对于一个序列，用两个指针维护一段区间 (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作 位运算 —— 模板题 AcWing 801. 二进制中1的个数 原码，反码，补码 求n二进制表示中第k位数字: n \u0026gt;\u0026gt; k \u0026amp; 1 返回n的最后一位1：lowbit(n) = n \u0026amp; -n 树状数组基本操作 整数离散化 —— 模板题 AcWing 802. 区间和 vector\u0026lt;int\u0026gt; alls; // 存储所有待离散化的值 sort(alls.begin(), alls.end()); // 将所有值排序 alls.erase(unique(alls.begin(), alls.end())返回去重后数组末尾端点, alls.end()); // 去掉重复元素 // 二分求出x对应的离散化的值 int find(int x) // 找到第一个大于等于x的位置 { int l = 0, r = alls.size() - 1; while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (alls[mid] \u0026gt;= x) r = mid; else l = mid + 1; } return r + 1; // 映射到1, 2, ...n } 区间合并 —— 模板题 AcWing 803. 区间合并 // 将所有存在交集的区间合并 贪心 void merge(vector\u0026lt;PII\u0026gt; \u0026amp;segs) { vector\u0026lt;PII\u0026gt; res; sort(segs.begin(), segs.end()); //区间左端点排序 int st = -2e9, ed = -2e9; for (auto seg : segs) if (ed \u0026lt; seg.first) { if (st != -2e9) res.push_back({st, ed}); st = seg.first, ed = seg.second; } else ed = max(ed, seg.second); if (st != -2e9) res.push_back({st, ed}); segs = res; } 作者：yxc 链接：https://www.acwing.com/blog/content/277/ 来源：AcWing 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n第二章 数据结构，以数组模拟的形式\n指针+结构体 ： 面试题\n单链表 —— 模板题 AcWing 826. 单链表 邻接表-存储树和图 静态链表\n下标从0开始\n// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点 int head, e[N], ne[N], idx; // 初始化 void init() { head = -1; idx = 0; } // 在链表头插入一个数a void insert(int a) { e[idx] = a, ne[idx] = head, head = idx ++ ; } // 插入下标k后面 void add(int k,int x) { e[idx]= x, ne[idx] = ne[k], ne[k] = idx++ ; } // 将头结点删除，需要保证头结点存在 void remove() { head = ne[head]; } // 将k后面的点删掉 void remove(int k) { ne[k] = ne[ne[k]]; } 双链表 —— 模板题 AcWing 827. 双链表 优化某些问题\n// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点 int e[N], l[N], r[N], idx; // 初始化 void init() { //0是左端点，1是右端点 r[0] = 1, l[1] = 0; idx = 2; } // 在节点a的右边插入一个数x void insert(int a, int x) { e[idx] = x; l[idx] = a, r[idx] = r[a]; l[r[a]] = idx, r[a] = idx ++ ; } // 删除节点a void remove(int a) { l[r[a]] = l[a]; r[l[a]] = r[a]; } 栈 —— 模板题 AcWing 828. 模拟栈 // tt表示栈顶 int stk[N], tt = 0; // 向栈顶插入一个数 stk[ ++ tt] = x; // 从栈顶弹出一个数 tt -- ; // 栈顶的值 stk[tt]; // 判断栈是否为空 if (tt \u0026gt; 0) { } 队列 —— 模板题 AcWing 829. 模拟队列 普通队列\n// hh 表示队头，tt表示队尾 int q[N], hh = 0, tt = -1; // 向队尾插入一个数 q[ ++ tt] = x; // 从队头弹出一个数 hh ++ ; // 队头的值 q[hh]; // 判断队列是否为空 if (hh \u0026lt;= tt) { //不空 } 循环队列\n// hh 表示队头，tt表示队尾的后一个位置 int q[N], hh = 0, tt = 0; // 向队尾插入一个数 q[tt ++ ] = x; if (tt == N) tt = 0; // 从队头弹出一个数 hh ++ ; if (hh == N) hh = 0; // 队头的值 q[hh]; // 判断队列是否为空 if (hh != tt) { } 单调栈 —— 模板题 AcWing 830. 单调栈 常见模型：找出每个数左边离它最近的比它大/小的数 int tt = 0; for (int i = 1; i \u0026lt;= n; i ++ ) { while (tt \u0026amp;\u0026amp; check(stk[tt], i)) tt -- ; stk[ ++ tt] = i; } 单调队列 —— 模板题 AcWing 154. 滑动窗口 常见模型：找出滑动窗口中的最大值/最小值 int hh = 0, tt = -1; for (int i = 0; i \u0026lt; n; i ++ ) { while (hh \u0026lt;= tt \u0026amp;\u0026amp; check_out(q[hh])) hh ++ ; // 判断队头是否滑出窗口 while (hh \u0026lt;= tt \u0026amp;\u0026amp; check(q[tt], i)) tt -- ; q[ ++ tt] = i; } KMP —— 模板题 AcWing 831. KMP字符串 用模板串来匹配模式串，找到模式串\ns的真前缀以及真后缀是指不等于s的前缀以及后缀，即至少是s[1~n-2]或s[0~n-1]\nne[i] : 以i结尾的串中 最长真前缀与真后缀相等的串 的长度，如果没有则为0。\n//前缀h vector\u0026lt;int\u0026gt; prefix_function(string s) { int n = (int)s.length(); vector\u0026lt;int\u0026gt; pi(n); for (int i = 1; i \u0026lt; n; i++) { int j = pi[i - 1]; while (j \u0026gt; 0 \u0026amp;\u0026amp; s[i] != s[j]) j = pi[j - 1]; if (s[i] == s[j]) j++; pi[i] = j; } return pi; } 实际使用范例（下面这个例子字符串从1开始）\n// 求Next数组： // ne[i] 存储真前缀和真后缀相等的长度，所以至少从2开始： //abcab,从b开始才有真前缀 // s[]是模式串，p[]是模板串, n是s的长度，m是p的长度 for (int i = 2, j = 0; i \u0026lt;= m; i ++ ) { while (j \u0026amp;\u0026amp; p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j ++ ; ne[i] = j; } // 匹配 for (int i = 1, j = 0; i \u0026lt;= n; i ++ ) { while (j \u0026amp;\u0026amp; s[i] != p[j + 1]) j = ne[j]; if (s[i] == p[j + 1]) j ++ ; if (j == m) { j = ne[j]; // 匹配成功后的逻辑 } } Trie树 —— 模板题 AcWing 835. Trie字符串统计 int son[N][26], cnt[N], idx; // 0号点既是根节点，又是空节点 // son[][]存储树中每个节点的子节点 // cnt[]存储以每个节点结尾的单词数量 // 插入一个字符串 void insert(char *str) { int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - \u0026#39;a\u0026#39;; if (!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; } cnt[p] ++ ; } // 查询字符串出现的次数 int query(char *str) { int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - \u0026#39;a\u0026#39;; if (!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; } 并查集 —— 模板题 AcWing 836. 合并集合, AcWing 837. 连通块中点的数量 按秩合并\n字符按字符串读入\n(1)朴素并查集：\nint p[N]; //存储每个点的祖宗节点 // 返回x的祖宗节点 int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } // 初始化，假定节点编号是1~n for (int i = 1; i \u0026lt;= n; i ++ ) p[i] = i; // 合并a和b所在的两个集合： p[find(a)] = find(b); (2)维护size的并查集：\nint p[N], size[N]; //p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量 // 返回x的祖宗节点 int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } // 初始化，假定节点编号是1~n for (int i = 1; i \u0026lt;= n; i ++ ) { p[i] = i; size[i] = 1; } // 合并a和b所在的两个集合： p[find(a)] = find(b); size[b] += size[a]; (3)维护到祖宗节点距离的并查集：\nint p[N], d[N]; //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离 // 返回x的祖宗节点 int find(int x) { if (p[x] != x) { int u = find(p[x]); d[x] += d[p[x]]; p[x] = u; } return p[x]; } // 初始化，假定节点编号是1~n for (int i = 1; i \u0026lt;= n; i ++ ) { p[i] = i; d[i] = 0; } // 合并a和b所在的两个集合： p[find(a)] = find(b); d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量 堆 —— 模板题 AcWing 838. 堆排序, AcWing 839. 模拟堆 维护集合的数据结构 （大根堆，父节点值不小于子节点值）\n// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1 // pos[k]存储第k个插入的点在堆中的位置 // ord[k]存储堆中下标是k的点是第几个插入的 int h[N], ph[N], hp[N], size; // 交换两个点，及其映射关系 void heap_swap(int a, int b) { //swap(ph[hp[a]],ph[hp[b]]); 根据题意 //swap(hp[a], hp[b]); swap(h[a], h[b]); } void down(int u) { int t = u; if (u * 2 \u0026lt;= size \u0026amp;\u0026amp; h[u * 2] \u0026lt; h[t]) t = u * 2; if (u * 2 + 1 \u0026lt;= size \u0026amp;\u0026amp; h[u * 2 + 1] \u0026lt; h[t]) t = u * 2 + 1; if (u != t) { heap_swap(u, t); down(t); } } void up(int u) { while (u / 2 \u0026amp;\u0026amp; h[u] \u0026lt; h[u / 2]) { heap_swap(u, u / 2); u \u0026gt;\u0026gt;= 1; } } // O(n)建堆 for (int i = n / 2; i; i -- ) down(i); heap[++size] = x; up(size); //添加元素 heap[1]; //堆顶元素 heap[1]=heap[size]; size--; down(1);//删除第size个结点 heap[k]=heap[size]; size---; down(k);up(k);//删除第k个结点 heap[k]=x; down(k); up(k); //将第k个元素赋值为x 一般哈希 —— 模板题 AcWing 840. 模拟散列表 (1) 拉链法 int h[N], e[N], ne[N], idx; // 向哈希表中插入一个数 void insert(int x) { int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx ++ ; } // 在哈希表中查询某个数是否存在 bool find(int x) { int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) if (e[i] == x) return true; return false; } (2) 开放寻址法 int h[N]; // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置 int find(int x) { int t = (x % N + N) % N; while (h[t] != null \u0026amp;\u0026amp; h[t] != x) { t ++ ; if (t == N) t = 0; } return t; } 字符串哈希 —— 模板题 AcWing 841. 字符串哈希 核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低 小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果。\ntypedef unsigned long long ULL; const int P = 131 or 13331 ; ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64 // 初始化 p[0] = 1; for (int i = 1; i \u0026lt;= n; i ++ ) { h[i] = h[i - 1] * P + str[i]; p[i] = p[i - 1] * P; } // 计算子串 str[l ~ r] 的哈希值 ULL get(int l, int r) { return h[r] - h[l - 1] * p[r - l + 1]; } C++ STL简介 所有容器都有size() empty() vector, 变长数组，倍增的思想 size() 返回元素个数 empty() 返回是否为空 clear() 清空 front()/back() push_back()/pop_back() begin()/end() [] 支持比较运算，按字典序 vector\u0026lt;int\u0026gt; a(10,2); a.empty(); pair\u0026lt;int, int\u0026gt; first, 第一个元素 second, 第二个元素 支持比较运算，以first为第一关键字，以second为第二关键字（字典序） pair\u0026lt;int,int\u0026gt; p; p=make_pair(1,1); p={1,1}; string，字符串 size()/length() 返回字符串长度 empty() clear() substr(起始下标，(子串长度)) 返回子串 c_str() 返回字符串所在字符数组的起始地址 strcpy(c,s.c_str());//c_str()的使用方法 queue, 队列 没有clear函数 清空用新建queue size() empty() push() 向队尾插入一个元素 front() 返回队头元素 back() 返回队尾元素 pop() 弹出队头元素 priority_queue, 优先队列，默认是大根堆 push() 插入一个元素 top() 返回堆顶元素 pop() 弹出堆顶元素 定义成小根堆的方式：priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; q; stack, 栈 size() empty() push() 向栈顶插入一个元素 top() 返回栈顶元素 pop() 弹出栈顶元素 deque, 双端队列 size() empty() clear() front()/back() push_back()/pop_back() push_front()/pop_front() begin()/end() [] set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列 size() empty() clear() begin()/end() ++, -- 返回前驱和后继，时间复杂度 O(logn) set/multiset insert() 插入一个数 find() 查找一个数 count() 返回某一个数的个数 erase() (1) 输入是一个数x，删除所有x O(k + logn) (2) 输入一个迭代器，删除这个迭代器 lower_bound()/upper_bound() lower_bound(x) 返回大于等于x的最小的数的迭代器 upper_bound(x) 返回大于x的最小的数的迭代器 map/multimap insert() 插入的数是一个pair erase() 输入的参数是pair或者迭代器 find() [] 注意multimap不支持此操作。 时间复杂度是 O(logn) lower_bound()/upper_bound() unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表 和上面类似，增删改查的时间复杂度是 O(1) 不支持 lower_bound()/upper_bound()， 迭代器的++，-- bitset, 圧位 bitset\u0026lt;10000\u0026gt; s; ~, \u0026amp;, |, ^ \u0026gt;\u0026gt;, \u0026lt;\u0026lt; ==, != [] count() 返回有多少个1 none() 判断是否全为0 any() 判断是否至少有一个1 set() 把所有位置成1 set(k, v) 将第k位变成v reset() 把所有位变成0 flip() 等价于~ flip(k) 把第k位取反 作者：yxc 链接：https://www.acwing.com/blog/content/404/ 来源：AcWing 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n第三章 树与图的存储 树是一种特殊的图: 无环连通图，与图的存储方式相同。 对于无向图中的边ab，存储两条有向边a-\u0026gt;b, b-\u0026gt;a。 因此我们可以只考虑有向图的存储。\n(1) 邻接矩阵：g[a][b] 存储边a-\u0026gt;b (2) 邻接表： // 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点 int h[N], e[N], ne[N], idx; // 添加一条边a-\u0026gt;b void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } // 初始化 idx = 0; memset(h, -1, sizeof h); 树与图的遍历 时间复杂度 O(n+m)O(n+m), nn 表示点数，mm 表示边数\n(1) 深度优先遍历 —— 模板题 AcWing 846. 树的重心 int dfs(int u) { st[u] = true; // st[u] 表示点u已经被遍历过 for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) dfs(j); } } (2) 宽度优先遍历 —— 模板题 AcWing 847. 图中点的层次 queue\u0026lt;int\u0026gt; q; st[1] = true; // 表示1号点已经被遍历过 q.push(1); while (q.size()) { int t = q.front(); q.pop(); for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) { st[j] = true; // 表示点j已经被遍历过 q.push(j); } } } 拓扑排序 —— 模板题 AcWing 848. 有向图的拓扑序列 时间复杂度 O(n+m)O(n+m), nn 表示点数，mm 表示边数\nbool topsort() { int hh = 0, tt = -1; // d[i] 存储点i的入度 for (int i = 1; i \u0026lt;= n; i ++ ) if (!d[i]) q[ ++ tt] = i; while (hh \u0026lt;= tt) { int t = q[hh ++ ]; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (-- d[j] == 0) q[ ++ tt] = j; } } // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。 return tt == n - 1; } 最短路 单源最短路\n所有边权均为正：朴素Dijkstra O(n^2)；堆优化版的Dijkstra(mlogn)\n存在负权变：Bellman-Ford O(nm) ； SPFA（队列优化Bellman-Ford) 一般：O(m) 最坏 O(nm)\n多元汇最短路：Floyed算法 O(n^3)\n朴素dijkstra算法 —— 模板题 AcWing 849. Dijkstra求最短路 I 基于贪心 时间复杂是 O(n^2+m), n 表示点数，m 表示边数\nint g[N][N]; // 存储每条边， int dist[N]; // 存储1号点到每个点的最短距离 bool st[N]; // 存储每个点的最短路是否已经确定 // 求1号点到n号点的最短路，如果不存在则返回-1 int dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i \u0026lt; n - 1; i ++ ) { int t = -1; // 在还未确定最短路的点中，寻找距离最小的点 for (int j = 1; j \u0026lt;= n; j ++ ) if (!st[j] \u0026amp;\u0026amp; (t == -1 || dist[t] \u0026gt; dist[j])) t = j; // 用t更新其他点的距离 for (int j = 1; j \u0026lt;= n; j ++ ) dist[j] = min(dist[j], dist[t] + g[t][j]); st[t] = true; } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } 堆优化版dijkstra —— 模板题 AcWing 850. Dijkstra求最短路 II 时间复杂度 O(mlogn), n 表示点数，m 表示边数\ntypedef pair\u0026lt;int, int\u0026gt; PII; int n; // 点的数量 int h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边 int dist[N]; // 存储所有点到1号点的距离 bool st[N]; // 存储每个点的最短距离是否已确定 // 求1号点到n号点的最短距离，如果不存在，则返回-1 int dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; priority_queue\u0026lt;PII, vector\u0026lt;PII\u0026gt;, greater\u0026lt;PII\u0026gt;\u0026gt; heap; heap.push({0, 1}); // first存储距离，second存储节点编号 while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] \u0026gt; distance + w[i]) { dist[j] = distance + w[i]; heap.push({dist[j], j}); } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } Bellman-Ford算法 —— 模板题 AcWing 853. 有边数限制的最短路 时间复杂度 O(nm), n 表示点数，m表示边数 注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题。\nint n, m; // n表示点数，m表示边数 int dist[N]; // dist[x]存储1到x的最短路距离 struct Edge // 边，a表示出点，b表示入点，w表示边的权重 { int a, b, w; }edges[M]; // 求1到n的最短路距离，如果无法从1走到n，则返回-1。 int bellman_ford() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。 for (int i = 0; i \u0026lt; n; i ++ ) { for (int j = 0; j \u0026lt; m; j ++ ) { int a = edges[j].a, b = edges[j].b, w = edges[j].w; if (dist[b] \u0026gt; dist[a] + w) dist[b] = dist[a] + w; } } if (dist[n] \u0026gt; 0x3f3f3f3f / 2) return -1; return dist[n]; } spfa 算法（队列优化的Bellman-Ford算法） —— 模板题 AcWing 851. spfa求最短路 时间复杂度 平均情况下 O(m)，最坏情况下 O(nm), n 表示点数，m 表示边数\nint n; // 总点数 int h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边 int dist[N]; // 存储每个点到1号点的最短距离 bool st[N]; // 存储每个点是否在队列中 // 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1 int spfa() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; queue\u0026lt;int\u0026gt; q; q.push(1); st[1] = true; while (q.size()) { auto t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] \u0026gt; dist[t] + w[i]) { dist[j] = dist[t] + w[i]; if (!st[j]) // 如果队列中已存在j，则不需要将j重复插入 { q.push(j); st[j] = true; } } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } spfa判断图中是否存在负环 —— 模板题 AcWing 852. spfa判断负环 时间复杂度是 O(nm), n 表示点数，m 表示边数\nint n; // 总点数 int h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边 int dist[N], cnt[N]; // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数 bool st[N]; // 存储每个点是否在队列中 // 如果存在负环，则返回true，否则返回false。 bool spfa() { // 不需要初始化dist数组 // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。 queue\u0026lt;int\u0026gt; q; for (int i = 1; i \u0026lt;= n; i ++ ) { q.push(i); st[i] = true; } while (q.size()) { auto t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] \u0026gt; dist[t] + w[i]) { dist[j] = dist[t] + w[i]; cnt[j] = cnt[t] + 1; if (cnt[j] \u0026gt;= n) return true; // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环 if (!st[j]) { q.push(j); st[j] = true; } } } } return false; } floyd算法 —— 模板题 AcWing 854. Floyd求最短路 时间复杂度是 O(n3)O(n3), nn 表示点数 初始化： for (int i = 1; i \u0026lt;= n; i ++ ) for (int j = 1; j \u0026lt;= n; j ++ ) if (i == j) d[i][j] = 0; else d[i][j] = INF; // 算法结束后，d[a][b]表示a到b的最短距离 void floyd() { for (int k = 1; k \u0026lt;= n; k ++ ) for (int i = 1; i \u0026lt;= n; i ++ ) for (int j = 1; j \u0026lt;= n; j ++ ) d[i][j] = min(d[i][j], d[i][k] + d[k][j]); } 最小生成树（无向图） Prim : 朴素版Prim O(n^2)(稠密图) ; 堆优化版Prim O(mlogn)(一般不会用)\nKruskal : O(mlogm)(稀疏图)\n朴素版prim算法 —— 模板题 AcWing 858. Prim算法求最小生成树 时间复杂度是 O(n^2+m), n 表示点数，m 表示边数\n初始化距离为正无穷，迭代所有点，找到集合中最近的点，更新它到集合的距离，把t加到集合中。\nint n; // n表示点数 int g[N][N]; // 邻接矩阵，存储所有边 int dist[N]; // 存储其他点到当前最小生成树的距离 bool st[N]; // 存储每个点是否已经在生成树中 // 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和 int prim() { memset(dist, 0x3f, sizeof dist); int res = 0; for (int i = 0; i \u0026lt; n; i ++ ) { int t = -1; for (int j = 1; j \u0026lt;= n; j ++ ) if (!st[j] \u0026amp;\u0026amp; (t == -1 || dist[t] \u0026gt; dist[j])) t = j; if (i \u0026amp;\u0026amp; dist[t] == INF) return INF; if (i) res += dist[t]; st[t] = true; for (int j = 1; j \u0026lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]); } return res; } Kruskal算法 —— 模板题 AcWing 859. Kruskal算法求最小生成树 时间复杂度是 O(mlogm), n 表示点数，m 表示边数\nint n, m; // n是点数，m是边数 int p[N]; // 并查集的父节点数组 struct Edge // 存储边 { int a, b, w; // 重载小于号运算符 // 用于比较两个Edge对象的大小关系 bool operator \u0026lt; (const Edge \u0026amp;W) const { return w \u0026lt; W.w; // 如果当前对象的边权小于W对象的边权，返回true，否则返回false } }edges[M]; int find(int x) // 并查集核心操作 { if (p[x] != x) p[x] = find(p[x]); return p[x]; } int kruskal() { sort(edges, edges + m); for (int i = 1; i \u0026lt;= n; i ++ ) p[i] = i; // 初始化并查集 int res = 0, cnt = 0; for (int i = 0; i \u0026lt; m; i ++ ) { int a = edges[i].a, b = edges[i].b, w = edges[i].w; a = find(a), b = find(b); if (a != b) // 如果两个连通块不连通，则将这两个连通块合并 { p[a] = b; res += w; cnt ++ ; } } if (cnt \u0026lt; n - 1) return INF; return res; } 染色法（本质dfs)判别二分图 —— 模板题 AcWing 860. 染色法判定二分图 给定一个 n 个点m条边的无向图，图中可能存在重边和自环。请你判断这个图是否是二分图。\n时间复杂度是 O(n+m), n 表示点数，m 表示边数\nint n; // n表示点数 int h[N], e[M], ne[M], idx; // 邻接表存储图 int color[N]; // 表示每个点的颜色，-1表示为染色，0表示白色，1表示黑色 // 参数：u表示当前节点，c表示当前点的颜色 bool dfs(int u, int c) { color[u] = c; for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (color[j] == -1) { if (!dfs(j, !c)) return false; } else if (color[j] == c) return false; } return true; } bool check() { memset(color, -1, sizeof color); bool flag = true; for (int i = 1; i \u0026lt;= n; i ++ ) if (color[i] == -1) if (!dfs(i, 0)) { flag = false; break; } return flag; } 匈牙利算法 —— 模板题 AcWing 861. 二分图的最大匹配 时间复杂度最坏是 O(nm)，实际运行时间一般远小于O(nm)， n 表示点数，m 表示边数\n做错一件事，错过一件事\nint n1, n2; // n1表示第一个集合中的点数，n2表示第二个集合中的点数 int h[N], e[M], ne[M], idx; // 邻接表存储所有边，匈牙利算法中只会用到从第二个集合指向第一个集合的边，所以这里只用存一个方向的边 int match[N]; // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个 bool st[N]; // 表示第二个集合中的每个点是否已经被遍历过 bool find(int x) { for (int i = h[x]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) { st[j] = true; if (match[j] == 0 || find(match[j])) { match[j] = x; return true; } } } return false; } // 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点 int res = 0; for (int i = 1; i \u0026lt;= n1; i ++ ) { memset(st, false, sizeof st); if (find(i)) res ++ ; } 作者：yxc 链接：https://www.acwing.com/blog/content/405/ 来源：AcWing 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n第四章 试除法判定质数 —— 模板题 AcWing 866. 试除法判定质数 质数：大于1的整数中，如果只包含1和本身两个约束，称为质数（素数）\n（1）判定，试除法\n（2）分解质因数\nbool is_prime(int x) { if (x \u0026lt; 2) return false; for (int i = 2; i \u0026lt;= x / i; i ++ ) if (x % i == 0) return false; return true; } 试除法分解质因数 —— 模板题 AcWing 867. 分解质因数 void divide(int x) { for (int i = 2; i \u0026lt;= x / i; i ++ ) if (x % i == 0) { int s = 0; while (x % i == 0) x /= i, s ++ ; cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; } if (x \u0026gt; 1) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; endl; } 朴素筛法求素数 —— 模板题 AcWing 868. 筛质数 int primes[N], cnt; // primes[]存储所有素数 bool st[N]; // st[x]存储x是否被筛掉 void get_primes(int n) { for (int i = 2; i \u0026lt;= n; i ++ ) { if (st[i]) continue; primes[cnt ++ ] = i; for (int j = i; j \u0026lt;= n; j += i) st[j] = true; } } 线性筛法求素数 —— 模板题 AcWing 868. 筛质数 被最小质因子筛掉\nint primes[N], cnt; // primes[]存储所有素数 bool st[N]; // st[x]存储x是否被筛掉 void get_primes(int n) { for (int i = 2; i \u0026lt;= n; i ++ ) { if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] \u0026lt;= n / i; j ++ ) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } 试除法求所有约数 —— 模板题 AcWing 869. 试除法求约数 int范围内约数个数最多为1500个左右\nvector\u0026lt;int\u0026gt; get_divisors(int x) { vector\u0026lt;int\u0026gt; res; for (int i = 1; i \u0026lt;= x / i; i ++ ) if (x % i == 0) { res.push_back(i); if (i != x / i) res.push_back(x / i); } sort(res.begin(), res.end()); return res; } 约数个数和约数之和 —— 模板题 AcWing 870. 约数个数, AcWing 871. 约数之和 如果 N = p1^c1 * p2^c2 * ... *pk^ck 约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1) 约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck) 欧几里得算法 —— 模板题 AcWing 872. 最大公约数 int gcd(int a, int b) { return b ? gcd(b, a % b) : a; } 求欧拉函数 —— 模板题 AcWing 873. 欧拉函数 欧拉函数公式（容斥原理) : n*(1-p1)*(1-p2)\u0026hellip;(1-pk)\nint phi(int x) { int res = x; for (int i = 2; i \u0026lt;= x / i; i ++ ) if (x % i == 0) { res = res / i * (i - 1); while (x % i == 0) x /= i; } if (x \u0026gt; 1) res = res / x * (x - 1); return res; } 筛法求欧拉函数 —— 模板题 AcWing 874. 筛法求欧拉函数 O(n) 线性求所有数的欧拉函数\n应用：欧拉定理：a与n互质 a^φ(n)=1(mod n)\nint primes[N], cnt; // primes[]存储所有素数 int euler[N]; // 存储每个数的欧拉函数 bool st[N]; // st[x]存储x是否被筛掉 void get_eulers(int n) { euler[1] = 1; for (int i = 2; i \u0026lt;= n; i ++ ) { if (!st[i]) { primes[cnt ++ ] = i; euler[i] = i - 1; } for (int j = 0; primes[j] \u0026lt;= n / i; j ++ ) { int t = primes[j] * i; st[t] = true; if (i % primes[j] == 0) { euler[t] = euler[i] * primes[j]; break; } euler[t] = euler[i] * (primes[j] - 1); } } } 快速幂 —— 模板题 AcWing 875. 快速幂 求 m^k mod p，时间复杂度 O(logk)。\nint qmi(int m, int k, int p) { int res = 1 % p, t = m; while (k) { if (k\u0026amp;1) res = res * t % p; t = t * t % p; k \u0026gt;\u0026gt;= 1; } return res; } 扩展欧几里得算法 —— 模板题 AcWing 877. 扩展欧几里得算法 // 求x, y，使得ax + by = gcd(a, b) int exgcd(int a, int b, int \u0026amp;x, int \u0026amp;y) { if (!b) { x = 1; y = 0; return a; } int d = exgcd(b, a % b, y, x); y -= (a/b) * x; return d; } 高斯消元 —— 模板题 AcWing 883. 高斯消元解线性方程组 O(n^3)时间内解n个方程n个未知数的解。\n解：无解 ； 无穷多组解 ； 唯一解 ；\n完美阶梯型：唯一解 *0=*非零 ： *无解 0=0 ： 无穷多组解 高斯消元：\n枚举每一列c：\n找到绝对值最大的一行 将该行换到最上面 将该行第一个数变成1 将下面所有行的第c列消成0 // a[N][N]是增广矩阵 int gauss() { int c, r; for (c = 0, r = 0; c \u0026lt; n; c ++ ) { int t = r; for (int i = r; i \u0026lt; n; i ++ ) // 找到绝对值最大的行 if (fabs(a[i][c]) \u0026gt; fabs(a[t][c])) t = i; if (fabs(a[t][c]) \u0026lt; eps) continue; for (int i = c; i \u0026lt;= n; i ++ ) swap(a[t][i], a[r][i]); // 将绝对值最大的行换到最顶端 for (int i = n; i \u0026gt;= c; i -- ) a[r][i] /= a[r][c]; // 将当前上的首位变成1 for (int i = r + 1; i \u0026lt; n; i ++ ) // 用当前行将下面所有的列消成0 if (fabs(a[i][c]) \u0026gt; eps) for (int j = n; j \u0026gt;= c; j -- ) a[i][j] -= a[r][j] * a[i][c]; r ++ ; } if (r \u0026lt; n) { for (int i = r; i \u0026lt; n; i ++ ) if (fabs(a[i][n]) \u0026gt; eps) return 2; // 无解 return 1; // 有无穷多组解 } for (int i = n - 1; i \u0026gt;= 0; i -- ) for (int j = i + 1; j \u0026lt; n; j ++ ) a[i][n] -= a[i][j] * a[j][n]; return 0; // 有唯一解 } 递归法求组合数 —— 模板题 AcWing 885. 求组合数 I 十万 1\u0026lt;b\u0026lt;a\u0026lt;2000 O(n^2)\n// c[a][b] 表示从a个苹果中选b个的方案数 for (int i = 0; i \u0026lt; N; i ++ ) for (int j = 0; j \u0026lt;= i; j ++ ) if (!j) c[i][j] = 1; else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod; 通过预处理逆元的方式求组合数 —— 模板题 AcWing 886. 求组合数 II 一万 1\u0026lt;b\u0026lt;a\u0026lt;10^5 O(logn)\n首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N] 如果取模的数是质数，可以用费马小定理求逆元 int qmi(int a, int k, int p) // 快速幂模板 { int res = 1; while (k) { if (k \u0026amp; 1) res = (LL)res * a % p; a = (LL)a * a % p; k \u0026gt;\u0026gt;= 1; } return res; } // 预处理阶乘的余数和阶乘逆元的余数 fact[0] = infact[0] = 1; for (int i = 1; i \u0026lt; N; i ++ ) { fact[i] = (LL)fact[i - 1] * i % mod; infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod; } ll C(ll n,ll m){ if(m\u0026gt;n) return 0ll; return fact[n]*infact[m]%mod*infact[n-m]%mod; } Lucas定理 —— 模板题 AcWing 887. 求组合数 III 组合数，1\u0026lt;b\u0026lt;a\n若p是质数，则对于任意整数 1 \u0026lt;= m \u0026lt;= n，有： C(n, m) = C(n % p, m % p) * C(n / p, m / p) (mod p) int qmi(int a, int k) // 快速幂模板 { int res = 1; while (k) { if (k \u0026amp; 1) res = (LL)res * a % p; a = (LL)a * a % p; k \u0026gt;\u0026gt;= 1; } return res; } int C(int a, int b) // 通过定理求组合数C(a, b) { int res = 1; for (int i = 1, j = a; i \u0026lt;= b; i ++, j -- ) { res = (LL)res * j % p; res = (LL)res * qmi(i, p - 2) % p; } return res; } int lucas(LL a, LL b) { if (a \u0026lt; p \u0026amp;\u0026amp; b \u0026lt; p) return C(a, b); return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p; } 分解质因数法求组合数 —— 模板题 AcWing 888. 求组合数 IV 当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：\n1. 筛法求出范围内的所有质数 2. 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^2 + n / p^3 + ... 3. 用高精度乘法将所有质因子相乘 int primes[N], cnt; // 存储所有质数 int sum[N]; // 存储每个质数的次数 bool st[N]; // 存储每个数是否已被筛掉 void get_primes(int n) // 线性筛法求素数 { for (int i = 2; i \u0026lt;= n; i ++ ) { if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] \u0026lt;= n / i; j ++ ) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } int get(int n, int p) // 求n！中的次数 { int res = 0; while (n) { res += n / p; n /= p; } return res; } vector\u0026lt;int\u0026gt; mul(vector\u0026lt;int\u0026gt; a, int b) // 高精度乘低精度模板 { vector\u0026lt;int\u0026gt; c; int t = 0; for (int i = 0; i \u0026lt; a.size(); i ++ ) { t += a[i] * b; c.push_back(t % 10); t /= 10; } while (t) { c.push_back(t % 10); t /= 10; } return c; } get_primes(a); // 预处理范围内的所有质数 for (int i = 0; i \u0026lt; cnt; i ++ ) // 求每个质因数的次数 { int p = primes[i]; sum[i] = get(a, p) - get(b, p) - get(a - b, p); } vector\u0026lt;int\u0026gt; res; res.push_back(1); for (int i = 0; i \u0026lt; cnt; i ++ ) // 用高精度乘法将所有质因子相乘 for (int j = 0; j \u0026lt; sum[i]; j ++ ) res = mul(res, primes[i]); 卡特兰数 —— 模板题 AcWing 889. 满足条件的01序列 给定n个0和n个1，它们按照某种顺序排成长度为2n的序列，满足任意前缀中0的个数都不少于1的个数的序列的数量为： $$ Cat(n) = C(2n, n) / (n + 1) $$\n容斥原理 找1~n中能至少被素数p1,p2,\u0026hellip;,pn一个整除的整数有多少个。\n位运算对应容斥原理集合，1~n中能被x整除的个数为n/x，奇数加上，偶数减去\nNIM(尼姆)游戏 —— 模板题 AcWing 891. Nim游戏 给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。\n我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。 所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。 NIM博弈不存在平局，只有先手必胜和先手必败两种情况。\n定理： NIM博弈先手必胜，当且仅当 A1 ^ A2 ^ … ^ An != 0\n公平组合游戏ICG 若一个游戏满足：\n由两名玩家交替行动； 在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关； 不能行动的玩家判负； 则称该游戏为一个公平组合游戏。 NIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件2和条件3。\n有向图游戏 给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。 任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。\nMex运算 设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即： mex(S) = min{x}, x属于自然数，且x不属于S\nSG函数 在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达节点y1, y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk 的SG函数值构成的集合再执行**mex(S)**运算的结果，即： SG(x) = mex({SG(y1), SG(y2), …, SG(yk)}) 特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G) = SG(s)。\nint sg(int x){ if (f[x] != -1) return f[x]; unordered_set\u0026lt;int\u0026gt; S; for(int i = 0; i \u0026lt; m; i++ ) { int sum = s[i]; if (x \u0026gt;= sum) S.insert(sg(x - sum)); } for (int i=0; ; i++ ) if (!S.count(i)) return f[x] = i; } 有向图游戏的和 —— 模板题 AcWing 893. 集合-Nim游戏 设G1, G2, …, Gm 是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。 有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即： SG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm)\n定理 有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。 有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。\n作者：yxc 链接：https://www.acwing.com/blog/content/406/ 来源：AcWing 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n时空复杂度分析 当处理ACM或笔试题时，通常时间限制为1秒或2秒。在这种情况下，C++代码中的操作次数应控制在10^7 到 10^8之间，这是最佳范围。\n以下是在不同数据规模下，代码的时间复杂度和算法选择的指导：\nn ≤ 30：指数级别，使用DFS+剪枝，状态压缩DP。 n ≤ 100：O(n^3)，适用于Floyd、DP、高斯消元。 n ≤ 1000：O(n^2)或O(n^2*logn)，适用于DP、分治、高斯消元、朴素版Dijkstra、朴素版Prim、Bellman-Ford。 n ≤ 10000：O(n * √n)，适用于块状链表、分块、莫队。 n ≤ 100000：O(nlogn)，适用于各种排序、线段树、树状数组、集合/映射、堆、拓扑排序、Dijkstra+堆、Prim、Kruskal、SPFA、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树。 n \u0026lt; 1000000：O(n)或常数较小的O(nlogn)，适用于单调队列、哈希映射、双指针扫描、BFS、并查集、KMP、AC自动机、常数较小的O(nlogn)的做法（如排序、树状数组、堆、Dijkstra、SPFA）。 n \u0026lt; 10000000：O(n)，适用于双指针扫描、KMP、AC自动机、线性筛素数。 n ≤ 10^9：O(n√n)，适用于判断质数。 n ≤ 10^18：O(logn)，适用于最大公约数、快速幂、数位DP。 n ≤ 10^1000：O((logn)^2)，适用于高精度加减乘除。 n ≤ 10^100000：O(logk × loglogk)，其中k表示位数，适用于高精度加减、FFT/NTT。 动态规划计算量 ： 状态数 * 状态转移数量\n1 Byte = 8 bit\n1KB = 1024 Byte\n1MB = 102410241024 Byte\n1GB = 1024 * 1024 * 1024 Byte\nint 4 Byte\nchar 1 Byte\ndouble, long long 8 Byte\n动态规划 常见模型\n背包 九讲 01背包 每件物品最多可以用一次\n体积从大到小的原因 ： 如果从小到大，则f[j-w[i]]+v[i]实际是f[i-1][j-w[i]]+v[i]，需要的是上一维度f[i-1]维度，所以从大到小可以使用上一维度的，因为这一维度的还没有被计算到。\nfor(int i=1;i\u0026lt;=N;i++){ for(int j=V;j\u0026gt;=w[i];j--){ f[j]=max(f[j],f[j-w[i]]+v[i]); } } 完全背包 每件物品可以用无限次\nfor(int i=1;i\u0026lt;=N;i++){ for(int j=w[i];j\u0026lt;=V;j++){ f[j]=max(f[j],f[j-w[i]]+v[i]); } } 多重背包 每件物品特定数量\n二进制优化 for(int i=1;i\u0026lt;=N;i++){ cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c; //权重a,价值b，数量c int k=1; while(k\u0026lt;=c){ cnt++; c-=k; w[cnt]=k*a; v[cnt]=k*b; k*=2; } if(c){ cnt++; w[cnt]=c*a; v[cnt]=c*b; } } //之后用01背包 单调队列优化 for(int i=1;i\u0026lt;=N;i++){ // 遍历每件物品 memcpy(g, f, sizeof g); // 将上一轮的最优解拷贝给g数组 for(int r=0;r\u0026lt;v[i];r++){ // 遍历余数r（用于优化循环） int h=0,t=-1; // 滑动窗口的起始索引和结束索引 for(int l=r;l\u0026lt;=V;l+=v[i]){ // 遍历背包容量，间隔为当前物品体积 while(h\u0026lt;=t \u0026amp;\u0026amp; l-q[h]\u0026gt;s[i]*v[i]) h++; // 如果窗口左边界超出限制，则左边界右移 while(h\u0026lt;=t \u0026amp;\u0026amp; g[q[t]] + (l-q[t])/v[i]*w[i]\u0026lt;=g[l]) t--; // 保持窗口单调性，将窗口内不符合条件的解移除 q[++t] = l; // 将当前状态的背包容量加入窗口 f[l] = g[q[h]] + (l-q[h])/v[i]*w[i]; // 更新当前状态的最优解 } } } 分组背包 若干组，一组只能选一个\nfor(int i=1;i\u0026lt;=N;i++){ for(int j=V;j\u0026gt;=0;j--){ for(int k=1;k\u0026lt;=s[i];k++){ if(w[i][k]\u0026lt;=j){ f[j]=max(f[j],f[j- w[i][k] ]+v[i][k]); } } } } 混合背包 转换成01背包问题\nfor(int i=1;i\u0026lt;=N;i++){ cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;s; if(s==-1) s=1; else if(s==0) s=V/a; k=1; while(k\u0026lt;=s){ s-=k; cnt++; v[cnt] = k*a; w[cnt] = k*b; k*=2; } if(s){ cnt++; v[cnt] = s*a; w[cnt] = s*b; } } for(int i=1;i\u0026lt;=cnt;i++){ for(int j=V;j\u0026gt;=v[i];j--){ f[j] = max(f[j], f[j-v[i]]+w[i]); } } 二维费用的背包问题 采用两层循环\ncin\u0026gt;\u0026gt;N\u0026gt;\u0026gt;V\u0026gt;\u0026gt;W; for(int i=1;i\u0026lt;=N;i++){ cin\u0026gt;\u0026gt;v\u0026gt;\u0026gt;m\u0026gt;\u0026gt;w; for(int j=V;j\u0026gt;=v;j--){ for(int k=W;k\u0026gt;=m;k--){ f[j][k] = max(f[j][k], f[j-v][k-m] + w); } } } cout\u0026lt;\u0026lt;f[V][W]\u0026lt;\u0026lt;endl; 线性dp 数字三角形 for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=i;j++){ a[i][j]+=max(a[i-1][j],a[i-1][j-1]); } } LIS for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;i;j++){ if(a[j]\u0026lt;a[i]) f[i]=max(f[j]+1,f[i]); } } for(int i=1;i\u0026lt;=n;i++){ ma=max(f[i],ma); } LCS for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=m;j++){ f[i][j]=max(f[i-1][j],f[i][j-1]); if(a[i]==b[j]) f[i][j]=f[i-1][j-1]+1; } } 区间dp 石子合并 memset(f, 0x3f, sizeof f); for(int len=2;len\u0026lt;=n;len++){ for(int i=1;i+len-1\u0026lt;=n;i++){ int j=i+len-1; if (len == 1) { f[i][j] = 0; // 边界初始化 continue; } for(int k=i;k\u0026lt;j;k++){ f[l][r]=min(f[l][r],f[l][k]+f[k+1][r]+s[r]-s[l-1]); } } } cout\u0026lt;\u0026lt;f[1][n]; 数位统计dp 状态表示\n分情况讨论\n状态压缩 dp 蒙德里安的梦想\n最短Hamilton距离\n树形dp 没有上司的舞会\n记忆化 滑雪\n#include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long const int maxn=1e4; ll f[maxn][maxn],g[maxn][maxn]; //distance struct node{ ll i,j,num; }a[maxn]; struct cmp { bool operator () (node x,node y){ return x.num\u0026gt;y.num; } }; int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); ll n,m,ma=-1; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; priority_queue\u0026lt;node, vector\u0026lt;node\u0026gt;,cmp\u0026gt;pq; for(ll i=1;i\u0026lt;=n;i++){ for(ll j=1;j\u0026lt;=m;j++){ f[i][j]=1; node a; a.i=i; a.j=j; cin\u0026gt;\u0026gt;a.num; g[i][j]=a.num; pq.push(a); } } while(!pq.empty()){ node t=pq.top(); pq.pop(); ll i=t.i; ll j=t.j; ll nu=t.num; if(g[i-1][j]\u0026lt;nu) f[i][j]=max(f[i][j],f[i-1][j]+1); if(g[i+1][j]\u0026lt;nu) f[i][j]=max(f[i][j],f[i+1][j]+1); if(g[i][j-1]\u0026lt;nu) f[i][j]=max(f[i][j],f[i][j-1]+1); if(g[i][j+1]\u0026lt;nu) f[i][j]=max(f[i][j],f[i][j+1]+1); ma=max(ma,f[i][j]); } cout\u0026lt;\u0026lt;ma\u0026lt;\u0026lt;endl; return 0; } 习题课 ","permalink":"https://showguan.github.io/en/posts/tech/acwing/","summary":"acwing算法学习 [TOC] 第一章 课上：学思想 课下：背代码 题目，一道题写好几遍 理解没有任何意义，体力活+脑力活 记忆力 毅力/自制力 沉下心背东西 快速排","title":""},{"content":"图片 ","permalink":"https://showguan.github.io/en/posts/tech/image/","summary":"图片","title":""},{"content":"$x^2$\n","permalink":"https://showguan.github.io/en/posts/tech/math/","summary":"$x^2$","title":""},{"content":"title = \u0026lsquo;后端八股学习笔记\u0026rsquo; date = 2024-04-06T17:47:22+08:00 draft = false\n+++\n后端八股学习笔记 想要生活能进步，就不能走退步路。\n计算机网络 网络是把主机连接起来，而互联网(Internet)是把多种不同的网络连接起来，因此互联网是网络的网络，而互联网(Internet)是全球范围的互联网。 ISP 互联网服务提供商ISP可以从互联网管理机构获得许多IP地址，同时拥有通信线路以及路由器等联网设备，个人或机构向ISP缴纳一定的费用就可以接入互联网。\n目前的互联网是一种多层次ISP结构，ISP根据覆盖面积的大小分为第一层ISP，区域ISP和接入ISP。**互联网交换点IXP（Internet Exchange Point)**允许两个ISP直接相连而不用经过第三个ISP。\n主机之间的通信方式 客户-服务器（C/S）：客户是服务的请求方，服务器 是服务的提供方。\n对等（P2P）：不区分客户和服务器\n电路交换与分组交换 1.电路交换 电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到10%。\n2.分组交换 每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。\n在同一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发的过程，分组交换也使用了存储转发过程。\n时延 总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延\n1.排队时延 分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。\n2.处理时延 主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。\n3.传输时延 主机或路由器传输数据帧所需要的时间。 $$ delay = \\frac{l(bit)}{v(bit/s)} $$ $l$:数据帧的长度, $v$:传输速率\n4.传播时延 电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。 $$ delay = \\frac{l(m)}{v(m/s)} $$ $l$:表示信道长度， $v$:表示电磁波在信道上的传播速度\n计算机网络体系结构 1.五层协议 应用层：为特定应用程序提供数据传输服务，例如HTTP，DNS等协议。数据单位为报文。\n传输层：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议UDP，提供无连接的、尽最大努力的数据传输服务，数据单位为用户数据报。TCP主要提供完整性服务，UDP主要提供及时性服务。\n网络层：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。\n数据链路层：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。\n物理层：考虑的是怎样在传输媒体上传输比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。\n2.OSI (Open Systems Interconnection，开放式系统互联)\n其中表示层和会话层用途如下：\n表示层：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。 会话层：建立及管理会话。 五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。\n3.TCP/IP 只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。\nTCP/IP体系结构不严格遵循OSI分层概念，应用层可能会直接使用IP层或者网络接口层。\n4.数据在各层之间的传递过程 在向下的过程中，需要添加下层协议所需要的首部和尾部，而在向上的过程中不断拆开首部和尾部。\n路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。\n物理层 通信方式 根据信息在传输线上的传送方向，分为一下三种通信方式：\n单工通信：单向传输 半双工通信：双向交替传输 全双工通信：双向同时传输 带通调制 模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号。\n链路层 基本问题 1.封装成帧 把网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。\n2.透明传输 透明表示一个实际存在的事物看起来好像不存在一样。\n帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。\n3.差错检测 目前数据链路层广泛使用了**循环冗余检验（CRC，Cyclic Redundancy Check）**来检查比特差错。\n信道分类 1.广播信号 一对多通信，一个节点发送的数据能够被广播信道上所有的节点接受到。\n所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。\n主要有两种控制方法进行协调，一个是使用信道复用技术；另一个是使用CSMA/CD协议。\n2.点对点信道 一对一通信。\n因为不会发生碰撞，因此也比较简单，使用PPP（Point-to-Point Protocol）协议进行控制。\n信道复用技术 1.频分复用 频分复用的所有主机在相同的时间占用不同的频率带宽资源。\n2.时分复用 时分复用的所有主机在不同的事件占用相同的频率带宽资源。\n使用频分复用和时分复用进行通信，在通信的过程中主机会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其他用户使用，因此这两种方式对信道的利用率都不高。\n3.统计时分复用 是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。\n4.波分复用 光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。\n5.码分复用 为每个用户分配$m\\ bit$ 的码片，并且所有的码片正交，对于任意两个码片$\\vec{S}$和$\\vec{T}$有 $$ \\frac{1}{m}\\vec{S}\\ \\cdot \\vec{T} = 0 $$ 为了讨论方便，取$m=8$, 设码片$\\vec{S}$为$00011011$。在拥有该码片额用户发送比特1时就发送该码片，发送比特0时就发送该码片的反码$11100100$\n在计算时将$00011011$记作（$-1-1-1+1+1-1+1+1$）,可以得到： $$ \\frac{1}{m}\\vec{S} \\cdot \\vec{S}=1 $$\n$$ \\frac{1}{m}\\vec{S} \\cdot \\vec{S}\u0026rsquo;=-1 $$\n其中$\\vec{S}\u0026rsquo;$是$\\vec{S}$的反码\n利用上面的式子可知，当接收端使用码片$\\vec{S}\u0026rsquo;$对接受到的数据进行内积运算时， 结果为0的是其它用户发送的数据，结果为1的是用户发送的比特1,结果为-1的是用户发送的比特0。\n码分复用需要发送的数据量为原先的m倍。\nCSMA/CD协议 CSMA/CD表示载波监听多点接入/碰撞检测。\n多点接入：说明这是总线型网络，许多主机以多点的方式连接到总线上 载波监听：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。 碰撞检测：在发送中，如果监听到信道已有其他主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。 记端到端的传播时延为$\\tau$, 最先发送的站点最多经过$2\\tau$就可以知道是否发生了碰撞，称$2\\tau$为争用期。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。\n当发生碰撞时， 站点要停止发送，等待一段时间再发送。这个时间采用截断二进制指数退避算法来确定。从离散的整数集合${0, 1, \u0026hellip;, (2^k-1)}$中随机取出一个数，记作$r$， 然后取$r$倍的争用期作为重传等待时间。\nPPP协议 互联网用户通常需要连接到某个ISP之后才能接入互联网，PPP协议时用户计算机和ISP进行通信时所使用的数据链路层协议。\nPPP的帧格式：\nF字段为帧的定界符 A和C字段暂时没有意义 FCS字段是使用CRC的检验序列 信息部分的长度不超过1500 MAC地址 MAC地址是链路层地址，长度为6字节（48位）， 用于唯一表示网络适配器（网卡）。\n一台主机拥有多少个网络适配器就有多少个MAC地址。例如笔记本电脑普遍存在无限网络适配器和有线网络适配器，因此就有两个MAC地址。\n局域网 局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有， 且地理范围和站点数目均有限。\n主要有以太网、令牌环网络、FDDI和ATM等局域网技术，目前以太网占领着有线局域网市场。\n可以按照网络拓扑结构对局域网进行分类。\n以太网 以太网是一种星型拓扑结构局域网。\n早起使用集线器进行连接，集线器是一种物理层设备。作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其他所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。\n目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据MAC地址进行存储转发。\n以太网格式：\n类型：标记上层使用的协议 数据：长度为46~1500之间，如果太小则需要填充 FCS：真检验序列，使用的时CRC检验方法 交换机 ","permalink":"https://showguan.github.io/en/posts/tech/%E5%90%8E%E7%AB%AF%E5%85%AB%E8%82%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","summary":"title = \u0026lsquo;后端八股学习笔记\u0026rsquo; date = 2024-04-06T17:47:22+08:00 draft = false +++ 后端八股学习笔记 想要生活能进步，就不能走退步路。 计算机网络 网络是把主机连接起来","title":""},{"content":"蓝桥杯笔记 以后做事：切记切记切记，不要一直做新题，及时复习是最重要的。\n一定一定拿一个国奖，6~7月准备两个项目，八月开始投简历。\n真题一定要全部过一遍\n一、基础复习阶段 3.4~3.10\n二、刷题 3.10~3.20\n三、刷真题，搞懂每一道真题 3.20~4.10\n程序易错点 ：\n变量未声明 i,j,k变量写错了 11+12+16+15+12+12 = 78\n七夕祭 $$ p[i] : i给i+1 \\enspace p[i]个糖果 \\ 则 ans = \\sum_{i=1}^n|p[i]| \\ p[1]=a[1]-avg \\ 递推 \\enspace p[2]=p[1]+a[2]-avg \\ p[3]=p[2]+a[3]-avg = p[1]+a[2]-avg+a[3]-avg \\ p[4]=p[3]+a[4]-avg = p[2]+p[3]-avg+a[4]-avg = p[1]+a[2]-avg+a[3]-avg+a[4]-avg \\ =\\sum_{i=2}^4{(a[i]-avg)} - p[1] \\ ans = $$\nfrom collections import defaultdict r = defaultdict(int) c = defaultdict(int) s = defaultdict(int) def get_ans(a, n): ans = 0 avg = sum(a.values()) // n for i in a: a[i] -= avg s[1] = 0 prev_sum = 0 sorted_values = sorted(a.values()) mid = sorted_values[n // 2] for i in range(2, n + 1): prev_sum += a[i] s[i] = prev_sum for i in s.values(): ans += abs(i - mid) return ans n, m, t = map(int, input().split()) for _ in range(t): x, y = map(int, input().split()) r[x] += 1 c[y] += 1 if t % n != 0 and t % m != 0: print(\u0026#34;impossible\u0026#34;) elif t % n == 0 and t % m == 0: print(\u0026#34;both\u0026#34;, get_ans(r, n) + get_ans(c, m)) elif t % n == 0: print(\u0026#34;row\u0026#34;, get_ans(r, n)) else: print(\u0026#34;column\u0026#34;, get_ans(c, m)) 模板 基础+杂项 快速排序 def quick_sort(q, l, r): if l\u0026gt;=r: return i,j,x=l-1,r+1,q[(l+r)\u0026gt;\u0026gt;1] while i\u0026lt;j: i+=1 while q[i]\u0026lt;x: i+=1 j-=1 while q[j]\u0026gt;x: j-=1 if i\u0026lt;j: q[i], q[j] = q[j], q[i] quick_sort(q, l, j) quick_sort(q, j+1, r) n=int(input()) arr=list(map(int, input().split())) quick_sort(arr,0,n-1) print(\u0026#34; \u0026#34;.join(map(str, arr))) 归并排序 j = mid+1 !!!\ndef merge_sort(q,l,r): if l\u0026gt;=r: return mid = (l+r)\u0026gt;\u0026gt;1 merge_sort(q, l, mid) merge_sort(q, mid+1, r) i,j,k = l, mid+1, 0 tmp = [0]*(r-l+1) while i\u0026lt;=mid and j\u0026lt;=r: if q[i]\u0026lt;q[j]: tmp[k]=q[i] k+=1 i+=1 else: tmp[k]=q[j] k+=1 j+=1 while i\u0026lt;=mid: tmp[k]=q[i] i+=1 k+=1 while j\u0026lt;=r: tmp[k]=q[j] j+=1 k+=1 for i in range(l, r+1): q[i]=tmp[i-l] n=int(input()) arr=list(map(int, input().split())) merge_sort(arr, 0, n-1) print(\u0026#34; \u0026#34;.join(map(str, arr))) 二分 def check(x): # 检查 x 是否满足某种性质 pass # 这里需要根据具体的情况实现 def bsearch_1(l, r): while l \u0026lt; r: mid = (l + r) // 2 if check(mid): r = mid else: l = mid + 1 return l def bsearch_2(l, r): while l \u0026lt; r: mid = (l + r + 1) // 2 if check(mid): l = mid else: r = mid - 1 return l # 示例用法 # 首先定义 check 函数来检查性质 # 然后使用 bsearch_1 或 bsearch_2 来进行二分搜索 浮点数二分 def check(x): # 检查x是否满足某种性质 pass # 这里需要根据具体情况实现check函数 def bsearch_3(l, r): eps = 1e-6 # eps 表示精度，取决于题目对精度的要求 while r - l \u0026gt; eps: mid = (l + r) / 2 if check(mid): r = mid else: l = mid return l 一维前缀和 def prefixSum(arr): n = len(arr) prefixSum = [0] * n prefixSum[0] = arr[0] for i in range(1, n): prefixSum[i] = prefixSum[i-1] + arr[i] for i in range(n): print(prefixSum[i], end=\u0026#34; \u0026#34;) arr = [1, 2, 3, 4, 5] prefixSum(arr) 二维前缀和 def prefixSum2D(arr): n = len(arr) m = len(arr[0]) prefixSum = [[0] * m for _ in range(n)] # 计算第一行的前缀和 prefixSum[0][0] = arr[0][0] for j in range(1, m): prefixSum[0][j] = prefixSum[0][j-1] + arr[0][j] # 计算第一列的前缀和 for i in range(1, n): prefixSum[i][0] = prefixSum[i-1][0] + arr[i][0] # 计算其他部分的前缀和 for i in range(1, n): for j in range(1, m): prefixSum[i][j] = prefixSum[i-1][j] + prefixSum[i][j-1] - prefixSum[i-1][j-1] + arr[i][j] return prefixSum def submatrixSum(prefixSum, x1, y1, x2, y2): return prefixSum[x2][y2] - prefixSum[x1-1][y2] - prefixSum[x2][y1-1] + prefixSum[x1-1][y1-1] arr = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]] prefixSum = prefixSum2D(arr) print(prefixSum) x1, y1 = 1, 1 x2, y2 = 2, 2 submatrixSum = submatrixSum(prefixSum, x1, y1, x2, y2) print(submatrixSum) 一维差分 差分和前缀和是逆运算。\n需要计算某一段区间$+-$操作时，运用差分操作 updateRange 需要先构造差分数组\n$s[i] = s[i-1]+a[i]$ 逆运算 $d[i]=a[i]-a[i-1]$ （原数组看作为前缀和数组）\ndef updateRange(B, l, r, c): B[l] += c B[r + 1] -= c def printArray(arr): for i in range(len(arr)): print(arr[i], end=\u0026#34; \u0026#34;) print() n= 5 B = [0] * (n + 1) updateRange(B, 1, 3, 2) updateRange(B, 2, 4, 3) printArray(B) 二维差分 def updateSubmatrix(S, x1, y1, x2, y2, c): S[x1][y1] += c S[x2 + 1][y1] -= c S[x1][y2 + 1] -= c S[x2 + 1][y2 + 1] += c def printMatrix(S): rows = len(S) cols = len(S[0]) for i in range(rows): for j in range(cols): print(S[i][j], end=\u0026#34; \u0026#34;) print() rows = 3 cols = 3 S = [[0] * cols for _ in range(rows + 1)] updateSubmatrix(S, 0, 0, 1, 1, 1) updateSubmatrix(S, 1, 1, 2, 2, 2) printMatrix(S) 双指针 for i in range(n): j = 0 while j \u0026lt; i and check(j, i): j += 1 # 具体问题的逻辑 # 常见问题分类： # (1) 对于一个序列，用两个指针维护一段区间 # (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作 位运算 原码，反码，补码 求n二进制表示中第k位数字: n \u0026gt;\u0026gt; k \u0026amp; 1 返回n的最后一位1：lowbit(n) = n \u0026amp; -n 树状数组基本操作 离散化 alls = [] # 存储所有待离散化的值 # 将所有值排序 alls.sort() # 去掉重复元素 alls = list(set(alls)) # 二分求出x对应的离散化的值 def find(x): l, r = 0, len(alls) - 1 while l \u0026lt; r: mid = (l + r) // 2 if alls[mid] \u0026gt;= x: r = mid else: l = mid + 1 return r + 1 # 映射到1, 2, ...n 区间合并 def merge(segs): segs.sort() # 区间左端点排序 res = [] st, ed = -2e9, -2e9 for seg in segs: if ed \u0026lt; seg[0]: if st != -2e9: res.append((st, ed)) st, ed = seg[0], seg[1] else: ed = max(ed, seg[1]) if st != -2e9: res.append((st, ed)) segs[:] = res 数据结构 单链表 N = int(1e5+10) e=[0]*N ne=[0]*N head=-1 idx=1 def insert(x): global idx, head e[idx]=x ne[idx]=head head=idx idx+=1 def add(k, x): global idx e[idx]=x ne[idx]=ne[k] ne[k]=idx idx+=1 def remove(k): global idx, head if k==0: head = ne[head] else: ne[k]=ne[ne[k]] n = int(input()) for _ in range(n): s = input().split() op=s[0] if op==\u0026#39;H\u0026#39;: insert(int(s[1])) elif op==\u0026#39;I\u0026#39;: add(int(s[1]), int(s[2])) else: remove(int(s[1])) i=head while i!=-1: print(e[i], end=\u0026#39; \u0026#39;) i=ne[i] 双链表 N = int(1e5+10) e=[0]*N l=[0]*N r=[0]*N idx=0 def init(): global idx r[2]=1 l[1]=2 idx=3 def insert(k, x): global idx e[idx]=x l[idx]=k r[idx]=r[k] l[r[k]]=idx r[k]=idx idx+=1 def remove(k): l[r[k]]=l[k] r[l[k]]=r[k] init() m=int(input()) for _ in range(m): s=input().split() if s[0]==\u0026#39;L\u0026#39;: x=int(s[1]) insert(2,x) elif s[0]==\u0026#39;R\u0026#39;: x=int(s[1]) insert(l[1],x) elif s[0]==\u0026#39;D\u0026#39;: k=int(s[1])+2 remove(k) elif s[0]==\u0026#39;IL\u0026#39;: k=int(s[1])+2 x=int(s[2]) insert(l[k],x) elif s[0]==\u0026#39;IR\u0026#39;: k=int(s[1])+2 x=int(s[2]) insert(k,x) i=2 while i!=0: if i==2 or i==1: i=r[i] continue print(e[i],end=\u0026#34; \u0026#34;) i=r[i] 栈 N = int(1e5+10) # 假设N的值为100 stk = [0] * N tt = 0 # 向栈顶插入一个数 tt += 1 stk[tt] = x # 从栈顶弹出一个数 tt -= 1 # 栈顶的值 stk[tt] # 判断栈是否为空 if tt \u0026gt; 0: pass 队列 N = 100 # 假设N的值为100 q = [0] * N hh = 0 tt = -1 # 向队尾插入一个数 tt += 1 q[tt] = x # 从队头弹出一个数 hh += 1 # 队头的值 q[hh] # 判断队列是否为空 if hh \u0026lt;= tt: pass N = 100 # 假设N的值为100 q = [0] * N hh = 0 tt = 0 # 向队尾插入一个数 q[tt] = x tt += 1 if tt == N: tt = 0 # 从队头弹出一个数 hh += 1 if hh == N: hh = 0 # 队头的值 q[hh] # 判断队列是否为空 if hh != tt: pass 单调栈 tt = 0 stk = [0] * (n + 1) for i in range(1, n + 1): while tt and check(stk[tt], i): tt -= 1 stk[tt + 1] = i tt += 1 单调队列 n = 10 # 假设n的值为10 hh = 0 tt = -1 q = [0] * n for i in range(n): while hh \u0026lt;= tt and check_out(q[hh]): hh += 1 while hh \u0026lt;= tt and check(q[tt], i): tt -= 1 q[tt + 1] = i tt += 1 N = int(1e6+10) q=[0 for _ in range(N)] n,k=map(int, input().split()) a=[0]+[int(x) for x in input().split()] hh,tt=0,-1 for i in range(1,n+1): if hh\u0026lt;=tt and i-q[hh]+1\u0026gt;k: hh+=1 while hh\u0026lt;=tt and a[q[tt]] \u0026gt;= a[i]: tt-=1 tt+=1 q[tt]=i if i \u0026gt;= k: print(a[q[hh]], end=\u0026#34; \u0026#34;) print() hh,tt=0,-1 for i in range(1,n+1): if hh\u0026lt;=tt and i-q[hh]+1\u0026gt;k: hh+=1 while hh\u0026lt;=tt and a[q[tt]] \u0026lt;= a[i]: tt-=1 tt+=1 q[tt]=i if i\u0026gt;=k: print(a[q[hh]], end=\u0026#34; \u0026#34;) KMP m = len(p) # 假设p为模板串，长度为m n = len(s) # 假设s为模式串，长度为n ne = [0] * (m + 1) # 初始化ne数组 # 求Next数组 j = 0 for i in range(2, m + 1): while j and p[i] != p[j + 1]: j = ne[j] if p[i] == p[j + 1]: j += 1 ne[i] = j # 匹配 j = 0 for i in range(1, n + 1): while j and s[i] != p[j + 1]: j = ne[j] if s[i] == p[j + 1]: j += 1 if j == m: j = ne[j] # 匹配成功后的逻辑 Tire N = 100010 son = [[0] * 26 for _ in range(N)] cnt = [0] * N idx = 0 # 0号点既是根节点，又是空节点 # son[][]存储树中每个节点的子节点 # cnt[]存储以每个节点结尾的单词数量 # 插入一个字符串 def insert(s): global idx p = 0 for i in range(len(s)): u = ord(s[i]) - ord(\u0026#39;a\u0026#39;) if not son[p][u]: idx += 1 son[p][u] = idx p = son[p][u] cnt[p] += 1 # 查询字符串出现的次数 def query(s): p = 0 for i in range(len(s)): u = ord(s[i]) - ord(\u0026#39;a\u0026#39;) if not son[p][u]: return 0 p = son[p][u] return cnt[p] 并查集 N = 1000005 # 假设N的值为1000005 p = [0] * N # 初始化p数组 # 返回x的祖宗节点 def find(x): if p[x] != x: p[x] = find(p[x]) return p[x] # 初始化，假定节点编号是1~n for i in range(1, n + 1): p[i] = i # 合并a和b所在的两个集合 p[find(a)] = find(b) 维护size信息\n# Python中没有类似于C++的数组声明方式，我们直接使用列表来代替 p = [i for i in range(N)] size = [1] * N # 返回x的祖宗节点 def find(x): if p[x] != x: p[x] = find(p[x]) return p[x] # 初始化，假定节点编号是1~n n = N # 假设n是提前定义好的 for i in range(1, n + 1): p[i] = i size[i] = 1 # 合并a和b所在的两个集合 p[find(a)] = find(b) size[b] += size[a] 维护到祖宗节点距离的并查集\n# Python中没有类似于C++的数组声明方式，我们直接使用列表来代替 p = [i for i in range(N)] d = [0] * N # 返回x的祖宗节点 def find(x): if p[x] != x: u = find(p[x]) d[x] += d[p[x]] p[x] = u return p[x] # 初始化，假定节点编号是1~n n = N # 假设n是提前定义好的 for i in range(1, n + 1): p[i] = i d[i] = 0 # 合并a和b所在的两个集合 p[find(a)] = find(b) d[find(a)] = distance # 根据具体问题，初始化find(a)的偏移量 堆 # h[N] 存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1 # ph pos[k] 存储第k个插入的点在堆中的位置 # hp ord[k] 存储堆中下标是k的点是第几个插入的 N = 1000005 # 假设N的值为1000005 h = [0] * N # 初始化h数组 ph = [0] * N # 初始化ph数组 hp = [0] * N # 初始化hp数组 size = 0 # 初始化size为0 # 交换两个点，及其映射关系 def heap_swap(a, b): ph[hp[a]], ph[hp[b]] = ph[hp[b]], ph[hp[a]] hp[a], hp[b] = hp[b], hp[a] h[a], h[b] = h[b], h[a] def down(u): t = u if u * 2 \u0026lt;= size and h[u * 2] \u0026lt; h[t]: t = u * 2 if u * 2 + 1 \u0026lt;= size and h[u * 2 + 1] \u0026lt; h[t]: t = u * 2 + 1 if u != t: heap_swap(u, t) down(t) def up(u): while u // 2 and h[u] \u0026lt; h[u // 2]: heap_swap(u, u // 2) u \u0026gt;\u0026gt;= 1 # O(n)建堆 for i in range(n // 2, 0, -1): down(i) def add_element(x): global size size += 1 h[size] = x ph[size] = size hp[size] = size up(size) def get_heap_top(): return h[1] def delete_element(k): global size heap_swap(k, size) size -= 1 down(k) up(k) def update_element(k, x): h[k] = x down(k) up(k) # 添加元素 add_element(x) # 堆顶元素 heap_top = get_heap_top() # 删除第size个节点 delete_element(1) # 删除第k个节点 delete_element(k) # 将第k个元素赋值为x update_element(k, x) 哈希 (1)拉链法 N = 1000005 # 假设N的值为1000005 h = [-1] * N # 初始化h数组为-1 e = [0] * N # 初始化e数组 ne = [0] * N # 初始化ne数组 idx = 0 # 初始化idx为0 # 向哈希表中插入一个数 def insert(x): k = (x % N + N) % N e[idx] = x ne[idx] = h[k] h[k] = idx idx += 1 # 在哈希表中查询某个数是否存在 def find(x): k = (x % N + N) % N i = h[k] while i != -1: if e[i] == x: return True i = ne[i] return False (2) 开放寻址法 N = 1000005 # 假设N的值为1000005 h = [0] * N # 初始化h数组 # 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置 def find(x): t = (x % N + N) % N while h[t] != 0 and h[t] != x: t += 1 if t == N: t = 0 return t 字符串哈希 N = 1000005 # 假设N的值为1000005 P = 131 # 或者可以设置为13331 h = [0] * N # 初始化h数组 p = [0] * N # 初始化p数组 # 初始化 p[0] = 1 for i in range(1, n + 1): h[i] = h[i - 1] * P + ord(str[i]) p[i] = p[i - 1] * P # 计算子串 str[l ~ r] 的哈希值 def get(l, r): return h[r] - h[l - 1] * p[r - l + 1] 图论 树的存储 邻接矩阵 # 创建一个二维列表表示邻接矩阵 n = 10 # 顶点数量 g = [[0] * n for _ in range(n)] # 添加一条边a-\u0026gt;b def add_edge(a, b): g[a][b] = 1 # 初始化 g = [[0] * n for _ in range(n)] 邻接表 # 创建一个列表表示邻接表 n = 10 # 顶点数量 h = [-1] * n e = [0] * n ne = [0] * n idx = 0 # 添加一条边a-\u0026gt;b def add_edge(a, b): global idx e[idx] = b ne[idx] = h[a] h[a] = idx idx += 1 # 初始化 idx = 0 h = [-1] * n 树和图的存储 # 邻接表表示的图 N = 100010 # 根据具体需求设置合适的最大节点数量 # 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点 h = [-1] * N # 存储边的目标节点 e = [0] * N # 存储下一条边的索引 ne = [0] * N # 边的索引 idx = 0 # 添加一条边a-\u0026gt;b def add(a, b): global idx e[idx] = b ne[idx] = h[a] h[a] = idx idx += 1 # 初始化 idx = 0 for i in range(N): h[i] = -1 树和图的遍历 DFS def dfs(u): st[u] = True # st[u] 表示点u已经被遍历过 for i in range(h[u], -1, -1): j = e[i] if not st[j]: dfs(j) BFS from queue import Queue q = Queue() st[1] = True # 表示1号点已经被遍历过 q.put(1) while not q.empty(): t = q.get() for i in range(h[t], -1, -1): j = e[i] if not st[j]: st[j] = True # 表示点j已经被遍历过 q.put(j) 拓扑排序 def topsort(): hh = 0 tt = -1 # d[i] 存储点i的入度 for i in range(1, n + 1): if d[i] == 0: q.append(i) tt += 1 while hh \u0026lt;= tt: t = q[hh] hh += 1 for i in range(h[t], -1, -1): j = e[i] d[j] -= 1 if d[j] == 0: q.append(j) tt += 1 # 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。 return tt == n - 1 LCA def lca(x,y): if dep[x] \u0026lt; dep[y]: x,y = y,x d = dep[x]-dep[y] while d: # 循环直到深度差为 0 v = d \u0026amp; -d # 获取 d 的最低位的 1 所在的位置 i = v.bit_length() - 1 # 计算最低位的位置索引 x = fa[i][x] # 将节点 x 上移到和节点 y 同一深度 d -= v # 更新深度差 if x==y: return x for k in range(K-1, -1, -1): if fa[k][x] != fa[k][y]: x = fa[k][x] y = fa[k][y] return fa[0][x] 最短路 单元最短路\n​\t所有边权为正：\n​\t朴素版Dijkstra $O(n^2)$,堆优化版的Dijkstra $O(mlogn)$,\n​\t存在负权边\n​\tBellman-Ford $O(nm)$, SPFA 队列优化的Bellman-Ford, 一般情况：$O(m)$ 最坏情况：$O(nm)$\n多元汇最短路：\n​\tFloyed $O(n^3)$\n朴素Dijkstra N = int(5e2)+10 INF = 0x3f3f3f3f g = [[INF]*N for _ in range(N)] #g = defaultdict(lambda:defaultdict(lambda:INF)) 同样的效果 dis = [INF]*N st = [False]*N def dijkstra(): dis[1]=0 for i in range(n-1): t=-1 for j in range(1,n+1): if not st[j] and (t==-1 or dis[j]\u0026lt;dis[t]): t=j for j in range(1,n+1): dis[j]=min(dis[j], dis[t] + g[t][j]) st[t]=True if dis[n]==INF: return -1 return dis[n] n, m = map(int, input().split()) for _ in range(m): x, y, z = map(int ,input().split()) g[x][y] = min(g[x][y], z) print(dijkstra()) 堆优化版Dijkstra from heapq import * import sys input = lambda:sys.stdin.readline().strip() N = 150010 INF = 0x3f3f3f3f e, ne, head, w, dis= [0]*N, [0]*N, [-1]*N, [0]*N, [INF]*N st = [False]*N idx=0 def add(a, b, x): global idx e[idx]=b w[idx]=x ne[idx]=head[a] head[a]=idx idx+=1 def dijkstra(): dis[1]=0 h=[] heappush(h, (0,1)) while h: dist, ver = heappop(h) if st[ver]: continue st[ver]=True i=head[ver] while i!=-1: j=e[i] if not st[j] and dis[j]\u0026gt;dist+w[i]: dis[j]=dist+w[i] heappush(h, (dis[j], j)) i=ne[i] if dis[n]==INF: print(-1) else: print(dis[n]) n, m = map(int, input().split()) for _ in range(m): x, y, z = map(int, input().split()) add(x,y,z) dijkstra() 另一种写法 from heapq import * from collections import defaultdict import sys input=lambda:sys.stdin.readline().strip() N, INF = 150010, 0x3f3f3f3f dis, st = [INF]*N, [False]*N g=defaultdict(list) def dijkstra(): dis[1]=0 h=[] heappush(h, (0, 1)) while h: dist, ver = heappop(h) if st[ver]: continue st[ver]=True for y, z in g[ver]: if dis[y]\u0026gt;dis[ver]+z: dis[y]=dis[ver]+z heappush(h, (dis[y], y)) if dis[n]==INF: print(-1) else: print(dis[n]) n, m = map(int, input().split()) for _ in range(m): x,y,z = map(int, input().split()) g[x].append((y, z)) dijkstra() Bellman-Ford # n表示点数，m表示边数 dist = [float(\u0026#39;inf\u0026#39;)] * (n + 1) # dist[x]存储1到x的最短路距离 # 边，a表示出点，b表示入点，w表示边的权重 edges = [] # 求1到n的最短路距离，如果无法从1走到n，则返回-1。 def bellman_ford(): dist[1] = 0 # 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。 for i in range(n): for j in range(m): a, b, w = edges[j][\u0026#39;a\u0026#39;], edges[j][\u0026#39;b\u0026#39;], edges[j][\u0026#39;w\u0026#39;] if dist[b] \u0026gt; dist[a] + w: dist[b] = dist[a] + w if dist[n] \u0026gt; float(\u0026#39;inf\u0026#39;) / 2: return -1 return dist[n] SPFA from collections import defaultdict, deque import sys input = lambda:sys.stdin.readline().strip() N, INF = int(1e5+10), 0x3f3f3f3f dis, st = [INF]*N, [False]*N g=defaultdict(list) def spfa(): q=deque() q.append(1) st[1]=True dis[1]=0 while q: x=q.popleft() st[x]=False for y, z in g[x]: if dis[y]\u0026gt;dis[x]+z: dis[y]=dis[x]+z if not st[y]: st[y]=True q.append(y) if dis[n]==INF: print(\u0026#39;impossible\u0026#39;) else: print(dis[n]) n, m = map(int, input().split()) for _ in range(m): x, y, z = map(int, input().split()) g[x].append((y, z)) spfa() 判断负环 from collections import deque N = int(1e5+10) INF = 0x3f3f3f3f n = 0 # 总点数 h = [-1] * N # 邻接表存储所有边 e, ne, w = [0] * N, [0] * N, [0] * N idx = 0 dist, cnt = [INF] * N, [0] * N # dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数 st = [False] * N # 存储每个点是否在队列中 # 如果存在负环，则返回True，否则返回False。 def spfa(): # 不需要初始化dist数组 # 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环 q = deque() for i in range(1, n + 1): q.append(i) st[i] = True while q: t = q.popleft() st[t] = False i = h[t] while i != -1: j = e[i] if dist[j] \u0026gt; dist[t] + w[i]: dist[j] = dist[t] + w[i] cnt[j] = cnt[t] + 1 if cnt[j] \u0026gt;= n: return True # 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环 if not st[j]: q.append(j) st[j] = True i = ne[i] return False # Example usage: # n = 5 # h = [-1, 2, 1, 4, 3, -1] # e = [0, 2, 1, 4, 3, 0] # ne = [1, -1, 3, -1, -1, 2] # w = [0, 1, 2, 3, 4, 5] # if spfa(): # print(\u0026#34;Exist negative cycle\u0026#34;) # else: # print(\u0026#34;No negative cycle\u0026#34;) floyd INF = float(\u0026#39;inf\u0026#39;) # 初始化距离矩阵d，d[a][b]表示a到b的最短距离 def initialize(n): d = [[0 if i == j else INF for j in range(n)] for i in range(n)] return d # Floyd算法求解最短路径 def floyd(d, n): for k in range(n): for i in range(n): for j in range(n): d[i][j] = min(d[i][j], d[i][k] + d[k][j]) return d # Example usage: # n = 5 # d = initialize(n) # d = floyd(d, n) # print(d) Prim INF = float(\u0026#39;inf\u0026#39;) # Prim算法求解最小生成树的权重之和 def prim(n, g): dist = [INF] * (n + 1) st = [False] * (n + 1) res = 0 for i in range(n): t = -1 for j in range(1, n + 1): if not st[j] and (t == -1 or dist[t] \u0026gt; dist[j]): t = j if i and dist[t] == INF: return INF if i: res += dist[t] st[t] = True for j in range(1, n + 1): dist[j] = min(dist[j], g[t][j]) return res # Example usage: # n = 5 # g = [[0] * (n + 1) for _ in range(n + 1)] # dist = prim(n, g) # print(dist) Kruskal INF = float(\u0026#39;inf\u0026#39;) # 并查集的查找操作 def find(x, p): if p[x] != x: p[x] = find(p[x], p) return p[x] # Kruskal算法求解最小生成树的权重之和 def kruskal(n, m, edges): edges.sort(key=lambda x: x[2]) # 按照边权重对边进行排序 p = [i for i in range(n + 1)] # 初始化并查集的父节点数组 res = 0 cnt = 0 for edge in edges: a, b, w = edge a = find(a, p) b = find(b, p) if a != b: # 如果两个连通块不连通，则将这两个连通块合并 p[a] = b res += w cnt += 1 if cnt \u0026lt; n - 1: return INF return res # Example usage: # n, m = 5, 7 # edges = [(1, 2, 2), (1, 3, 5), (1, 4, 6), (2, 3, 1), (2, 4, 3), (3, 4, 4), (4, 5, 7)] # min_spanning_tree_weight = kruskal(n, m, edges) # print(min_spanning_tree_weight) 染色法 # 定义全局变量 N = 10005 # 根据需要修改 M = 20005 # 根据需要修改 h = [-1] * N # 邻接表头 e, ne = [0] * M, [0] * M # 邻接表存储图 idx = 0 # 邻接表索引 color = [-1] * N # 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色 # 深度优先搜索进行着色 def dfs(u, c): color[u] = c i = h[u] while i != -1: j = e[i] if color[j] == -1: if not dfs(j, 1 - c): return False elif color[j] == c: return False i = ne[i] return True # 检查图是否是二分图 def check(n): flag = True for i in range(1, n + 1): if color[i] == -1: if not dfs(i, 0): flag = False break return flag # Example usage: # n = 5 # h = [-1, 2, -1, 4, -1, 4] # 邻接表头 # e = [0, 3, 0, 1, 0, 4] # 邻接表存储图 # ne = [1, -1, -1, 2, 5, -1] # 邻接表存储图 # if check(n): # print(\u0026#34;Graph is a bipartite graph.\u0026#34;) # else: # print(\u0026#34;Graph is not a bipartite graph.\u0026#34;) 匈牙利算法 N = 1005 # 根据需要修改 M = 100005 # 根据需要修改 h = [-1] * N # 邻接表头 e, ne = [0] * M, [0] * M # 邻接表存储所有边，只存储从第二个集合指向第一个集合的边 idx = 0 # 邻接表索引 match = [0] * N # 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个 st = [False] * N # 表示第二个集合中的每个点是否已经被遍历过 # 匈牙利算法中的深度优先搜索寻找增广路 def find(x): for i in range(h[x]): j = e[i] if not st[j]: st[j] = True if match[j] == 0 or find(match[j]): match[j] = x return True return False # 求最大匹配数 def hungarian(n1, n2): res = 0 for i in range(1, n1 + 1): st = [False] * N # 重置st数组 if find(i): res += 1 return res # Example usage: # n1, n2 = 5, 5 # h = [-1, 2, 3, 4, 0, 0] # 邻接表头 # e = [1, 2, 3, 4, 0, 0] # 邻接表存储所有边，只存储从第二个集合指向第一个集合的边 # ne = [1, 2, 3, 4, -1, -1] # 邻接表存储所有边，只存储从第二个集合指向第一个集合的边 # max_matching = hungarian(n1, n2) # print(max_matching) 数学 试除法判定质数 # 判断一个数是否是素数 def is_prime(x): if x \u0026lt; 2: return False for i in range(2, int(x ** 0.5) + 1): if x % i == 0: return False return True # Example usage: # result = is_prime(17) # print(result) # Output: True 试除法分解质因数 # 因数分解函数 def divide(x): i = 2 while i \u0026lt;= x ** 0.5: if x % i == 0: s = 0 while x % i == 0: x //= i s += 1 print(i, s) i += 1 if x \u0026gt; 1: print(x, 1) print() # Example usage: # divide(36) 朴素筛法求素数 N = 1000005 # 根据需要修改 primes = [] # 存储所有素数 st = [False] * N # st[x]存储x是否被筛掉 # 筛素数函数 def get_primes(n): global primes global st for i in range(2, n + 1): if not st[i]: primes.append(i) for j in range(i, n + 1, i): st[j] = True # Example usage: # get_primes(100) # print(primes) 线性筛法求素数 N = 1000005 # 根据需要修改 primes = [] # 存储所有素数 st = [False] * N # st[x]存储x是否被筛掉 # 筛素数函数 def get_primes(n): global primes global st for i in range(2, n + 1): if not st[i]: primes.append(i) for j in range(len(primes)): if primes[j] * i \u0026gt; n: break st[primes[j] * i] = True if i % primes[j] == 0: break # Example usage: # get_primes(100) # print(primes) 试除法求所有约数 # 获取因数函数 def get_divisors(x): res = [] i = 1 while i \u0026lt;= x ** 0.5: if x % i == 0: res.append(i) if i != x // i: res.append(x // i) i += 1 res.sort() return res # Example usage: # divisors = get_divisors(36) # print(divisors) 约数个数和约数之和 如果 N = p1^c1 * p2^c2 * ... *pk^ck\r约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1)\r约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck) gcd def gcd(a, b): return gcd(b, a % b) if b else a 求欧拉函数 # 计算欧拉函数 def phi(x): res = x i = 2 while i \u0026lt;= x ** 0.5: if x % i == 0: res = res // i * (i - 1) while x % i == 0: x //= i i += 1 if x \u0026gt; 1: res = res // x * (x - 1) return res # Example usage: # result = phi(36) # print(result) 筛法求欧拉函数 N = 1000005 # 根据需要修改 primes = [] # 存储所有素数 euler = [0] * N # 存储每个数的欧拉函数 st = [False] * N # st[x]存储x是否被筛掉 # 获取欧拉函数数组 def get_eulers(n): global primes global euler global st euler[1] = 1 for i in range(2, n + 1): if not st[i]: primes.append(i) euler[i] = i - 1 for j in range(len(primes)): if primes[j] * i \u0026gt; n: break t = primes[j] * i st[t] = True if i % primes[j] == 0: euler[t] = euler[i] * primes[j] break euler[t] = euler[i] * (primes[j] - 1) # Example usage: # get_eulers(100) # print(euler) 快速幂 # 快速幂函数 def qmi(m, k, p): res, t = 1 % p, m while k: if k \u0026amp; 1: res = res * t % p t = t * t % p k \u0026gt;\u0026gt;= 1 return res # Example usage: # result = qmi(2, 10, 1000000007) # print(result) 拓展欧几里得 # 求 x, y，使得 ax + by = gcd(a, b) def exgcd(a, b, x, y): if b == 0: x[0], y[0] = 1, 0 return a d = exgcd(b, a % b, y, x) y[0] -= (a // b) * x[0] return d # Example usage: # x = [0] # y = [0] # gcd = exgcd(30, 20, x, y) # print(\u0026#34;x:\u0026#34;, x[0], \u0026#34;y:\u0026#34;, y[0], \u0026#34;gcd:\u0026#34;, gcd) 高斯消元 eps = 1e-8 # 根据需要调整 # a 是增广矩阵，n 是矩阵维度 def gauss(a, n): c, r = 0, 0 for c in range(n): t = r for i in range(r, n): if abs(a[i][c]) \u0026gt; abs(a[t][c]): t = i if abs(a[t][c]) \u0026lt; eps: continue for i in range(c, n + 1): a[r][i], a[t][i] = a[t][i], a[r][i] for i in range(n, c - 1, -1): a[r][i] //= a[r][c] for i in range(r + 1, n): if abs(a[i][c]) \u0026gt; eps: for j in range(n, c - 1, -1): a[i][j] -= a[r][j] * a[i][c] r += 1 if r \u0026lt; n: for i in range(r, n): if abs(a[i][n]) \u0026gt; eps: return 2 # 无解 return 1 # 有无穷多组解 for i in range(n - 1, -1, -1): for j in range(i + 1, n): a[i][n] -= a[i][j] * a[j][n] return 0 # 有唯一解 # Example usage: # a = [[2, 1, -1, 8], [-3, -1, 2, -11], [-2, 1, 2, -3]] # n = 3 # result = gauss(a, n) # print(result) 递归法求组合数 N = 1005 # 根据需要调整 mod = 1000000007 # 根据需要调整 c = [[0] * N for _ in range(N)] # 初始化二维数组 # 计算组合数 for i in range(N): for j in range(i + 1): if j == 0: c[i][j] = 1 else: c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod # Example usage: # result = c[5][2] # 获取从5个苹果中选2个的方案数 # print(result) 通过预处理逆元的方式求组合数 mod = 1000000007 # 根据需要调整 N = 1005 # 根据需要调整 fact = [0] * N # 存储阶乘的余数 infact = [0] * N # 存储阶乘逆元的余数 # 快速幂模板 def qmi(a, k, p): res = 1 while k: if k \u0026amp; 1: res = (res * a) % p a = (a * a) % p k \u0026gt;\u0026gt;= 1 return res # 预处理阶乘的余数和阶乘逆元的余数 fact[0] = infact[0] = 1 for i in range(1, N): fact[i] = (fact[i - 1] * i) % mod infact[i] = (infact[i - 1] * qmi(i, mod - 2, mod)) % mod # 计算组合数 def C(n, m): if m \u0026gt; n: return 0 return (fact[n] * infact[m] % mod * infact[n - m] % mod) # Example usage: # result = C(5, 2) # 获取组合数 C(5, 2) # print(result) Lucas定理 p = 1000000007 # 根据需要调整 # 快速幂模板 def qmi(a, k): res = 1 while k: if k \u0026amp; 1: res = (res * a) % p a = (a * a) % p k \u0026gt;\u0026gt;= 1 return res # 通过定理求组合数C(a, b) def C(a, b): res = 1 for i in range(1, b + 1): res = (res * (a - i + 1)) % p res = (res * qmi(i, p - 2)) % p return res # Lucas定理计算组合数 def lucas(a, b): if a \u0026lt; p and b \u0026lt; p: return C(a, b) return (C(a % p, b % p) * lucas(a // p, b // p)) % p # Example usage: # result = lucas(10, 5) # 计算组合数 C(10, 5) # print(result) 分解质因数法求组合数 # 获取素数列表 def get_primes(n): primes = [] st = [False] * (n + 1) for i in range(2, n + 1): if not st[i]: primes.append(i) for j in range(len(primes)): if primes[j] * i \u0026gt; n: break st[primes[j] * i] = True if i % primes[j] == 0: break return primes # 获取n!中p的次数 def get(n, p): res = 0 while n: res += n // p n //= p return res # 高精度乘法 def mul(a, b): res = [0] * (len(a) + len(b)) for i in range(len(a)): t = 0 for j in range(len(b)): t += res[i + j] + a[i] * b[j] res[i + j] = t % 10 t //= 10 res[i + len(b)] += t while len(res) \u0026gt; 1 and res[-1] == 0: res.pop() return res # 计算组合数 def calc_combination(a, b): primes = get_primes(a) sum = [0] * len(primes) for i in range(len(primes)): p = primes[i] sum[i] = get(a, p) - get(b, p) - get(a - b, p) res = [1] for i in range(len(primes)): for j in range(sum[i]): res = mul(res, [primes[i]]) return res # Example usage: # result = calc_combination(10, 5) # 计算组合数 C(10, 5) # print(\u0026#39;\u0026#39;.join(map(str, result[::-1]))) 题目 日期差值 mm = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30,31, 30, 31] def day(x): y = int(x/10000) m = int((x/100)%100) d = x%100 mm[2]=29 if (y%4==0 and y%100!=0) or y%400==0 else 28 for i in range(1, m): d+=mm[i] for i in range(1, y): d+=366 if (i%4==0 and i%100!=0) or i%400==0 else 365 return d while True: try: x=int(input()) y=int(input()) print( abs(day(x)-day(y))+1 ) except: break 特殊排序 # Forward declaration of compare API. # def compare(a, b): # @param a, b int # @return bool # return bool means whether a is less than b. class Solution(object): def specialSort(self, N): \u0026#34;\u0026#34;\u0026#34; :type N: int :rtype: List[int] \u0026#34;\u0026#34;\u0026#34; a = [1] for i in range(2, N+1): l, r = 0, len(a)-1 while l\u0026lt;r: mid = (l+r)\u0026gt;\u0026gt;1 if compare(i, a[mid]): r=mid else: l=mid+1 a[r+1:]=a[r:] a[r]=i if compare(a[r+1],a[r]): a[r], a[r+1] = a[r+1], a[r] return a 单链表 N = int(1e5+10) h, idx, e, ne = -1, 1, [0]*N, [0]*N def insert(x): global h, idx e[idx]=x ne[idx]=h h=idx idx+=1 def add(k, x): global h,idx e[idx]=x ne[idx]=ne[k] ne[k]=idx idx+=1 def remove(k): global h if k==0: h = ne[h] else: ne[k]=ne[ne[k]] n=int(input()) for _ in range(n): op = input().split() if op[0]==\u0026#39;H\u0026#39;: insert(int(op[1])) elif op[0]==\u0026#39;D\u0026#39;: remove(int(op[1])) elif op[0]==\u0026#39;I\u0026#39;: add(int(op[1]), int(op[2])) i=h while i!=-1: print(e[i], end=\u0026#34; \u0026#34;) i=ne[i] DP 数字三角形 f=[] n=int(input()) for _ in range(n): f.append([int(x) for x in input().split()]) for i in range(n-2,-1,-1): for j in range(i+1): f[i][j]=max(f[i+1][j], f[i+1][j+1])+f[i][j] print(f[0][0]) 背包 空间优化成1维之后，只有完全背包问题的体积是从小到大循环的\n01背包 N = int(1e3+10) f=[ 0 for _ in range(N) ] n,v=map(int,input().split()) for i in range(n): vi,wi=map(int,input().split()) for j in range(v, vi-1,-1): f[j]=max(f[j],f[j-vi]+wi) print(f[v]) 多重背包 单调队列 MN = int(2e4+10) f=[0 for _ in range(MN)] q=[0 for _ in range(MN)] g=[0 for _ in range(MN)] N,V = map(int, input().split()) for i in range(N): v,w,s=map(int, input().split()) g=f[:] for j in range(v): hh,tt=0,-1 for k in range(j,V+1,v): while hh\u0026lt;=tt and q[hh]\u0026lt;k-s*v: hh+=1 while hh\u0026lt;=tt and g[q[tt]]+(k-q[tt])//v*w \u0026lt;= g[k]: tt-=1 tt+=1 q[tt]=k f[k]=g[q[hh]]+(k-q[hh])//v*w print(f[V]) 二维费用背包 N = int(1e2+10) f=[[0]*N for _ in range(N)] n,V,M = map(int , input().split()) for i in range(n): v,m,w=map(int , input().split()) for j in range(V,v-1,-1): for k in range(M, m-1, -1): f[j][k]=max(f[j][k], f[j-v][k-m]+w) print(f[V][M]) 宠物小精灵 N = int(1e3+10) M = int(5e2+10) f=[[0]*M for _ in range(N)] n,m,kk = map(int, input().split()) for i in range(kk): v1,v2=map(int, input().split()) for j in range(n, v1-1, -1): for k in range(m-1,v2-1,-1): f[j][k]=max(f[j][k], f[j-v1][k-v2]+1) print(f[n][m-1], end=\u0026#34; \u0026#34;) t=m-1 while t\u0026gt;0 and f[n][m-1]==f[n][t-1]: t-=1 print(m-t) 潜水 最多\n恰好\n最少\nN = int(1e2+10) INF = 0x3f3f3f3f f=[ [INF]*N for _ in range(N) ] f[0][0]=0 m,n=map(int, input().split()) k=int(input()) for i in range(k): a,b,c=map(int, input().split()) for j in range(m,-1,-1): for k in range(n,-1,-1): f[j][k]=min(f[j][k], f[max(j-a, 0)][max(k-b, 0)]+c) print(f[m][n]) 庆功会 N = int(6e3+10) f=[0 for _ in range(N)] n,m = map(int, input().split()) for i in range(n): v,w,s=map(int, input().split()) for j in range(1,s+1): for k in range(m, v-1, -1): f[k]=max(f[k], f[k-v]+w) print(f[m]) 分组背包 分组背包的顺序：\n物品组 体积 决策 N = int(1e2+10) f=[0 for _ in range(N)] v=[0 for _ in range(N)] w=[0 for _ in range(N)] N,V = map(int, input().split()) for i in range(N): # 物品组 s=int(input()) for j in range(s): v[j],w[j]=map(int, input().split()) for j in range(V,-1,-1): #体积 for k in range(s): #决策 if j\u0026gt;=v[k]: f[j]=max(f[j], f[j-v[k]]+w[k]) print(f[V]) 机器分配 多重背包变种\nN = 100 f=[0 for _ in range(N)] w=[[0]*N for _ in range(N)] c=[[0]*N for _ in range(N)] n,m=map(int, input().split()) for i in range(n): w[i]=[0]+[int(x) for x in input().split()] for i in range(n): for j in range(m,-1,-1): for k in range(1,j+1): if f[j-k]+w[i][k] \u0026gt; f[j]: f[j]=f[j-k]+w[i][k] c[i][j]=k print(f[m]) t=m for i in range(n-1,-1,-1): print(i+1, c[i][t]) t-=c[i][t] 金明的预算方案 N = 80 M = 32010 f=[0 for _ in range(M)] mas=[[0,0] for _ in range(N)] ser=[[] for _ in range(N)] n,m=map(int,input().split()) for i in range(1,m+1): v,p,q=map(int, input().split()) if q==0: mas[i]=[v,v*p] else: ser[q].append((v, v*p)) for i in range(1,m+1): for j in range(n, -1, -1): for k in range( (1 \u0026lt;\u0026lt; len(ser[i]) )): v,p=mas[i] for l in range(len(ser[i])): if k\u0026gt;\u0026gt;l \u0026amp; 1: v+=ser[i][l][0] p+=ser[i][l][1] if j\u0026gt;=v: f[j]=max(f[j], f[j-v]+p) print(f[n]) 摘花生 N = 105 f=[ [0]*N for _ in range(N)] t=int(input()) for _ in range(t): r,c=map(int, input().split()) for i in range(1,r+1): f[i] = [0] + [int(x) for x in input().split()] for j in range(1,c+1): f[i][j]+=max(f[i-1][j], f[i][j-1]) print(f[r][c]) 最小通行费 N = int(1e3+10) INF = 0x3f3f3f3f f = [[INF]*N for _ in range(N)] f[1][0]=f[0][1]=0 n=int(input()) for i in range(1,n+1): f[i]=[INF]+[int(x) for x in input().split()] for i in range(1,n+1): for j in range(1,n+1): f[i][j]+=min(f[i-1][j],f[i][j-1]) print(f[n][n]) 方格 N = 15 g = [[0]*N for _ in range(N)] f = [[[[0]*N for _ in range(N)] for _ in range(N)] for _ in range(N)] n=int(input()) while True: r,c,x=map(int,input().split()) if r==0 and c==0 and x==0: break g[r][c]=x for i in range(1,n+1): for j in range(1,n+1): for k in range(1,n+1): for l in range(1,n+1): if i==k and j==l: f[i][j][k][l] = max(f[i-1][j][k-1][l], f[i-1][j][k][l-1], f[i][j-1][k-1][l], f[i][j-1][k][l-1]) + g[i][j] else: f[i][j][k][l] = max(f[i-1][j][k-1][l], f[i-1][j][k][l-1], f[i][j-1][k-1][l], f[i][j-1][k][l-1]) + g[i][j] + g[k][l] print(f[n][n][n][n]) N = 55 g=[[0]*N for _ in range(N)] f=[[[[0]*N for _ in range(N)] for _ in range(N)] for _ in range(N)] m,n=map(int, input().split()) for i in range(1,m+1): g[i]=[0]+[int(x) for x in input().split()] for i in range(1,m+1): for j in range(1,n+1): for k in range(1,m+1): for l in range(1,n+1): if i==k and j==l: f[i][j][k][l]=max(f[i-1][j][k-1][l], f[i-1][j][k][l-1], f[i][j-1][k-1][l], f[i][j-1][k][l-1])+g[i][j] else: f[i][j][k][l]=max(f[i-1][j][k-1][l], f[i-1][j][k][l-1], f[i][j-1][k-1][l], f[i][j-1][k][l-1])+g[i][j]+g[k][l] print(f[m][n][m][n]) LIS N=int(1e3+10) f=[1 for _ in range(N)] a=[] n=int(input()) a=[0]+[int(x) for x in input().split()] for i in range(1,n+1): for j in range(1,i): if a[i]\u0026gt;a[j]: f[i]=max(f[i],f[j]+1) ans = 0 for i in range(1,n+1): ans = max(ans, f[i]) print(ans) LCS N = int(1e3+10) f=[[0]*N for _ in range(N)] a=\u0026#34;\u0026#34; b=\u0026#34;\u0026#34; n,m=map(int, input().split()) a=input() b=input() for i in range(n): for j in range(m): f[i][j]=max(f[i-1][j], f[i][j-1]) if a[i]==b[j]: f[i][j]=f[i-1][j-1]+1 print(f[n-1][m-1]) 最大上升子序列和 import copy a=[] f=[] ans=0 n=int(input()) a=[int(x) for x in input().split()] f=copy.deepcopy(a) for i in range(n): for j in range(i): if a[i]\u0026gt;a[j]: f[i]=max(f[i], f[j]+a[i]) for i in range(n): ans = max(ans, f[i]) print(ans) N = int(1e3+10) f=[0 for _ in range(N)] ans = 0 n=int(input()) a=[0]+[int(x) for x in input().split()] for i in range(1,n+1): f[i]=a[i] for j in range(1,i): if a[i]\u0026gt;a[j]: f[i]=max(f[i], f[j]+a[i]) ans = max(ans, f[i]) print(ans) 最大上升子序列II N = int(1e5+10) INF = 0x3f3f3f3f q=[INF for _ in range(N)] ans=0 n=int(input()) a=[0]+[int(x) for x in input().split()] for i in range(1,n+1): l,r=0,i while l\u0026lt;r: mid = (l+r+1)\u0026gt;\u0026gt;1 if q[mid]\u0026lt;a[i]: l=mid else: r=mid-1 ans = max(ans, l+1) q[l+1]=min(q[l+1], a[i]) print(ans) N = int(1e5+10) q=[0 for _ in range(N)] len = 0 n=int(input()) a=[0]+[int(x) for x in input().split()] for i in range(1, n+1): l,r=0,len while l\u0026lt;r: mid = (l+r+1)\u0026gt;\u0026gt;1 if q[mid]\u0026lt;a[i]: l=mid else: r=mid-1 len=max(len, l+1) q[l+1]=a[i] print(len) N = int(1e5+10) q=[0 for _ in range(N)] len = 0 n=int(input()) a=[0]+[int(x) for x in input().split()] for i in range(1,n+1): l,r=0,len while l\u0026lt;r: mid = (l+r+1)\u0026gt;\u0026gt;1 if q[mid]\u0026gt;=a[i]: r=mid-1 else: l=mid len = max(len, l+1) q[l+1]=a[i] print(len) 二分原则：\n有单调性，并且二分之后能保持单调性\n怪盗基德的滑翔翼 N = int(1e3+10) f=[0 for _ in range(N)] t=int(input()) while t: t-=1 ans=0 n=int(input()) a=[0]+[int(x) for x in input().split()] for i in range(1,n+1): f[i]=1 for j in range(1,i): if a[i]\u0026gt;a[j]: f[i]=max(f[i], f[j]+1) ans = max(ans, f[i]) for i in range(n,0,-1): f[i]=1 for j in range(n,i,-1): if a[i]\u0026gt;a[j]: f[i]=max(f[i], f[j]+1) ans = max(ans, f[i]) print(ans) 登山 N = int(1e3+10) f=[1 for _ in range(N)] g=[1 for _ in range(N)] ans = 0 n=int(input()) a=[0]+[int(x) for x in input().split()] for i in range(1,n+1): for j in range(1,i): if a[i]\u0026gt;a[j]: f[i]=max(f[i], f[j]+1) for i in range(n,0,-1): for j in range(n,i,-1): if a[i]\u0026gt;a[j]: g[i]=max(g[i], g[j]+1) for i in range(1,n+1): ans = max(ans, f[i]+g[i]-1) print(ans) 合唱队形 N = int(1e3+10) f=[1 for _ in range(N)] g=[1 for _ in range(N)] ans = 0 n=int(input()) a=[0]+[int(x) for x in input().split()] for i in range(1,n+1): for j in range(1,i): if a[i]\u0026gt;a[j]: f[i]=max(f[i], f[j]+1) for i in range(n,0,-1): for j in range(n,i,-1): if a[i]\u0026gt;a[j]: g[i]=max(g[i], g[j]+1) for i in range(1,n+1): ans = max(ans, f[i]+g[i]-1) print(n-ans) 友好城市 N = int(5e3+10) a=[(-1,-1)] f=[1 for _ in range(N)] ans = 0 n=int(input()) for i in range(n): x,y=map(int, input().split()) a.append((x,y)) a.sort(key=lambda x:x[0]) for i in range(1,n+1): for j in range(1,i): if a[i][1]\u0026gt;a[j][1]: f[i]=max(f[i], f[j]+1) ans = max(f[i], ans) print(ans) 拦截导弹 贪心证明\nN = int(1e3+10) f=[1 for _ in range(N)] g=[0 for _ in range(N)] ans = 0 cnt = 0 a=[0]+[int(x) for x in input().split()] n=len(a) for i in range(n-1,0,-1): for j in range(n-1,i,-1): if a[i]\u0026gt;=a[j]: f[i]=max(f[i], f[j]+1) ans = max(ans, f[i]) print(ans) for i in range(1, n): k=0 while k\u0026lt;cnt and g[k]\u0026lt;a[i]: k+=1 if k\u0026gt;=cnt: cnt+=1 g[k]=a[i] print(cnt) 导弹防御系统 N = int(1e2+10) up=[0 for _ in range(N)] down=[0 for _ in range(N)] ans=0 def dfs(u, su, sd): global ans if su + sd\u0026gt;=ans: return if u==n: ans=su+sd return k=0 while k\u0026lt;su and up[k]\u0026gt;=a[u]: k+=1 t=up[k] up[k]=a[u] if k\u0026gt;=su: dfs(u+1, su+1, sd) else: dfs(u+1, su, sd) up[k]=t k=0 while k\u0026lt;sd and down[k]\u0026lt;=a[u]: k+=1 t=down[k] down[k]=a[u] if k\u0026gt;=sd: dfs(u+1, su, sd+1) else: dfs(u+1, su, sd) down[k]=t while True: n=int(input()) ans = n if n==0: break a=[int(x) for x in input().split()] dfs(0,0,0) print(ans) 最长公共上升子序列 N = int(3e3+10) f=[[0]*N for _ in range(N)] ans=0 n=int(input()) a=[0]+[int(x) for x in input().split()] b=[0]+[int(x) for x in input().split()] for i in range(1,n+1): maxv=1 for j in range(1,n+1): f[i][j]=f[i-1][j] if a[i]==b[j]: f[i][j]=max(f[i][j], maxv) if a[i]\u0026gt;b[j]: maxv=max(maxv, f[i][j]+1) for i in range(1,n+1): ans = max(ans, f[n][i]) print(ans) 状态机模型 闫氏DP分析法——状态机分析法\nN = int(1e5+10) t=int(input()) while t: t-=1 f=[[0]*2 for _ in range(N)] n=int(input()) a=[0]+[int(x) for x in input().split()] f[1][0]=0 f[1][1]=a[1] for i in range(2,n+1): f[i][0]=max(f[i-1][1],f[i-1][0]) f[i][1]=max(f[i-1][0], f[i-2][1])+a[i] print(max(f[n][0], f[n][1])) 买卖股票 IV K = 110 INF = 0x3f3f3f3f f=[[[-INF]*2 for _ in range(K)] for _ in range(2)] n,k = map(int ,input().split()) w=[0]+[int(x) for x in input().split()] f[1][0][0]=0 t=0 for i in range(1,n+1): for j in range(k+1): f[t][j][0]=max(f[t^1][j][0], f[t^1][j][1]+w[i]) f[t][j][1]=max(f[t^1][j][1], f[t^1][j-1][0]-w[i]) t^=1 res =max(f[t^1][i][0] for i in range(k+1)) print(res) 股票交易V N = int(1e5+10) INF = 0x3f3f3f3f f=[[-INF]*3 for _ in range(N)] n=int(input()) w=[0]+[int(x) for x in input().split()] f[0][2]=0 for i in range(1,n+1): f[i][0]=max(f[i-1][0], f[i-1][2]-w[i]) f[i][1]=f[i-1][0]+w[i] f[i][2]=max(f[i-1][1], f[i-1][2]) print(max(f[n][1], f[n][2])) 状态压缩DP 小国王 N = 13 M = 1\u0026lt;\u0026lt;N K = 110 state=[] h=[[] for _ in range(M)] cnt = [0]*M f=[[[0]*M for _ in range(K)] for _ in range(N)] def check(x): global n for i in range(n): if (x\u0026gt;\u0026gt;i)\u0026amp;1 and (x\u0026gt;\u0026gt;i+1)\u0026amp;1: return False return True def count(x): global n cnt=0 for i in range(n): if (x\u0026gt;\u0026gt;i)\u0026amp;1: cnt+=1 return cnt n,m = map(int, input().split()) for i in range(1\u0026lt;\u0026lt;n): if check(i): state.append(i) cnt[i]=count(i) for i in range(len(state)): for j in range(len(state)): a = state[i] b = state[j] if (a\u0026amp;b)==0 and check(a|b): h[i].append(j) f[0][0][0]=1 for i in range(1,n+2): for j in range(m+1): for k in range(len(state)): for t in h[k]: c = cnt[state[k]] if j\u0026gt;=c: f[i][j][state[k]]+=f[i-1][j-c][state[t]] print(f[n+1][m][0]) 愤怒的小鸟 eps = 1e-6 N = 18 M = 1\u0026lt;\u0026lt;18 INF = 0x3f3f3f3f def cmp(a,b): if abs(a-b)\u0026lt;eps: return 0 if a\u0026gt;b: return 1 return -1 t = int(input()) for _ in range(t): f = [INF]*M path = [[0]*N for _ in range(N)] q = [0]*N n,m = map(int, input().split()) for i in range(n): x,y = map(float, input().split()) q[i]=(x,y) for i in range(n): path[i][i]=1\u0026lt;\u0026lt;i #关键点：与其他点的抛物线可能都不合法，所以需要独立出一条抛物线 for j in range(n): x1,y1 = q[i] x2,y2 = q[j] if cmp(x1,x2)==0: continue a = (y1/x1-y2/x2)/(x1-x2) if cmp(a,0)\u0026gt;=0: continue b = y1/x1-a*x1 state=0 for k in range(n): x3,y3 = q[k] if cmp(a*x3*x3+b*x3, y3) == 0: state+=(1\u0026lt;\u0026lt;k) path[i][j]=state f[0]=0 for i in range(1\u0026lt;\u0026lt;n): for j in range(n): if not (i\u0026gt;\u0026gt;j)\u0026amp;1: x=j break for j in range(n): f[i | path[x][j]] = min(f[i | path[x][j]], f[i]+1) print(f[(1\u0026lt;\u0026lt;n)-1]) 集合类状态压缩DP 最短Hamilton距离 N = 22 M = 1\u0026lt;\u0026lt;20 INF = 0x3f3f3f3f f=[[INF]*N for _ in range(M)] w=[[]*N for _ in range(N)] n=int(input()) for i in range(n): w[i]=[int(_) for _ in input().split()] f[1][0]=0 for i in range(1\u0026lt;\u0026lt;n): for j in range(n): if i\u0026gt;\u0026gt;j\u0026amp;1: for k in range(n): if i\u0026gt;\u0026gt;k\u0026amp;1: f[i][j]=min(f[i][j], f[i-(1\u0026lt;\u0026lt;j)][k]+w[k][j]) print(f[(1\u0026lt;\u0026lt;n)-1][n-1]) 区间DP 石子合并\nN = 1010 INF = 0x3f3f3f3f f=[[INF]*N for _ in range(N)] s=[0]*N n = int(input()) a=[0]+[int(_) for _ in input().split()] for i in range(1,n+1): f[i][i]=0 s[i]=s[i-1]+a[i] for l in range(2,n+1): for i in range(1,n-l+2): j=i+l-1 for k in range(i,j): f[i][j] = min(f[i][j], f[i][k] + f[k+1][j] + s[j]-s[i-1]) print(f[1][n]) 环形石子合并 N = 410 w=[0]*N s=[0]*N INF = 0x3f3f3f3f f=[[-INF]*N for _ in range(N)] g=[[INF]*N for _ in range(N)] n=int(input()) a= [0]+[int(_) for _ in input().split()] for i in range(1,n+1): w[i] = w[i+n] = a[i] for i in range(1,n*2+1): s[i]=s[i-1]+w[i] for l in range(1,n+1): for i in range(1,n*2-l+2): j=i+l-1 if l==1: f[i][j]=g[i][j]=0 for k in range(i,j): f[i][j] = max(f[i][j], f[i][k]+f[k+1][j]+s[j]-s[i-1]) g[i][j] = min(g[i][j], g[i][k]+g[k+1][j]+s[j]-s[i-1]) minv, maxv = INF, -INF for i in range(1,n+1): minv = min(minv, g[i][i+n-1]) maxv = max(maxv, f[i][i+n-1]) print(minv, maxv, sep=\u0026#39;\\n\u0026#39;) 能量项链 N = 210 w=[0]*N f=[[0]*N for _ in range(N)] n = int(input()) a=[0]+[int(_) for _ in input().split()] for i in range(1,n+1): w[i]=w[i+n]=a[i] for l in range(3,n+2): for i in range(1,n*2-l+2): j=i+l-1 for k in range(i+1,j): f[i][j] = max(f[i][j], f[i][k]+f[k][j]+w[i]*w[k]*w[j]) maxv = -1 for i in range(1,n+1): maxv = max(maxv, f[i][i+n]) print(maxv) 凸多边形的划分 N = 55 INF = 1e30 f=[[INF]*N for _ in range(N)] n = int(input()) w=[0]+[int(_) for _ in input().split()] for i in range(1,n+1): f[i][i+1]=0 for l in range(3,n+1): for i in range(1, n-l+2): j=i+l-1 for k in range(i+1,j): f[i][j] = min(f[i][j], f[i][k]+f[k][j]+w[i]*w[k]*w[j]) print(f[1][n]) 加分二叉树 N = 50 def dfs(l, r): if l\u0026gt;r: return k=root[l][r] print(k,end=\u0026#39; \u0026#39;) dfs(l,k-1) dfs(k+1,r) n = int(input()) w = [0]+[int(_) for _ in input().split()] f=[[0]*N for _ in range(N)] root=[[0]*N for _ in range(N)] for l in range(1,n+1): for i in range(1,n-l+2): j=i+l-1 for k in range(i,j+1): left = 1 if k==i else f[i][k-1] right = 1 if k==j else f[k+1][j] s = left*right+w[k] if i==j: s=w[k] if f[i][j]\u0026lt;s: f[i][j]=s root[i][j]=k print(f[1][n]) dfs(1,n) 树形DP 树的最长路径 注意注意再注意，while循环链不符合要求是需要 i=ne[i]\nimport sys sys.setrecursionlimit(int(1e5+10)) N = 10010*2 e = [0]*N ne = [0]*N w = [0]*N h = [-1]*N idx = 1 ans = -1 def add(a, b, c): global idx e[idx]=b w[idx]=c ne[idx]=h[a] h[a]=idx idx+=1 def dfs(root, father): global ans dis, d1, d2 = 0,0,0 i=h[root] while i!=-1: j = e[i] if j==father: i=ne[i] # 重点 continue d = dfs(j, root)+w[i] dis = max(dis, d) if d\u0026gt;d1: d2=d1 d1=d else: d2 = max(d2, d) i=ne[i] ans = max(ans, d1+d2) return dis n = int(input()) for i in range(n-1): a,b,c = map(int, input().split()) add(a,b,c) add(b,a,c) dfs(1,-1) print(ans) 树的中心 N = 10010*2 e = [0]*N ne=[0]*N h=[-1]*N w=[0]*N d1=[0]*N d2=[0]*N s1=[0]*N up=[0]*N idx = 1 def add(a,b,c): global idx e[idx]=b w[idx]=c ne[idx]=h[a] h[a]=idx idx+=1 def dfs1(u, father): i=h[u] while i!=-1: j=e[i] if j==father: i=ne[i] continue dfs1(j,u) dis = d1[j]+w[i] if dis\u0026gt;d1[u]: d2[u]=d1[u] d1[u], s1[u]=dis, j elif dis\u0026gt;d2[u]: d2[u]=dis i=ne[i] def dfs2(u, father): i=h[u] while i!=-1: j=e[i] if j==father: i=ne[i] continue if s1[u]==j: up[j]=max(up[u], d2[u])+w[i] else: up[j]=max(up[u], d1[u])+w[i] i=ne[i] dfs2(j, u) n = int(input()) for i in range(n-1): a,b,c = map(int ,input().split()) add(a,b,c) add(b,a,c) dfs1(1,-1) dfs2(1,-1) ans = 1e10 for i in range(1,n+1): ans = min(ans, max(up[i], d1[i])) print(ans) 数字转换 N = int(5e4+10) s=[0]*N st=[False]*N e=[0]*N ne=[0]*N h=[-1]*N idx=1 ans = -1 def add(a,b): global idx e[idx]=b ne[idx]=h[a] h[a]=idx idx+=1 def dfs(u): global ans d1,d2=0,0 i=h[u] while i!=-1: j=e[i] dis = dfs(j)+1 if dis\u0026gt;d1: d2,d1=d1,dis elif dis\u0026gt;d2: d2=dis i=ne[i] ans = max(ans, d1+d2) return d1 n = int(input()) for i in range(1,n+1): for j in range(2,n+1): if i\u0026gt;n//j: break s[i*j]+=i for i in range(2,n+1): if s[i]\u0026lt;i: add(s[i], i) st[i]=True # for i in range(1,n+1): # if not st[i]: # dfs(i) dfs(1) print(ans) 没有上司的舞会 import sys sys.setrecursionlimit(int(1e4)) N = int(7e3) v=[[] for _ in range(N)] f=[[0]*2 for _ in range(N)] st=[False]*N h=[0]*N root=0 def dfs(u): f[u][1]+=h[u] for i in v[u]: dfs(i) f[u][1]+=f[i][0] f[u][0]+=max(f[i][0], f[i][1]) n = int(input()) for i in range(1,n+1): h[i]=int(input()) for i in range(n-1): l,k = map(int, input().split()) v[k].append(l) st[l]=True for i in range(1,n+1): if not st[i]: root=i dfs(root) print(max(f[root][0], f[root][1])) 单调队列优化的DP 最大子序和 N = 300010 q, s = [0]*N, [0]*N ans = -2**33 hh, tt = 0, 0 n,m = map(int, input().split()) s = [0]+list(map(int, input().split())) for i in range(1,n+1): s[i]+=s[i-1] for i in range(1,n+1): if q[hh]\u0026lt;i-m: hh+=1 ans = max(ans, s[i]-s[q[hh]]) while hh\u0026lt;=tt and s[q[tt]]\u0026gt;=s[i]: tt-=1 tt+=1 q[tt]=i print(ans) 数位DP 1081\nfrom typing import List N = 35 def init() -\u0026gt; List[List[int]]: f = [[0] * N for _ in range(N)] for i in range(N): for j in range(i + 1): if j == 0: f[i][j] = 1 else: f[i][j] = f[i - 1][j] + f[i - 1][j - 1] return f def dp(n: int, k: int, b: int, f: List[List[int]]) -\u0026gt; int: if n == 0: return 0 nums = [] while n: nums.append(n % b) n //= b res = 0 last = 0 for i in range(len(nums) - 1, -1, -1): x = nums[i] if x \u0026gt; 0: res += f[i][k - last] if x \u0026gt; 1: if k - last - 1 \u0026gt;= 0: res += f[i][k - last - 1] break else: last += 1 if last \u0026gt; k: break if i == 0 and last == k: res += 1 return res def solve(l: int, r: int, k: int, b: int) -\u0026gt; int: f = init() return dp(r, k, b, f) - dp(l - 1, k, b, f) if __name__ == \u0026#34;__main__\u0026#34;: l, r, k, b = map(int, input().split()) print(solve(l, r, k, b)) 记忆化 import heapq class Node: def __init__(self, i, j, num): self.i = i self.j = j self.num = num def main(): n, m = map(int, input().split()) f = [[1] * (m + 2) for _ in range(n + 2)] # distance g = [[0] * (m + 2) for _ in range(n + 2)] # store heights pq = [] for i in range(1, n + 1): nums = list(map(int, input().split())) for j, num in enumerate(nums, 1): g[i][j] = num heapq.heappush(pq, Node(i, j, num)) ma = -1 while pq: t = heapq.heappop(pq) i, j, nu = t.i, t.j, t.num if g[i - 1][j] \u0026lt; nu: f[i][j] = max(f[i][j], f[i - 1][j] + 1) if g[i + 1][j] \u0026lt; nu: f[i][j] = max(f[i][j], f[i + 1][j] + 1) if g[i][j - 1] \u0026lt; nu: f[i][j] = max(f[i][j], f[i][j - 1] + 1) if g[i][j + 1] \u0026lt; nu: f[i][j] = max(f[i][j], f[i][j + 1] + 1) ma = max(ma, f[i][j]) print(ma) if __name__ == \u0026#34;__main__\u0026#34;: main() 数论 试除法求约数\ndef get(x): ans = [] for i in range(1,x+1): if i\u0026gt;x//i: break if x%i==0: ans.append(i) if i!=x//i: ans.append(x//i) ans.sort() return ans n = int(input()) for i in range(n): x = int(input()) ans = get(x) for i in ans : print(i, end=\u0026#39; \u0026#39;) print() 树状数组 楼兰图腾\nimport sys input=lambda:sys.stdin.readline() M = 200010 suml, sumg = 0, 0 tr = [0]*M n = int(input()) a = [0]+[int(_) for _ in input().split()] def lowbit(x): return x\u0026amp;-x def add(x,v): while x\u0026lt;M: tr[x]+=v x+=lowbit(x) def query(x): res = 0 while x: res+=tr[x] x-=lowbit(x) return res for i in range(1,n+1): y=a[i] lw = query(y-1) lwr = y-1-lw # the lower element on the right side gr = query(n)-query(y) grr = (n-y) - gr suml += (lw*lwr) sumg += (gr*grr) add(y,1) print(sumg, suml) 线段树 # 定义树节点，l,r, val表示该节点记录的是区间[l, r]的最大值是val class Tree(): def __init__(self): self.l = 0 self.r = 0 self.lazy = 0 self.val = 0 # 二叉树是堆形式，可以用一维数组存储，注意数组长度要开4倍空间 tree = [Tree() for i in range(10*4)] # 建树，用cur\u0026lt;\u0026lt;1访问左子树，cur\u0026lt;\u0026lt;1|1访问右子树，位运算操作很方便 def build(cur, l, r): tree[cur].l, tree[cur].r, tree[cur].lazy, tree[cur].val = l, r, 0, 0 # 当l==r的时候结束递归 if l \u0026lt; r: mid = l + r \u0026gt;\u0026gt; 1 build(cur\u0026lt;\u0026lt;1, l, mid) build(cur\u0026lt;\u0026lt;1|1, mid+1, r) # 当子节点计算完成后，用子节点的值来更新自己的值 def pushup(cur): tree[cur].val = max(tree[cur\u0026lt;\u0026lt;1].val, tree[cur\u0026lt;\u0026lt;1|1].val) # 单点更新 def add(cur, x, v): if tree[cur].l == tree[cur].r: tree[cur].val += v else: mid = tree[cur].r + tree[cur].l \u0026gt;\u0026gt; 1 if x \u0026gt; mid: add(cur\u0026gt;\u0026gt;1|1, x, v) else: add(cur\u0026lt;\u0026lt;1, x, v) pushup(cur) # 将lazy标记向下传递一层 def pushdown(cur): if tree[cur].lazy: lazy = tree[cur].lazy tree[cur\u0026lt;\u0026lt;1].lazy += lazy tree[cur\u0026lt;\u0026lt;1|1].lazy += lazy tree[cur\u0026lt;\u0026lt;1].val += lazy tree[cur\u0026lt;\u0026lt;1|1].val += lazy tree[cur].lazy = 0 # 区间更新 def update(cur, l, r, v): if l \u0026lt;= tree[cur].l and tree[cur].r \u0026lt;= r: tree[cur].lazy += v tree[cur].val += v return if r \u0026lt; tree[cur].l or l \u0026gt; tree[cur].r: return if tree[cur].lazy: pushdown(cur) update(cur\u0026lt;\u0026lt;1, l, r, v) update(cur\u0026lt;\u0026lt;1|1, l, r, v) pushup(cur) # 区间查询 def query(cur, l, r): if l \u0026lt;= tree[cur].l and tree[cur].r \u0026lt;= r: return tree[cur].val if tree[cur].l \u0026gt; r or tree[cur].r \u0026lt; l: return 0 if tree[cur].lazy: pushdown(cur) return max(query(cur\u0026lt;\u0026lt;1, l, r), query(cur\u0026lt;\u0026lt;1|1)) # 测试 # ----- # --- # ------- # -- # -- build(1, 1, 10) update(1, 1, 5, 1) update(1, 7, 10, 1) update(1, 2, 8, 1) update(1, 3, 4, 1) update(1, 9, 10, 1) print(query(1, 1, 10)) def pushup(u): tr[u] = tr[u \u0026lt;\u0026lt; 1] + tr[u \u0026lt;\u0026lt; 1 | 1] def build(u, l, r): if l == r: tr[u] = 0 else: mid = (l + r) \u0026gt;\u0026gt; 1 build(u \u0026lt;\u0026lt; 1, l, mid) build(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r) pushup(u) def query(u, l, r, ql, qr): if l \u0026gt;= ql and r \u0026lt;= qr: return tr[u] mid = (l + r) \u0026gt;\u0026gt; 1 if mid==l and mid==r: return 0 res = 0 if ql \u0026lt;= mid: res = query(u \u0026lt;\u0026lt; 1, l, mid, ql, qr) if qr \u0026gt; mid: res += query(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, ql, qr) return res def modify(u, x, l, r, val): if l == r: tr[u] += val else: mid = (l + r) \u0026gt;\u0026gt; 1 if x \u0026lt;= mid: modify(u \u0026lt;\u0026lt; 1, x, l, mid, val) else: modify(u \u0026lt;\u0026lt; 1 | 1, x, mid + 1, r, val) pushup(u) 搜索深入 池塘计数 import sys from collections import deque input = lambda:sys.stdin.readline().strip() N = int(1e3+10) M = N*N g = [0]*N cnt=0 vis = [ [False]*N for _ in range(N) ] def bfs(x, y): q=deque() q.append( (x,y) ) while q: tx, ty = q[0] q.popleft() for i in range(-1, 2): for j in range(-1, 2): if i==0 and j==0: continue xx, yy = tx+i, ty+j if xx\u0026lt;0 or xx\u0026gt;=n or yy\u0026lt;0 or yy\u0026gt;=m or vis[xx][yy] or g[xx][yy]==\u0026#39;.\u0026#39;: continue vis[xx][yy]=True q.append( (xx,yy) ) n, m = map(int, input().split()) for i in range(n): g[i]=input() for i in range(n): for j in range(m): if g[i][j]!=\u0026#39;W\u0026#39; or vis[i][j]: continue bfs(i, j) cnt+=1 print(cnt) 城堡问题 import sys from collections import deque input = lambda:sys.stdin.readline().strip() N = 55 g = [] vis = [[False]*N for _ in range(N)] area = 0 cnt=0 def bfs(x, y): vis[x][y]=True q = deque() q.append((x, y)) dx, dy = [0, -1, 0, 1], [-1, 0, 1, 0] ans=1 while q: tx, ty = q.popleft() for i in range(4): xx = tx+dx[i] yy = ty+dy[i] if xx\u0026lt;0 or xx\u0026gt;=n or yy\u0026lt;0 or yy\u0026gt;=m or vis[xx][yy]: continue if (g[tx][ty]\u0026gt;\u0026gt;i)\u0026amp;1: continue ans+=1 vis[xx][yy]=True q.append((xx,yy)) return ans n, m = map(int, input().split()) for _ in range(n): g.append(list(map(int, input().split()))) for i in range(n): for j in range(m): if vis[i][j]: continue area = max(area, bfs(i, j)) cnt+=1 print(cnt) print(area) 山峰和山谷 import sys from collections import deque N = 1010 g = [] vis = [[0]*N for _ in range(N)] pek, val = 0, 0 def bfs(x, y): global higher, lower vis[x][y]=True q = deque() q.append((x,y)) while q: tx,ty = q.popleft() for i in range(-1, 2): for j in range(-1, 2): if i==0 and j==0: continue xx, yy = tx+i, ty+j if xx\u0026lt;0 or xx\u0026gt;=n or yy\u0026lt;0 or yy\u0026gt;=n: continue if g[xx][yy]!=g[tx][ty]: if g[xx][yy]\u0026gt;g[tx][ty]: higher=True elif g[xx][yy]\u0026lt;g[tx][ty]: lower=True elif not vis[xx][yy]: vis[xx][yy]=True q.append((xx,yy)) higher, lower = False, False n = int(input()) for _ in range(n): g.append(list(map(int, input().split()))) # print(g) for i in range(n): for j in range(n): if vis[i][j]: continue higher, lower = False, False bfs(i, j) if not higher:pek+=1 if not lower:val+=1 print(pek, val) Python特点 IDLE 使用 输入输出 输出列表：\nprint（*a） # 输出列表中的所有数，用空格分隔 print（*a，sep=\u0026#34;\\n\u0026#34;） #每个数单独放一行 *运算符 解包运算符： 当*运算符用于可迭代对象（如列表、元组、集合等）前面时，它可以将可迭代对象解包为多个元素。例如：\na = [1, 2, 3] print(*a) # 解包并打印出每个元素：1 2 3 可变参数： 当*运算符用于函数定义时，它表示接受任意数量的参数，并将它们作为元组传递给函数。这种用法通常称为可变参数。例如：\ndef my_func(*args): for arg in args: print(arg) my_func(1, 2, 3) # 打印出每个参数：1 2 3 扩展运算符： 当*运算符用于可迭代对象前面时，它可以将可迭代对象的元素扩展到另一个可迭代对象中。这种用法通常称为扩展运算符。例如：\na = [1, 2, 3] b = [4, 5, 6 c = [*a, *b] # 扩展a和b的元素到c中 print(c) # 输出：[1, 2, 3, 4, 5, 6] 乘法运算符： 当*运算符用于数字和可迭代对象之间时，它表示重复该可迭代对象的元素。例如：\na = [1, 2, 3] b = a * 3 # 重复a的元素3次 print(b) # 输出：[1, 2, 3, 1, 2, 3, 1, 2, 3] 和* *和**在函数定义中的使用： *args用于接收任意数量的位置参数，并将它们作为元组传递给函数。 **kwargs用于接收任意数量的关键字参数，并将它们作为字典传递给函数。 *和**在函数调用中的使用： 在函数调用时，*用于解包可迭代对象，并将其作为位置参数传递给函数。 在函数调用时，**用于解包字典，并将其作为关键字参数传递给函数。 栈模拟递归 from collections import deque def dfs(idx,p): q = deque() q.append((idx,p)) while q: idx,p = q.pop() D[idx] = D[p] + V[idx] for u in A[idx]: if u == p: continue q.append((u,idx)) 引用赋值、浅拷贝和深拷贝 Python赋值、浅拷贝、深拷贝的区别 [:]和.copy()都属于“浅拷贝”，只拷贝最外层元素，外层元素是独立内存；内层嵌套元素则通过引用方式共享，而非独立分配内存。使用 copy 模块的 copy.copy（ 浅拷贝 ）和 copy.deepcopy（深拷贝），其中deepcopy是构建了一个完全独立的对象。\n1、b = a: 赋值引用，a 和 b 都指向同一个对象。\n2、b = a.copy(): 浅拷贝, a 和 b 是一个独立的对象，但他们的子对象（内层嵌套对象）还是指向统一对象（是引用）。\n3、b = copy.deepcopy(a): 深度拷贝, a 和 b 完全拷贝了父对象及其子对象，两者是完全独立的。\n例子：\n引用赋值 \u0026gt;\u0026gt;\u0026gt;a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] \u0026gt;\u0026gt;\u0026gt;b = a[:] \u0026gt;\u0026gt;\u0026gt;print(b) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] \u0026gt;\u0026gt;\u0026gt;print(id(a)) #41946376 \u0026gt;\u0026gt;\u0026gt;print(id(b)) #41921864 或 \u0026gt;\u0026gt;\u0026gt;b = a.copy() \u0026gt;\u0026gt;\u0026gt;print(b) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] \u0026gt;\u0026gt;\u0026gt;print(id(a)) #39783752 \u0026gt;\u0026gt;\u0026gt;print(id(b)) #39759176 浅拷贝 \u0026gt;\u0026gt;\u0026gt;a = [1,2,[\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;]] \u0026gt;\u0026gt;\u0026gt;print(\u0026#39;a={}\u0026#39;.format(a)) \u0026gt;\u0026gt;\u0026gt;b = a[:] \u0026gt;\u0026gt;\u0026gt;b[0] = 9 #修改b的最外层元素，将1变成9 \u0026gt;\u0026gt;\u0026gt;b[2][0] = \u0026#39;D\u0026#39; #修改b的内嵌层元素 \u0026gt;\u0026gt;\u0026gt;print(\u0026#39;a={}\u0026#39;.format(a)) \u0026gt;\u0026gt;\u0026gt;print(\u0026#39;b={}\u0026#39;.format(b)) \u0026gt;\u0026gt;\u0026gt;print(\u0026#39;id(a)={}\u0026#39;.format(id(a))) \u0026gt;\u0026gt;\u0026gt;print(\u0026#39;id(b)={}\u0026#39;.format(id(b))) a=[1, 2, [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;]] #原始a a=[1, 2, [\u0026#39;D\u0026#39;, \u0026#39;B\u0026#39;]] #b修改内部元素A为D后，a中的A也变成了D，说明共享内部嵌套元素，但外部元素1没变。 b=[9, 2, [\u0026#39;D\u0026#39;, \u0026#39;B\u0026#39;]] #修改后的b id(a)=38669128 id(b)=38669192 深拷贝 import copy a = [1, 2, 3, 4, [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;]] #原始对象 b = a #赋值，传对象的引用 c = copy.copy(a) #对象拷贝，浅拷贝 d = copy.deepcopy(a) #对象拷贝，深拷贝 a.append(5) #修改对象a a[4].append(\u0026#39;c\u0026#39;) #修改对象a中的[\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;]数组对象 print( \u0026#39;a = \u0026#39;, a ) print( \u0026#39;b = \u0026#39;, b ) print( \u0026#39;c = \u0026#39;, c ) print( \u0026#39;d = \u0026#39;, d ) #输出： \u0026#39;a = \u0026#39;, [1, 2, 3, 4, [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;], 5] \u0026#39;b = \u0026#39;, [1, 2, 3, 4, [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;], 5] \u0026#39;c = \u0026#39;, [1, 2, 3, 4, [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]] \u0026#39;d = \u0026#39;, [1, 2, 3, 4, [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;]] 栈代替递归 增加递归深度 import sys sys.setrecursionlimit(150000000) print(sys.getrecursionlimit()) 迭代加深搜索 s = input() l = len(s) s = \u0026#34;0\u0026#34; + s # 1~l ans = set() st = {} def dfs(curlen, last): global ans, st stack = [(curlen, last)] while stack: curlen, last = stack.pop() if curlen - 2 \u0026gt; 4 and last != s[curlen - 1:curlen + 1]: if (curlen - 1, curlen) not in st: st[(curlen - 1, curlen)] = 1 ans.add(s[curlen - 1:curlen + 1]) stack.append((curlen - 2, s[curlen - 1:curlen + 1])) if curlen - 3 \u0026gt; 4 and last != s[curlen - 2:curlen + 1]: if (curlen - 2, curlen) not in st: st[(curlen - 2, curlen)] = 1 ans.add(s[curlen - 2:curlen + 1]) stack.append((curlen - 3, s[curlen - 2:curlen + 1])) dfs(l, \u0026#34;\u0026#34;) ans = sorted(ans) # 将集合转换为列表并排序 print(len(ans)) for si in ans: print(si) 加速读入 import sys print(\u0026#39;Plase input your name: \u0026#39;) name = sys.stdin.readline() print(name) 队列 Queue中有FIFO（先入先出）队列Queue，LIFO（后入先出）栈LifoQueue，和优先级队列PriorityQueue，但速度较慢，且不能不出栈地访问头部元素，想要访问头部元素，只能用get方法出栈首部获取方法返回值的来进行访问，非常不方便。\n可以用deque()模拟\nimport collections q=collections.deque() m=int(input()) for i in range(m): s = input().split() if s[0]==\u0026#39;push\u0026#39;: q.append(s[1]) elif s[0]==\u0026#39;pop\u0026#39;: q.popleft() elif s[0]==\u0026#39;empty\u0026#39;: if len(q)==0: print(\u0026#39;YES\u0026#39;) else: print(\u0026#39;NO\u0026#39;) else: print(q[0]) 栈 列表模拟\nm=int(input()) stk=[] for i in range(m): s = input().split() if s[0]==\u0026#39;push\u0026#39;: stk.append(int(s[1])) elif s[0]==\u0026#39;pop\u0026#39;: stk.pop() elif s[0]==\u0026#39;empty\u0026#39;: if len(stk)==0: print(\u0026#39;YES\u0026#39;) else: print(\u0026#39;NO\u0026#39;) else: print(stk[-1]) deque模拟\nimport collections stk = collections.deque() m=int(input()) for i in range(m): s = input().split() if s[0]==\u0026#39;push\u0026#39;: stk.appendleft( int(s[1]) ) elif s[0]==\u0026#39;pop\u0026#39;: stk.popleft() elif s[0]==\u0026#39;empty\u0026#39;: if len(stk)==0: print(\u0026#39;YES\u0026#39;) else: print(\u0026#39;NO\u0026#39;) else: print(stk[0]) Python 常用内置库 array 定长数组 argparse 命令行参数处理 bisect 二分查找 collections 有序字典、双端队列等数据结构 fractions 有理数 heapq 基于堆的优先级队列 io 文件流、内存流 itertools 迭代器 math 数学函数 os.path 系统路径等 random 随机数 re 正则表达式 struct 转换结构体和二进制数据 sys 系统信息 defaultdict() from collections import defaultdict # 创建一个 defaultdict，指定默认值为 int 类型的 0 d = defaultdict() # 修改默认值为 100 d.default_factory = lambda: (1,2) Counter() from collections import Counter # 定义一个列表 lst = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4] s = \u0026#39;abcdgsaa\u0026#39; # 使用 Counter 统计列表中元素的出现次数 c1 = Counter(lst) c2 = Counter(s) print(c1,c2, sep=\u0026#39;\\n\u0026#39;) # 使用 most_common() 方法按照元素的出现次数进行排序 sorted_items = c1.most_common() for x,y in enumerate(sorted_items): print(y[0]) heapq 建堆 ( 小根堆 )\na = [1, 5, 20, 18, 10, 200] heapq.heapify(a) print(a) 建大根堆\na = [] for i in [1, 5, 20, 18, 10, 200]: heapq.heappush(a,-i) print( list( map(lambda x:-x,a) ) ) heap_sort(heappush)\nimport heapq def heap_sort(arr): if not arr: return [] h = [] #建立空堆 for i in arr: heapq.heappush(h,i) #heappush自动建立小根堆 return [heapq.heappop(h) for i in range(len(h))] #heappop每次删除并返回列表中最小的值 # 堆排序取最小的m个数字 import heapq def heap_sort(arr, k): if not arr: return [] h=[] for i in arr: heapq.heappush(h, i) return [heapq.heappop(h) for _ in range(k)] n,m = map(int, input().split()) arr = list(map(int, input().split())) ans = heap_sort(arr, m) print(\u0026#39; \u0026#39;.join(map(str, ans))) heappushpop\n先push再pop\n[1, 18, 5, 20, 90, 10, 200] h [1, 18, 5, 20, 90, 10, 200] heapq.heappushpop(h, 300) 1 h [5, 18, 10, 20, 90, 300, 200] heapreplace\n先pop再push\nh [5, 18, 10, 20, 90, 300, 200] heapq.heapreplace(h, -1) 5 h [-1, 18, 10, 20, 90, 300, 200] heapq.merge\nimport heapq h1 = [90, 1, 5, 20, 18, 10, 200] h2 = [4,2,3,4,1000] heapq.heapify(h1) heapq.heapify(h2) print(list(heapq.merge(h1, h2))) heap.nlargest\nh1 [1, 18, 5, 20, 90, 10, 200] heapq.nlargest(2,h1,key=lambda x:-x) [1, 5] List() del list[1] 删除列表元素 列表比较 import operator operator.eq(a,b) len(list) max(list) min(list) list(seq) 将元组转换为列表 list.append(obj) list.count(obj) list.extend(seq) list.index(obj) list.insert(index, obj) list.pop([index=-1]) 删除列表中一个元素 list.remove(obj) 删除第一个匹配项 list.reverse() list.sort(key=None, reverse=False) list.clear() list.copy() tuple() 元素组合 类似list\nSortedList() from sortedcontainers import SortedList sl = SortedList() sl.add(1) print(sl[-1]) print(sl[0]) sl.update([3,2,1]) print(sl) sl.update([9,8,7]) print(sl) ##sl.clear() sl.discard(5) sl.remove(9) print(sl) sl.pop() print(sl) sl.pop(-2) print(sl) print(sl.bisect_left(12)) #返回需要插入的位置，如有存在则返回左侧的位置 print(sl.bisect_right(2)) print(sl.count(1)) print(sl.index(1)) it = sl.islice(2,4) print(list(it)) dict() 键值必须不可变\nd = {\u0026#39;1\u0026#39;:\u0026#39;a\u0026#39;, \u0026#39;2\u0026#39;:\u0026#39;b\u0026#39;, \u0026#39;99\u0026#39;:\u0026#39;xycz\u0026#39;} print(d) if \u0026#39;0\u0026#39; in d :del d[\u0026#39;0\u0026#39;] del d[\u0026#39;1\u0026#39;] print(d) {\u0026#39;1\u0026#39;: \u0026#39;a\u0026#39;, \u0026#39;2\u0026#39;: \u0026#39;b\u0026#39;, \u0026#39;99\u0026#39;: \u0026#39;xycz\u0026#39;} {\u0026#39;2\u0026#39;: \u0026#39;b\u0026#39;, \u0026#39;99\u0026#39;: \u0026#39;xycz\u0026#39;} 内置方法 len str type dict.clear() dict.copy() dict.fromkeys(seq) 将seq作为字典的键值， 字典中val为默认 dict.get(key, default=None) key in dict dict.items() dict.keys() dict.setdefault(key, default = None) dict.update(dict2) 把dict2添加到dict中 dict.values() 返回值 pop(key[,default]) 删除字典中key所对应的值并返回 popitem() 返回并删除字典中最后一对键值 set() 空集合用set() 支持 -, |, \u0026amp;, ^(不同时包含于两个集合) difference() 在原集合上修改，无返回值, difference_update() 返回新集合 union() 并集 intersection() intersection_update() 返回交集 isdisjoint() 判断两个集合是否包含相同的元素 issubset() 判断指定参数的集合是否为该调用方法的集合的子集 issuperset() 判断该方法是否为指定参数的子集 symmetric_difference() 返回两个集合中不重复的元素集合 symmetric_difference_update() 移除相同的元素，并插入没有的元素 s.add(x) 添加元素 s.update(x) 可以添加多个元素，并且可以是列表元组字典 s.remove(x) 将元素从集合中移除， 如果不存在则报错 s.discard(x) 移除元素，但是不报错 s.pop() 设置随机删除结合中的一个元素（无序集合的第一个元素） len(s) s.clear() x in s s.copy() 自定义比较参数 from functools import cmp_to_key def compare(s1, s2): if len(s1) == len(s2): for c1, c2 in zip(s1, s2): if c1 \u0026gt; c2: return 1 elif c1 \u0026lt; c2: return -1 return 0 else: if len(s1) \u0026gt; len(s2): return 1 else: return -1 things = input().split() # 使用 cmp_to_key 将比较函数转换为 key 函数 things.sort(key=cmp_to_key(compare)) print(things) __init__魔术方法 class Fib(object): def __init__(self): pass def __call__(self, num): # 将对象作为函数调用时触发 a, b = 0, 1 self.l = [] for i in range(num): self.l.append(a) a, b = b, a+b return self.l def __str__(self): # 使用print(对象）或者str (对象)的时候触发 return str(self.l) # 必须返回字符串类型 __rept__=__str__ # 使用repr(对象) f = Fib() print(f(10)) ","permalink":"https://showguan.github.io/en/posts/tech/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%AC%94%E8%AE%B0/","summary":"蓝桥杯笔记 以后做事：切记切记切记，不要一直做新题，及时复习是最重要的。 一定一定拿一个国奖，6~7月准备两个项目，八月开始投简历。 真题一定要全","title":""}]